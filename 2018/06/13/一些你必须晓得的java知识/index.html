
 <!DOCTYPE HTML>
<html lang="zh-CN,en-US,default">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>一些你必须晓得的java知识 | 山间听雨者主页</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Daniel">
    
    <meta name="description" content="对象你知不知道一个最简单的java对象中你能获取什么内容？你可能不知道，我也不晓得，所以我再这里总结下我平时遇到能从一个基本的java对象获取的信息。
对象头对象都中存放了一些对象本身的基本信息，这些基本信息是为整个java语言体系能正常高效运转经过精心的设计的。它们保证了java面向对象，支持并发">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="山间听雨者主页" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/abao.jpg">
    
    
    <link rel="apple-touch-icon" href="/img/abao.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/abao.jpg">
    

  
    <link href="/css/font-awesome.min.css" rel="stylesheet">
    
  

    <link rel="stylesheet" href="/css/style.css">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?d182ed77fc48758bf45a33835ee35745";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','.............Add your swiftype userID...............');
</script>
</head>
</html>
  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="山间听雨者主页">山间听雨者主页</a></h1>
				<h2 class="blog-motto">个人学习总结</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
                    <ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/images">图片</a></li>
					
						<li><a href="/aboutme">关于</a></li>
					
					<li>
					
						<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="st-search-inpu" maxlength="20" placeholder="Search" />
						</form>
					
					</li>
                <!--<li><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div></li>-->

				</ul>
			</nav>	
</div>
    </header>
    <div id="container" class="clearfix">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/13/一些你必须晓得的java知识/" title="一些你必须晓得的java知识" itemprop="url">一些你必须晓得的java知识</a>
  </h1>
  <p class="article-time">
    <time datetime="2018-06-13T13:22:18.000Z" itemprop="datePublished">2018-06-13</time>
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title"></strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#对象"><span class="toc-number">1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象头"><span class="toc-number">1.1.</span> <span class="toc-text">对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mark-Word结构"><span class="toc-number">1.1.1.</span> <span class="toc-text">Mark Word结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程工作的基础"><span class="toc-number">2.</span> <span class="toc-text">多线程工作的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#happen-before规则"><span class="toc-number">2.1.</span> <span class="toc-text">happen-before规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重排序"><span class="toc-number">2.2.</span> <span class="toc-text">重排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序一致性模型"><span class="toc-number">2.3.</span> <span class="toc-text">顺序一致性模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存语义"><span class="toc-number">2.4.</span> <span class="toc-text">内存语义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发的基础"><span class="toc-number">3.</span> <span class="toc-text">并发的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全"><span class="toc-number">3.1.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程优先级"><span class="toc-number">3.2.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的状态变化"><span class="toc-number">3.3.</span> <span class="toc-text">线程的状态变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些基本概念"><span class="toc-number">3.4.</span> <span class="toc-text">一些基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间的通信"><span class="toc-number">3.5.</span> <span class="toc-text">线程间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal变量"><span class="toc-number">3.6.</span> <span class="toc-text">ThreadLocal变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java锁"><span class="toc-number">4.</span> <span class="toc-text">Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock与synchronized的区别"><span class="toc-number">4.1.</span> <span class="toc-text">Lock与synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步器"><span class="toc-number">4.2.</span> <span class="toc-text">同步器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独占锁、共享锁"><span class="toc-number">4.3.</span> <span class="toc-text">独占锁、共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列同步器的实现分析"><span class="toc-number">4.4.</span> <span class="toc-text">队列同步器的实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步队列"><span class="toc-number">4.4.1.</span> <span class="toc-text">同步队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重入锁"><span class="toc-number">4.5.</span> <span class="toc-text">重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的公平性"><span class="toc-number">4.6.</span> <span class="toc-text">锁的公平性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写锁"><span class="toc-number">4.7.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁的实现分析"><span class="toc-number">4.7.1.</span> <span class="toc-text">读写锁的实现分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁降级"><span class="toc-number">4.7.2.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport"><span class="toc-number">4.8.</span> <span class="toc-text">LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition接口"><span class="toc-number">4.9.</span> <span class="toc-text">Condition接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition的实现分析"><span class="toc-number">4.9.1.</span> <span class="toc-text">Condition的实现分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java并发容器和框架"><span class="toc-number">5.</span> <span class="toc-text">java并发容器和框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">5.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">5.2.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-Join框架"><span class="toc-number">5.3.</span> <span class="toc-text">Fork/Join框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原子类"><span class="toc-number">6.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发工具类"><span class="toc-number">7.</span> <span class="toc-text">并发工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池的实现原理"><span class="toc-number">8.1.</span> <span class="toc-text">线程池的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合理的配置线程池"><span class="toc-number">8.2.</span> <span class="toc-text">合理的配置线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Executor"><span class="toc-number">9.</span> <span class="toc-text">Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FixedThreadExecutor"><span class="toc-number">9.1.</span> <span class="toc-text">FixedThreadExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingleThreadExecutor"><span class="toc-number">9.2.</span> <span class="toc-text">SingleThreadExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CachedThreadExecutor"><span class="toc-number">9.3.</span> <span class="toc-text">CachedThreadExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FutureTask"><span class="toc-number">9.4.</span> <span class="toc-text">FutureTask</span></a></li></ol></li></ol>
		</div>
		
		<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>你知不知道一个最简单的java对象中你能获取什么内容？你可能不知道，我也不晓得，所以我再这里总结下我平时遇到能从一个基本的java对象获取的信息。</p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象都中存放了一些对象本身的基本信息，这些基本信息是为整个java语言体系能正常高效运转经过精心的设计的。它们保证了java面向对象，支持并发等特性。</p>
<p>在32位虚拟机中（不做特殊说明，本文都是指的32位的虚拟机系统），一个java对象头通常有8个字节（如果对象是数组，则有12个字节，多出来的一个字节用于保存数组的长度）。对象头的组成信息：</p>
<ol>
<li>32位的Mark Word</li>
<li>32位的对象类型数据的存储地址</li>
<li>32的数组长度（只有数组对象的对象头中才会多出这32位）</li>
</ol>
<h3 id="Mark-Word结构"><a href="#Mark-Word结构" class="headerlink" title="Mark Word结构"></a>Mark Word结构</h3><p>默认的存储结构：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B41.png" alt></p>
<p>运行期间，Mark Word的存储结构会根据锁标志位变化，可能会存在如下四种存储结构：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B42.png" alt></p>
<p>在64位虚拟机下，Mark Word的结构：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%A4%B43.png" alt></p>
<blockquote>
<p>参考《java并发编程的艺术》</p>
</blockquote>
<h1 id="多线程工作的基础"><a href="#多线程工作的基础" class="headerlink" title="多线程工作的基础"></a>多线程工作的基础</h1><p>如果在多线程环境下，每个线程各干各的，那使用多线程的意义会比较有限，如果能让线程之间协同工作，可以提升开发人员对复杂业务的设计能力，降低业务的设计复杂度。要能使线程协同工作，就需要保证线程之间有一种通信的机制，使用该机制，线程间就可以交换信息，就可以协同工作了。那么线程之间要怎么通信，就成为了并发编程必须要面对的问题。在命令式编程中，通信机制有两种：</p>
<ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
<p>使用共享内存的方式来实现线程之间的通信，就需要在内存中维护线程之间的一个公共状态，通过读写内存中的公共状态实现<strong>隐式的通信</strong>。这也正是java采用的方式。这对开发者是好事，不需要过分的关系线程之间的通信。</p>
<p>使用消息传递的方式来实现线程之间的通信，线程之间就需要通过显示的发送消息来<strong>显示进行通信</strong>。</p>
<p>什么是同步？同步是指控制不同线程间操作发生的相对顺序的机制。共享内存实现同步的模型中，同步是显示进行的，开发者必须要指定某个方法或某段代码需要在线程之间互斥执行。而在以消息传递实现的同步模型中，消息的发送总是发生在消息的接收之前，因此不需要开发者指定需要互斥的代码。</p>
<p>java线程之间的通信机制的基础是JMM，由JMM控制，它决定了一个线程对共享变量的写入何时对另一个线程可见。线程之间的共享变量（共享状态）存储在主内存，JMM通过控制主内存与每一个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<p>多线程编程跳不过去的一道坎是指令重排序。指令重排序是指编译器，处理器为了提高程序的执行性能，对程序想当然的执行顺序进行了重新排序，但即便它重排序了程序员想当然的顺序，却得出与程序员预料的结果一致的答案。存在三种指令重排序：</p>
<ul>
<li>编译器级的重排序，基于不改变单线程语义的前提下，重新安排语句的执行顺序。</li>
<li>指令级并行的重排序，如果不存在数据依赖关系，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序，由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能存在乱序执行。</li>
</ul>
<p>重排序可能会导致多线程程序出现内存可见性问题，为规避这个问题，JMM编译器重排序规则会禁止特定类型的编译器重排序；JMM的处理器重排序规则则会要求java编译器在生成指令序列的时候，插入特定类型的内存屏障，通过内存屏障指令来禁止特定类型的处理器重排序。由此可见，最终为程序员提供一致的内存可见性保证的是java编译器。</p>
<p>什么是内存可见性？程序的执行顺序在单线程下是按程序员的设计顺序来的。</p>
<h2 id="happen-before规则"><a href="#happen-before规则" class="headerlink" title="happen-before规则"></a>happen-before规则</h2><p>我们可以用happen-before规则来描述内存的可见性，JMM中，如果一个操作的结果对另一个操作可见，那么两个操作之间必须要存在happen-before关系，这里的两个操作可以在一个线程内，可以在线程间。我们需要了解的happen-before规则：</p>
<ul>
<li>程序顺序规则</li>
<li>监视器锁规则：对一个锁的解锁，happen-before于对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile变量的写，happen-before于任意后续对这个volatile变量的读。</li>
<li>传递性： A happen-before B，B happen-before C，那么 A happen-before C。</li>
<li>start（）规则：如果线程A执行操作ThreadB.start(),那么A线程的ThreadB.start()操作happens-before与线程B中的任意操作。</li>
<li>join()规则：如果线程A执行操作Thread.join()并成功返回，那么线程B中的任意操作happens-before于线程A从Thread.join()操作的成功返回。</li>
</ul>
<p>happen-before规则并不是要求两个操作要有顺序，而是要求前一个操作的结果后一个操作可见。</p>
<p>JMM的设计思想：对于程序员，易于理解，易于编程，程序员希望基于一个强内存模型来编写代码；然而编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以尽可能的做优化来提高性能，它们希望实现一个弱内存模型。</p>
<p>happen-before要求禁止的重排序有：</p>
<ol>
<li>会改变程序执行结果的重排序</li>
<li>不会改变程序执行结果的重排序</li>
</ol>
<p>对两种不同的重排序，JMM要求编译器和处理必须禁止会改变程序执行结果的重排序，对不会改变程序执行结果的，JMM对编译器和处理器没有要求。JMM的happen-before规则为程序员提供了足够强的内存可见性保证（即便有些内存可见性保证并不一定存在）。</p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>数据依赖性：编译器和处理器重排序时，遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作。</p>
<p>as-if-serial:不管怎么重排序，单线程的执行结果都不会改变。</p>
<p>控制依赖：在单线程中，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<p>as-if-serial和happen-before的关系：<br><strong>as-if-serial保证单线程内程序的执行结果不变，happen-before关系保证正确同步的多线程的执行结果不被改变。as-if-serial给编写单线程的程序员构造了一个幻境：单线程是按程序员的料想顺序执行的；happen-before该编写正确同步的多线程程序的程序员创造了另一个幻境：正确同步的多线程程序是按happen-before指定的顺序执行的。</strong></p>
<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性模型是一个理论参考模型，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。它为程序员提供了极强的内存可见性保证。顺序一致性模型的特性：</p>
<ul>
<li>一个线程的所有操作必须按照程序的顺序来执行。</li>
<li>所有线程都只能看到一个单一的操作顺序（不管是否同步），每个操作都必须原子执行且立刻对所有线程可见。顺序一致性模型依赖于一个单一的全局内存，通过该共享的全局内存模型，多个线程对内存的操作就可以串行执行，保证了顺序一致性模型中的所有操作顺序唯一。</li>
</ul>
<p>但在JMM模型中，所有线程看到的操作执行顺序可能不一致，因为每个当前线程都有一个私有的缓存，有些操作在独占的私有缓存中就完成了，没有通过全局内存暴露给其他线程。</p>
<p>未同步程序在两个模型中执行的差异：</p>
<ul>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行；而JMM不保证单线程内的操作会按程序的顺序执行。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作顺序。</li>
<li>JMM不保证对64位的long/double型变量的写操作具有原子性；而顺序一致性模型保证对所有的内存读写操作都具有原子性。</li>
</ul>
<p>不管是什么内存可见性模型，执行结果都必须与内存一致性的预测结果一致。</p>
<p><strong>happen-before规则约束重排序规则，重排序规则还必须得遵守顺序一致性规则。</strong></p>
<p>内存屏障保证了某个线程的屏障内的数据不被其他线程所见。·<br>由于常见的处理器内存模型比JMM要弱，java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器的内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为java程序员呈现一个一致的内存模型。</p>
<p>内存屏障指令是为了处理器的内存模型和JMM的一致，进一步的使JMM符合内存一致性模型。</p>
<h2 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h2><p>volatile的内存语义：volatile的读-写与锁的释放-获取具有相同的内存效果。volatile的写或锁的释放有相同的内存语义；volatile的读与锁的获取具有相同的内存语义。为了实现volatile的内存语义，JMM会限制编译器和处理器这两种类型的重排序。限制volatile内存语义的重排序的规则：</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。</li>
<li>当第一个操作是volatile读是，不管第二个操作是什么，都不能重排序。</li>
<li>第一个操作是volatile写，第二个是volatile读时，两个操作不能重排序。</li>
</ul>
<p>为实现上面的规则，编译器在生成字节码的时候，会在指令序列中加入内存屏障来禁止某些指令的重排序。加入内存屏障的策略是保守的，而不是最优的，这也是为了编译器的简单。</p>
<p>锁的内存语义：锁除了让临界区互斥执行以外，还可以让释放锁的线程向获取同一个锁的线程发送消息。锁的happen-before规则，锁的释放一定在锁的获取之前。当锁释放时，JMM会把线程对应的本地内存中的共享变量刷新到主内存中；当线程获取锁时，JMM会把该线程对应的本地内存设置为无效，从而强制线程重新从共享内存获取共享变量。</p>
<p>CAS内存语义：具有volatile读和写的内存语义，所以编译器不会对CAS与CAS前面和后面的任意内存操作重排序。CSA有对应的处理器指令，该指令利用lock指令进行了内存屏蔽。</p>
<p>锁释放-获取的内存语义的实现至少有两种：</p>
<ol>
<li>利用volatile变量的写-读锁具有的内存语义。</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ol>
<p>final域的内存语义：对于final域，编译器和处理器需要遵守的重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<p>如果final域是一个引用类型，写final域的重排序规则对编译器和处理器增加了约束：在构造函数内对一个final引用的对象域的写入，与随后在<strong>构造函数外</strong>把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<h1 id="并发的基础"><a href="#并发的基础" class="headerlink" title="并发的基础"></a>并发的基础</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>实现两个线程的安全，要么需要禁止线程内的操作的重排序，要么使线程内的重排序不被另一个线程可见。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程的优先级决定了线程需要多或者少分配一些处理器资源。因此，为了确保CPU不会被某些线程独占，那么要遵守优先级的设置原则：</p>
<ol>
<li>对于频繁阻塞的线程需要设置较高的优先级</li>
<li>对于偏重计算的线程设置较低的优先级，不然CPU就有可能被其独占。</li>
</ol>
<h2 id="线程的状态变化"><a href="#线程的状态变化" class="headerlink" title="线程的状态变化"></a>线程的状态变化</h2><p><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt></p>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><p>Daemon线程：是一种支持线程，主要用于程序中后台调度以及支持性工作，意味着一个java虚拟机中不存在非daemon的线程的时候，java虚拟机将退出。设置线程为daemon线程必须要在启动该线程之前。</p>
<p>线程启动：线程对象初始化完成后，调用start()方法就可以启动这个线程，start()方法的作用：当前线程同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()的线程。</p>
<p>中断：线程的一个标识位属性，标识一个运行中线程是否被其他线程进行中断操作，中断好比其他线程向该线程打了一个招呼，其他线程通过调用该线程的interrupt()修改该标识位的值，当前线程同检查自身的中断标识来进行响应。如果线程已经处于终结状态，那么气中断标识会被复位。</p>
<p>安全的终止线程的方式：使用一个标识来标记是否需要中断线程了。</p>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><ul>
<li>volatile和synchronized:使用的是volatile的内存语义，synchronized使用的是对象的锁。</li>
<li>等待通知机制，等待通知的经典范式：</li>
</ul>
<p>等待方：</p>
<ol>
<li><p>获取对象锁</p>
</li>
<li><p>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件</p>
</li>
<li><p>条件满足则执行对应的逻辑</p>
<pre><code>synchronized(对象){
    while(条件不满足){
        对象.wait();
    }
    处理逻辑；
}</code></pre></li>
</ol>
<p>通知方：</p>
<ol>
<li><p>获得对象锁</p>
</li>
<li><p>改变条件</p>
</li>
<li><p>通知所有等待在对象上的线程</p>
<pre><code>synchronized(对象){
    改变条件；
    对象.notify()/对象.notifyAll();
}</code></pre></li>
</ol>
<ul>
<li>管道输入/输出流，用于线程之间的信息传输，传输的媒介是内存。</li>
</ul>
<h2 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h2><p>是一个以ThreadLocal对象为键，任意对象为值的存储结构，这个存储结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定到这个线程上的一个值。</p>
<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><p>锁用于控制多个线程访问共享资源的方式，一般来说，一个锁能防止多个线程同时访问共享资源。Lock的实现基本都是通过聚合一个同步器的子类爱完成线程的<strong>访问控制</strong>。</p>
<h2 id="Lock与synchronized的区别"><a href="#Lock与synchronized的区别" class="headerlink" title="Lock与synchronized的区别"></a>Lock与synchronized的区别</h2><ol>
<li>Lock是显示的获取和释放锁，synchronized是隐式的获取和释放锁</li>
<li>Lock放弃了获取释放锁的便捷性，但是拥有了锁获取和释放的可操作性。可中断获取锁，可超时获取锁。扩展性强于synchronized</li>
<li>Lock可以尝试非阻塞的获取锁；可中断的获取锁；可以设置超时获取锁。</li>
</ol>
<h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><p>AbstractQueuedSynchronizer是用于构建锁或者其他同步器组件的基础框架，使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，管理同步状态的方法有getState(),setState(int newState),compareAndSetState(int expect,int update)。同步组件的实现者，可以通过这三个方法来安全的改变状态。</p>
<p>同步器自身没有实现任何同步接口，它仅仅是定义了若干同步同步状态的获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式的获取同步状态，也可以支持共享式地获取同步状态。</p>
<p>锁就是通过同步器实现的同步组件。</p>
<p><strong>怎么设计一个自己的同步组件？</strong></p>
<p>同步器的使用需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件中，并调用同步器提供的<strong>模板方法</strong>，而这些模板方法将会调用使用者重写的方法。重写同步器指定的方法时，需要使用同步器提供的如下方法：</p>
<ul>
<li>getState()</li>
<li>setState(int newState)</li>
<li>comapareAndSetState(int except,int update)</li>
</ul>
<p>同步器可重写的方法：</p>
<ul>
<li>boolean tryAcquire(int arg)</li>
<li>boolean tryRelease(int arg)</li>
<li>int tryAcquireShared(int arg)</li>
<li>boolean tryReleaseShared(int arg)</li>
<li>boolean isHeldExclusively()</li>
</ul>
<p>同步器提供的模板方法主要有三类：</p>
<ol>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中的线程等待情况</li>
</ol>
<h2 id="独占锁、共享锁"><a href="#独占锁、共享锁" class="headerlink" title="独占锁、共享锁"></a>独占锁、共享锁</h2><ul>
<li>独占锁：同一时刻只有一个线程获取到锁，其他需要获取锁的线程只能在同步队列中等待。</li>
<li>共享锁：同一时刻可以有多个线程获取到锁。</li>
</ul>
<h2 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖于内部的同步队列来完成同步状态的管理，当线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造为一个节点，将其加入同步队列，同时会阻塞当前线程，当同步状态释放后，会把首节点中的线程唤醒。</p>
<p>同步队列中的节点保存的信息：</p>
<ol>
<li>waitStatus 等待状态，包括CANCELLED、SIGNAL、CONDITION、PROPAGATE和INITIAL</li>
<li>Node prev 前驱节点</li>
<li>Node next 后驱节点</li>
<li>Node nextWaiter 等待队列中的后续节点</li>
</ol>
<p>同步队列的结构：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/synchronizerQueue.png" alt></p>
<p>如图，同步器包含两个节点类型的引用，一个指向头结点，一个指向尾节点。当一个线程试图获取锁而没有获取到，就需要加入同步队列中，加入同步队列需要保证线程安全。首节点是获取同步状态成功的节点，设置首节点是通过获取同步状态成功的线程来完成的，由于<strong>只有一个线程</strong>能成功获取同步状态，因此设置头节点的方法不需要CAS保证线程安全。获取同步状态的节点的前驱节点必须是head节点，只有head节点才有资格获取同步状态。</p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>表示一个线程能够支持一个线程对资源重复加锁，该锁还支持获取锁时的公平和非公平性选择。synchronized隐式的支持锁的重入，实现Lock接口的ReentrantLock的锁也是支持重入的。</p>
<p>实现锁的重进入需要解决：</p>
<ol>
<li>线程再次获取锁，锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次获取锁成功。</li>
<li>锁的最终释放，重复n次获取锁，那么就需要释放n次其他的线程才能获取锁，所以锁需要记录一个线程获取锁的次数，通过该次数来释放锁。</li>
</ol>
<h2 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h2><p>公平锁保证了等待时间最长的线程获取到锁，而非公平锁，不保证最长等待的线程获取到锁，可能造成线程“饥饿”的情况；公平锁的效率比非公平锁低很多，关键是公平锁线程切换更比非公平性锁多。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>特点：</p>
<ol>
<li>写操作对读操作可见</li>
<li>在读多于写的场景下，性能较排它锁高。</li>
<li>读锁时共享的，写锁时排他的。如果一个线程获取了写锁，那么其他线程就需要在读锁或者写锁上等待；如果一个线程获取了读锁，那么其他的读线程可以获取读锁，而写线程需要在读锁上等待。</li>
</ol>
<h3 id="读写锁的实现分析"><a href="#读写锁的实现分析" class="headerlink" title="读写锁的实现分析"></a>读写锁的实现分析</h3><p>读写锁时依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态，只是读写锁的自定义同步器需要在同步状态上维护多个读线程和一个写线程的状态。如果需要在一个整形变量上维护多种状态，就一定要切割变量，高16位表示读，低16位表示写。读写状态的确定：假设当前同步状态的值为S，那么些状态等于S&amp;0x0000FFFF,读状态等于S&gt;&gt;&gt;16(无符号补0右移16位)。写状态加1，使用S+1，读状态加1，使用S+(1&lt;&lt;16)。</p>
<p>写锁的获取需要增加对是否拥有写锁的判断，还有就是是否有非当前线程已经获取写锁。读锁的获取可能会被阻塞在别写线程上，读状态是所有线程获取读锁次数的总和。而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护。</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>指的把持住写锁，再获取读锁，随后释放写锁的过程。ReentrantReadWriteLock不支持锁的升级。</p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport定义了一组公共的静态方法，这些方法提供了最基本的线程阻塞和幻想功能，也成为构建同步组件的基础攻击，其定义了一株以park开头的方法用来阻塞当前线程，以及unpark（Thread thread）方法来唤醒一个被阻塞的线程。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition接口提供了类似Object监视器的方法，与Lock配合可以实现等待/通知机制。但是Condition比Object监视器有更加强大的功能，可以定义超时等待等，还可以支持多个等待队列。</p>
<p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联锁，Condition对象是由Lock对象创建出来的，也就是说condition是依赖lock对象的。</p>
<h3 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h3><p>每个Condition对象都包含着一个队列，该队列是Condition对象实现等待/通知功能的关键。Condition的实现主要包括：等待队列、等待和通知。</p>
<p>其中的等待队列是一个FIFO队列，队列中的每个节点都包含一个线程的引用，该线程就是在Condition对象上等待的线程。队列中的节点复用了同步队列中的节点的定义，都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>一个Condition包含一个等待队列，一个同步器有多个Condition。</p>
<p>如图，等待队列的基本结构：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/ConditionWaitQueue.png" alt></p>
<p>一个Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并非包中的Lock拥有一个同步队列和多个等待队列。如图</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/waitAndSynchQueue.png" alt></p>
<p>Condition的等待：调用Condition的await()方法，会使当前线程进入等待队列，并释放锁，当从await返回时，当前线程一定获取了Condition相关联的锁。如果从队列的角度看await方法，当调用await方法时，相当于同步队列的首节点移动到Condition的等待队列中。await()的实现:</p>
<pre><code>  public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}</code></pre><p>调用该方法的线程成功获取了锁的线程，也就是同步队列的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后续节点，然后当前线程会进入等待状态。同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p>
<p>Condition的通知：调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点，在唤醒节点前，会将该节点移到同步队列中。signal方法：</p>
<pre><code> public final void signal() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

//
 public final void signalAll() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignalAll(first);
}</code></pre><h1 id="java并发容器和框架"><a href="#java并发容器和框架" class="headerlink" title="java并发容器和框架"></a>java并发容器和框架</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>使用分段锁技术，提升了并发能力，不同段使用不同的锁，不同段可以完全实现真正的并发。</p>
<p>ConcurrentHashMap的初始化：ConcurrentHashMap的初始化时通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用费阻塞算法。使用阻塞算法的队列可以用一个锁（入队出队用同一把锁）或两个锁（入队和出队用不同的锁）来实现。非阻塞的实现则可以使用循环CAS的方式来实现。</p>
<p>ConcurrentLinkedQueue由head和tail节点组成，每个节点由节点元素和指向下一个节点的引用组成。默认情况下head节点存储的元素为null，tail节点等于head节点。</p>
<p>ConcurrentLinkedQueue的入队过程：首先定位出尾节点，接着使用CAS算法将入队节点设置成尾节点的next节点。</p>
<p>ConcurrentLinkedQueue的出队过程：首先获取头节点元素，判断头节点元素是否为null，如果为null，表示另一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接放回头结点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<p>阻塞队列的实现原理：使用通知模式，ArrayBlockingQueue使用的就是锁的Condition对象的等待/通知机制实现的。</p>
<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>是一个把大任务分割成若干小任务，最终汇总每个小任务结果后得到大任务结果的框架。工作窃取算法指的是某个线程从其他队列里窃取任务来执行。工作窃取算法的有点事充分利用线程进行并行计算，减少了线程间的竞争，缺点是会存在竞争。</p>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>atomic包里一共提供了13个类，有四种类型的原子类：</p>
<ol>
<li>基本类型的原子更新</li>
<li>数组的原子更新</li>
<li>引用的原子更新</li>
<li>属性的原子更新</li>
</ol>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><p>常用的并发工具类：</p>
<ol>
<li>CountDownLatch，允许一个或多个线程等待其他线程完成操作，CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。</li>
<li>CyclicBarrier，让一个线程到达一个屏障时阻塞，知道最后一个线程到达屏障时，屏障才会“开门”，所有被屏障拦截的线程才会继续执行。每个线程调用await方法告诉CyclicBarrier我已经到达屏障。</li>
<li>Semaphore，用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。</li>
<li>Exchanger，提供一个同步点，在这个同步点，两个线程可以交换彼此的数据，两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程产生的数据传输给对方。</li>
</ol>
<p>1、2和3提供了一种并发流程的控制手段，4提供了在线程间交换数据的一种手段。</p>
<p>CountDownLatch和CyclicBarrier区别：CountDownLatch中的计数器只能使用一次，而CyclicBarrier中的计数器可以使用reset()方法重置。</p>
<p>几个常用的操作：</p>
<ol>
<li><p>join，用于让当前执行的线程等待join线程结束，原理是不停的检查join线程是否存活，</p>
<pre><code>while(isAlive()){
    wait(0);//永远等下去
}</code></pre></li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>使用线程池的有点：</p>
<ol>
<li>降低资源消耗，降低线程创建和销毁的次数</li>
<li>提高响应速度，任务不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。</li>
</ol>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>线程池对任务的处理流程：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/threadpool.png" alt></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务，这一步需要获取全局锁</li>
<li>如果运行的线程等于或多余orePoolSize,则将任务添加到BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue，则创建新的线程来处理任务，这一步也需要获取全局锁。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectExecutionHandler.rejectedException()方法。</li>
</ol>
<p>线程池在创建线程时，会将线程封装为工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。在worker类的run方法里可以看到循环。</p>
<p>可以通过ThreadPoolExecutor来创建线程池：</p>
<pre><code>new ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
    BlockingQueue&lt;Runnable&gt; runableTaskQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</code></pre><ul>
<li><p>corePoolSize:当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即便其他的空闲线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池的基本大小时就不再创建。</p>
</li>
<li><p>runableTaskQueue：用于保存等待执行的任务的阻塞队列，可以选择：</p>
<ol>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>SynchronousQueue</li>
<li>PriorityBlockingQueue</li>
</ol>
</li>
<li><p>maximumPoolSize:线程运行创建的最大线程数量</p>
</li>
<li><p>ThreadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的现象设置更有意义的名字。</p>
</li>
<li><p>RejectedExecutionHandler:饱和策略，队列和线程池都满了，需要一个策略来处理新提交的任务。</p>
</li>
<li><p>keepAliveTime：线程池的工作线程空闲后，保持存活的时间。</p>
</li>
<li><p>TimeUnit：keepAliveTime的时间单位</p>
</li>
</ul>
<p>向线程池提交任务：</p>
<ol>
<li>execute：提交不需要返回值的任务</li>
<li>submit：提交需要返回值的任务，线程池会返回一个future类型对象，通过这个future对象可以判断任务是否执行成功。</li>
</ol>
<p>关闭线程池：可以调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理都是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。因此无法响应中断的任务可能永远无法终止。</p>
<h2 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h2><p>根据任务特性来配置线程池，任务特性可以冲如下几个点入手：</p>
<ol>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</li>
<li>任务的优先级：高中低</li>
<li>任务的执行时间：长中短</li>
<li>任务的依赖性：是否依赖于其他资源</li>
</ol>
<p>CPU密集任务应该分配尽量小的线程，IO密集型任务应该尽量分配更多的任务。执行时间不同的任务可以交给不同规模的线程池来处理。</p>
<p>什么时候我们需要扩展线程池？</p>
<p>需要监控线程池的状态时，可以扩展线程池。</p>
<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p>java线程中的工作单元包括Runnable和Callable，而执行机制由Executor框架提供。在HotSpot VM模型中，Java线程被一对一映射本地操作系统线程。Java线程启动时会创建一个本地操作系统线程，当该java线程终止时，这个操作系统线程也会被回收。</p>
<p>java多线程程序通常把应用分解为若干个任务，然后使用Executor将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<p>工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable(Runnable task或Executors.callable(Runnable task,Object resule)）</p>
<ul>
<li>ThreadPoolExecutor</li>
</ul>
<p>ThreadPoolExecutor通常使用工厂类Executors来创建，它可以创建三类ThreadPoolExecutor：</p>
<ol>
<li>SingleThreadExecutor，适用于需要保证各个任务顺序地执行，并且在任意时间点不会有多个线程是活动的应用场景。</li>
<li>FixedThreadExecutor，适用于负载比较重的服务器</li>
<li>CachedThreadExecutor，适用于执行很多短期异步任务的小程序，或者是负载较轻的服务器</li>
</ol>
<h2 id="FixedThreadExecutor"><a href="#FixedThreadExecutor" class="headerlink" title="FixedThreadExecutor"></a>FixedThreadExecutor</h2><p>可重用固定线程数的线程池，它的corePoolSize和maximumPoolSize被设置为一样。keepAliveTime被设置为0L，意味着多余的空闲线程会立即终止。</p>
<ol>
<li>如果当前运行的线程数少于corePoolSize,则创建新线程来执行任务</li>
<li>在线程池完成预热后，将任务加入LinkedBlockingQueue</li>
<li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行。</li>
</ol>
<h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><ol>
<li>使用单个Worker线程，corePoolSize和maximumPoolSize的大小都是1</li>
<li>使用无界队列作为线程池的任务队列</li>
</ol>
<h2 id="CachedThreadExecutor"><a href="#CachedThreadExecutor" class="headerlink" title="CachedThreadExecutor"></a>CachedThreadExecutor</h2><ol>
<li>会根据需要创建新线程的线程池，corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE</li>
<li>使用没有容量的SynchronousQueue作为线程池的工作队列。</li>
<li>有新任务，线程池中又没有有空闲线程，就创建新的线程。</li>
</ol>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>实现了Future接口，还实现了Runnable接口，因此FutureTask可以提交给Executor执行，也可以通过调用线程直接执行（FutureTask.run()）。</p>
<p>FutureTask是基于AQS实现的。AQS提供通用机制来原子性管理同步状态，阻塞和唤醒线程，以及维护被阻塞的线程队列</p>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="https://github.com/danielfengyu/danielfengyu.github.io/2018/06/13/一些你必须晓得的java知识/" data-title="一些你必须晓得的java知识 | 山间听雨者主页" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/01/01/我的2018/" title="我的2018">
  <strong>新一篇:</strong><br/>
  <span>
  我的2018</span>
</a>
</div>


<div class="next">
<a href="/2018/05/19/Tomcat工作原理/"  title="Tomcat工作原理">
 <strong>旧一篇:</strong><br/> 
 <span>Tomcat工作原理
</span>
</a>
</div>

</nav>

	
<section class="comment">
	
	<div class="ds-thread" data-title="一些你必须晓得的java知识" data-thread-key="一些你必须晓得的java知识" data-author-key="Daniel" data-url="https://github.com/danielfengyu/danielfengyu.github.io/post/一些你必须晓得的java知识"></div>
	
</section>


</div>  
    </div>
    <footer><div id="footer" >
	<div class="copyright">
		<span>Powered by <a href="https://github.com/hexojs/hexo">Hexo</a> and theme by 
		<a href="https://github.com/levonlin/Tinnypp">Tinnypp</a>.</span>
		
			<span>© Daniel/山间听雨者</span>
		
	<div>
</div></footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  //back to top
  function backToTop(){
    var buttonHTML = $("<a href=\"#top\" id=\"back-top\">" + "<span>Back to Top</span></a>");
    buttonHTML.appendTo($("body"));
    var buttonToTop = $("#back-top");
    // hide #back-top first
    buttonToTop.hide();

    // fade in #back-top
    $(function() {
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                buttonToTop.fadeIn();
            } else {
                buttonToTop.fadeOut();
            }
        });
        // scroll body to 0px on click
        buttonToTop.click(function() {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
  }
  backToTop();

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      ta = $('#toc.toc-aside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
        
    }
  });

  var show = true;
  c.click(function(){
    if(show == true){
        a.addClass('fadeOut').css('display', 'none');
        ta.css('display', 'block').addClass('fadeIn');
        m.addClass('moveMain');  
    }else{
        a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');     
        ta.css('display', 'none'); 
        m.removeClass('moveMain');
        $('#toc.toc-aside').css('display', 'none');
    }
    show = !show;
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{

    $(window).scroll(function(){
      ta.css("top",Math.max(140,240-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"tinnypp"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';    //change to ds.src = '/js/embed.js'; to add useragent for duoshuo
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>

<script type="text/javascript">
  function footerPosition() {
    var contentHeight = document.documentElement.scrollHeight,
        winHeight = window.innerHeight;
    if(contentHeight <= winHeight) {
      $('footer').addClass('fixed-bottom');
    } else {
      $('footer').removeClass('fixed-bottom');
    }
  }
  footerPosition();
  $(window).resize(footerPosition);
</script>


  </body>
</html>
