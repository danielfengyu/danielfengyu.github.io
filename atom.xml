<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山间听雨者主页</title>
  <subtitle>个人学习总结</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-02T02:55:04.457Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Daniel</name>
    <email>fengyu153610@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat工作原理</title>
    <link href="http://yoursite.com/2018/05/19/Tomcat%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/19/Tomcat工作原理/</id>
    <published>2018-05-19T13:12:59.000Z</published>
    <updated>2018-06-02T02:55:04.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着互联网的发展，java也在不断的改善进步。B/S架构的发展也是进展迅速，java为了支持B/S架构，出现了Servlet和jsp等服务端小程序，客户端小程序applet等。在servlet规范或是标准出现前，编写服务端程序需要在服务器集成通过其他语言实现的CGI程序，这个方式对java的平台无关性的影响很大，为此javaee中推出了servlet来替代CGI，servlet是用java实现的，属于javaee标准，且性能较高。为了能运行java编写的servlet程序，需要一个能支持servlet的web服务器，就这样Tomcat诞生了，Tomcat提供了对Servlet标准的支持，运行于服务端的servlet程序可以长期驻留在服务器上，即保留在web容器的servlet容器中。使用servlet写web的都知道比较费劲，为此根据.NET 中的ASP技术衍生出了JSP（Java Server Page）。其实JSP只是Servlet的一种表现形式，JSP最终都会被web服务器（如Tomcat）编译为Servlet，要编译jsp为servlet，需要web服务器中提供jsper解析器，jsper的功能就是把jsp解析为servlet。</p>
<p>Servlet和CGI一样，都可以提供动态服务。但有时候客户端的动态变化，是不需要与服务器交互的，为此，javaee体系提供了applet网络小程序，该程序可以在客户端运行，需要客户端能特殊支持，由于该技术的复杂特性，导致被JavaScript技术取代。</p>
<h1 id="JavaEE-J2EE"><a href="#JavaEE-J2EE" class="headerlink" title="JavaEE/J2EE"></a>JavaEE/J2EE</h1><p>JavaEE是J2EE的新叫法。JavaEE是一套使用Java进行企业级Web应用开发的大家一致遵循的工业标准，提供了一个机遇组件开发的方法来加快设计，开发，部署等。满足开放性，分布性和平台无关性。</p>
<p>JavaEE是对JavaSE的扩展。</p>
<p>JavaEE核心标准（规范）：</p>
<ul>
<li>jdbc</li>
<li>jndi(Java Naming and Directory Interfaces)Java 的命名和目录接口</li>
<li>EJB（Enterprise JavaBean）</li>
<li>RMI（Remote Method Invoke）远程方法调用</li>
<li>Java IDL（Interface Description Language）/CORBA（Common Object Broker Architecture）Java 接口定义语言/公用对象请求代理程序体系结构.</li>
<li>JSP（Java Server Pages）</li>
<li>Servlet</li>
<li>XML</li>
<li>JMS（Java Message Service）Java 消息服务</li>
<li>JTA（Java Transaction API）Java 事务 API</li>
<li>JTS（Java Transaction Service）Java 事务服务</li>
<li>JavaMail</li>
<li>JAF（JavaBean Activation Framework）</li>
</ul>
<p>JavaEE抽象了java应用的开发模式，提升了设计，开发，部署等效率。现在有许多框架都是在已有的JavaEE上再次抽象得到的，目的也是为了提升设计，开发和部署的效率，同时兼顾考虑了性能等大规模部署的问题。</p>
<p>我们常说的MVC模式在JavaEE就体现得很充分：EJB（M）+JSP(V)+Servlet（C）。我们通常说的SpringMVC和Struts都是对Servlet的抽象。</p>
<h1 id="Servlet与CGI"><a href="#Servlet与CGI" class="headerlink" title="Servlet与CGI"></a>Servlet与CGI</h1><p>Servlet是JavaEE的标准规范之一，运行在Web服务器或者应用服务器上，作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层，由服务器启动并初始化，初始化后能保存在服务器上的servlet容器中，客户的请求都会被服务器分发到特定的servlet处理。servlet是以多线程的方式运行的，对于每个请求都会启动一个单独的线程与之对接。servlet所需的数据老子HTTPServletRequest和web.xml。</p>
<p>CGI（Common Gateway Interface），CGI 是Web 服务器运行时外部程序的规范(编程模型)，按CGI 编写的程序可以扩展服务器功能。几乎所有服务器都支持CGI,可用任何语言编写CGI,标准CGI 使用<strong>命令行参数或环境变量</strong>表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI 又称缓冲CGI,在CGI 程序和CGI 接口之间插入一个缓冲程序，缓冲程序与CGI 接口间用标准输入输出进行通信。<br>对于每次请求，CGI方式都是启动一个新的进程，处理完请求后销毁该进程，这种工作模式限制了CGI服务器的并发量。CGI的另一个缺点是与平台强相关。Java Servlet是运行JVM上的与平台无关。</p>
<h1 id="Jsp"><a href="#Jsp" class="headerlink" title="Jsp"></a>Jsp</h1><p>Jsp是一种特殊的servlet，经过jsper处理后成为Servlet。Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</p>
<h2 id="Jsp的内置对象"><a href="#Jsp的内置对象" class="headerlink" title="Jsp的内置对象"></a>Jsp的内置对象</h2><p>Jsp共有九个内置对象：</p>
<ul>
<li>request</li>
<li>response</li>
<li>session，作用域是同一个用户的不同请求</li>
<li>application，可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。</li>
<li>out </li>
<li>pageContext 取得任何范围的参数</li>
<li>config 取得服务器的配置信息，通过web.xml可以一个servlet的初始化信息存入config中。</li>
<li>page Jsp本身,类似java对象的this。page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。</li>
<li>exception 作用是显示异常，只有在包含 isErrorPage=”true” 的页面中才可以被使用。</li>
</ul>
<p>这些内置对象之间的关系是有一定的规律可寻的，Servlet容器根据HTTP的请求生成request，并根据响应生成response。web容器通过request和response可以得到pageContex，session通过服务器自动创建，但可以通过pageContext获取，还可以通过pageContext获取application、out、config等。page只和jsp本身相关。</p>
<h2 id="内置指令："><a href="#内置指令：" class="headerlink" title="内置指令："></a>内置指令：</h2><ul>
<li>编译指令：page、include、taglib 。使用&lt;%@ 指令 属性%&gt;</li>
<li>动作指令：forward、include、useBean、setProperty、getProperty、plugin、param。使用<jsp:指令 属性=""></jsp:指令></li>
</ul>
<h1 id="aaplet"><a href="#aaplet" class="headerlink" title="aaplet"></a>aaplet</h1><p>applet是浏览器客户端运行的java小程序，是为了在客户端HTML实现动态的技术，类似于JavaScript，但是目前已经很少使用这门技术了。目前的主流就是JavaScript。</p>
<h1 id="Tomcat的源码调试步骤"><a href="#Tomcat的源码调试步骤" class="headerlink" title="Tomcat的源码调试步骤"></a>Tomcat的源码调试步骤</h1><ol>
<li><p>从GitHub上clone源码： </p>
<pre><code>&gt; git clone https://github.com/apache/tomcat.git
</code></pre></li>
<li>在源码目录下复制一份build.properties.default，并命名为build.properties，把该文件放到与build.properties.default同一个目录</li>
<li>修改build.properties其中的配置，把base.path的值设置为你指定的目录，该目录的作用是用来存放在编译Tomcat时所需要的依赖包的，在编译时会从网上把这些包下载到该目录。</li>
<li><p>开始编译，运行命令：</p>
<pre><code>&gt; ant
</code></pre></li>
<li>编译成功后在源码根目录下会输出一个output目录，该目录是存放编译好的Tomcat，可以直接运行的</li>
<li><p>为了能把源码导入eclipse，需要生成一些和eclipse相关的配置文件，如classpath。运行如下命令：</p>
<pre><code>&gt; ant ide-eclipse
</code></pre></li>
<li>如果6执行成功，则在源码跟目录下我们会看见 .classpath、.project和.settings等文件或文件夹。</li>
<li>这个就可以把该工程导入eclipse了。</li>
<li><p>导入的工程会报classpath变量的绑定出错，应该是找不到相应的环境变量，需要修改eclipse的环境变量配置。</p>
<p> <img src="http://ocytp9y7u.bkt.clouddn.com/2018-05-27_143600.png" alt=""></p>
</li>
<li><p>打开6生成的.classpath文件，我们会看到相应的配置：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;classpath&gt;
    &lt;classpathentry kind=&quot;src&quot; path=&quot;java&quot;/&gt;
    &lt;classpathentry excluding=&quot;deployment/|tld/|webapp*/|webresources/&quot; kind=&quot;src&quot; path=&quot;test&quot;/&gt;
    &lt;classpathentry kind=&quot;src&quot; path=&quot;webapps/examples/WEB-INF/classes&quot;/&gt;
    &lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8&quot;/&gt;
    &lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.junit.JUNIT_CONTAINER/4&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;ANT_HOME/lib/ant.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/jaxrpc-1.1-rc4/geronimo-spec-jaxrpc-1.1-rc4.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/wsdl4j-1.6.2/wsdl4j-1.6.2.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/ecj-4.7.3a/ecj-4.7.3a.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/easymock-3.2/easymock-3.2.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/hamcrest-1.3/hamcrest-core-1.3.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/cglib-2.2.3/cglib-nodep-2.2.3.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;var&quot; path=&quot;TOMCAT_LIBS_BASE/objenesis-1.2/objenesis-1.2.jar&quot;/&gt;
    &lt;classpathentry kind=&quot;output&quot; path=&quot;.settings/output&quot;/&gt;
&lt;/classpath&gt;
</code></pre><ol>
<li>src是源文件输出目的的。</li>
<li>output是类文件输出目的地。</li>
<li>con是eclipse运行时所需的核心包。</li>
<li>var是eclipse通过环境变量的形式增加的一些JAR包。</li>
<li>lib是直接加入的JAR包</li>
</ol>
</li>
<li><p>根据9中错误提示，可以看出是在绑定环境变量指定的包的时候出错了。说明eclipse是没相应的环境变量，需要设置ANT_HOME和TOMCAT_LIBS_BASE环境变量。其中的ANT_HOME是ant安装目录，TOMCAT_LIBS_BASE是3中配置的目录。配置eclipse环境变量的步骤：Window-&gt;Preferences-&gt;Java-&gt;Build Path-&gt;Classpath Variables。然后使用New添加环境变量即可。</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/2018-05-27_145110.png" alt=""></p>
</li>
<li>两个环境变量添加完后就没有错误了，可以通过org.apache.catalina.startup.Bootstrap在eclipse中以源码的方式启动Tomcat了。</li>
<li><p>启动成功后，通过<a href="http://localhost:8080/就可以访问Tomcat的默认页面" target="_blank" rel="external">http://localhost:8080/就可以访问Tomcat的默认页面</a></p>
<h1 id="Tomcat处理用户HTTP请求的流程"><a href="#Tomcat处理用户HTTP请求的流程" class="headerlink" title="Tomcat处理用户HTTP请求的流程"></a>Tomcat处理用户HTTP请求的流程</h1></li>
<li><p>Tomcat的某个service的connector在某个指定端口上监听用户HTTP请求，封装HttpServletRequest和HttpServletResponse</p>
</li>
<li>接收到请求，connector把请求转发到其对应的service下的engine</li>
<li>engine解析request的URL得到需要转发的host</li>
<li>host解析URL得到serve它的容器Context</li>
<li>servlet容器解析URL得到对应的servlet</li>
<li>servlet处理请求，包装返回结果并返回（这里暂时不请求返回的机制是原路返回到connector，然后通过connector把结果通过socket的输出流返回给客户端；还是直接在servlet就返回给客户端了。个人觉得是后者的情况比较准确，因为在servlet我们已经能获取socket的输出流了。所以下图可能不是特别准确）。</li>
</ol>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/Tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h1 id="各种器的关系"><a href="#各种器的关系" class="headerlink" title="各种器的关系"></a>各种器的关系</h1><p>在java的开发过程中，我们会遇到很多的“器”，比如服务器，应用服务器，web应用服务器，IOC容器，web容器，servlet容器，docker容器等。所以我觉得有必要理清下这些“器”的作用，使用场景，特征，它们之间的关系等。</p>
<ul>
<li>对容器的通俗解释：容器是一个接口集合，解耦应用程序与服务器或底层软件的耦合。</li>
<li>对服务器的通俗理解：基于硬件，加上某些容器或应用，能对外提供服务的网络设备。注意其不单纯指硬件，也不单纯指软件，而是二者之间的和谐配合。</li>
</ul>
<p>下面用我自己的话来对上面的各种器进行解释：</p>
<ol>
<li>服务器：提供某种软件服务的硬件设备。</li>
<li>应用服务器：提供一个完整的应用生态的服务器，本质是服务器。如果这个服务器上安装了Tomcat等，可以提供用户进行web访问功能的应用，叫web应用服务器。</li>
<li>web服务器：只提供web资源，不提供web服务，如部署了Nginx的。</li>
<li>各种容器的功能大体一致，就是给用户提供统一的接口。IOC容器提供了访问bean等接口，web容器提供了部署web应用的接口，servlet容器提供了统一管理servlet的接口。docker容器提供了统一管理服务部署额接口。</li>
</ol>
<p>Tomcat（提供web应用服务）=Tomcat（提供应用服务）+Nginx（提供web服务）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/83385852f711" title="https://www.jianshu.com/p/83385852f711" target="_blank" rel="external">https://www.jianshu.com/p/83385852f711</a></li>
<li><a href="https://www.cnblogs.com/lm002003/archive/2012/03/08/2385006.html" title="https://www.cnblogs.com/lm002003/archive/2012/03/08/2385006.html" target="_blank" rel="external">https://www.cnblogs.com/lm002003/archive/2012/03/08/2385006.html</a></li>
<li><a href="https://blog.csdn.net/skp127/article/details/52026150" title="https://blog.csdn.net/skp127/article/details/52026150" target="_blank" rel="external">https://blog.csdn.net/skp127/article/details/52026150</a></li>
<li><a href="https://blog.csdn.net/tjiyu/article/details/53148174" title="https://blog.csdn.net/tjiyu/article/details/53148174" target="_blank" rel="external">https://blog.csdn.net/tjiyu/article/details/53148174</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;随着互联网的发展，java也在不断的改善进步。B/S架构的发展也是进展迅速，java为了支持B/S架构，出现了Servlet和jsp等服务端
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis 源码解读</title>
    <link href="http://yoursite.com/2018/04/12/Mybatis-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/04/12/Mybatis-源码解读/</id>
    <published>2018-04-12T14:31:07.000Z</published>
    <updated>2018-04-13T14:12:06.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用的方式：</p>
<ol>
<li>纯代码</li>
<li>mybatis配置文件+代码，对于要学习mybatis的源码，这种方式是一种不错的选择。</li>
<li>Spring-mybatis配置方式，开发中建议使用这种方式。</li>
</ol>
<p>下面着重介绍下第二种方式，从简单的例子入手。</p>
<p>使用mybatis的java的基本代码结构：</p>
<pre><code>String resourcePath = &quot;./mybatis-config.xml&quot;;
InputStream is = null;
try {
    is = Resources.getResourceAsStream(resourcePath);
} catch (IOException e) {
    e.printStackTrace();
}

SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, &quot;development&quot;);
SqlSession sqlSession = sessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User user = userMapper.selectUser(id);
</code></pre><p>mybatis-config.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
  &lt;properties resource=&quot;./jdbc.properties&quot;&gt;
   &lt;!--  &lt;property name=&quot;jdbc.driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;
    &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; --&gt;
    &lt;!-- 使得可以使用默认值 --&gt;
    &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt;
  &lt;/properties&gt;
  &lt;settings&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
      &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
      &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;
      &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
      &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
      &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
      &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
      &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
      &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
      &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
      &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
      &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
      &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
      &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
      &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;
      &lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; --&gt;
  &lt;/settings&gt;
  &lt;typeAliases&gt;
          &lt;typeAlias alias=&quot;User&quot; type=&quot;com.daniel.study.mybatis.entity.User&quot;/&gt;
  &lt;/typeAliases&gt;
  &lt;typeHandlers&gt;
          &lt;typeHandler handler=&quot;com.daniel.study.mybatis.type.MyTypeHandler&quot;/&gt;
          &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.daniel.study.mybatis.enums.Gender&quot;/&gt;
  &lt;/typeHandlers&gt;
  &lt;plugins&gt;
      &lt;plugin interceptor=&quot;com.daniel.study.mybatis.plugins.MyPlugin&quot;&gt;
        &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
      &lt;/plugin&gt;
  &lt;/plugins&gt;
  &lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
      &lt;transactionManager type=&quot;JDBC&quot;&gt;
          &lt;!-- &lt;property name=&quot;name&quot; value=&quot;&quot;/&gt; --&gt;
      &lt;/transactionManager&gt;
      &lt;dataSource type=&quot;POOLED&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username:fengyu}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
      &lt;/dataSource&gt;
    &lt;/environment&gt;
  &lt;/environments&gt;
  &lt;mappers&gt;
    &lt;mapper resource=&quot;com/daniel/study/mybatis/dao/impl/UserMapper.xml&quot;/&gt;
    &lt;mapper resource=&quot;com/daniel/study/mybatis/dao/impl/ConsumerMapper.xml&quot;/&gt;
  &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><p>这就是要使用配置文件+代码的方式实现mybatis数据持久层访问的方式。</p>
<h1 id="配置文件的加载"><a href="#配置文件的加载" class="headerlink" title="配置文件的加载"></a>配置文件的加载</h1><p>这一节主要介绍mybatis是怎么加载上一节中使用的配置文件的。</p>
<p>加载的过程中设计到的主要类及过程如下图：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="mybatis配置文件的加载过程"></p>
<p>加载配置文件的最终目的是得到Configuration对象，这个对象最后在DefaultSqlSessionFactory中使用，使用该Configuration对象可以得到各种类型的SqlSession。</p>
<p>加载配置文件（mybatis-config.xml）的方式有两种，一种是字符流的方式，以Reader方式加载配置，一种是以字节流的方式，以Inputstream方式加载配置。</p>
<p>字符方式加载的主要代码：</p>
<pre><code>public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        reader.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
  }

//配置创建器
public XMLConfigBuilder(Reader reader, String environment, Properties props) {
    this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props);
}
//配置创建器通过parse解析xml配置文件
public Configuration parse() {
    if (parsed) {
        throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);
    }
    parsed = true;
    // 给配置对象设置属性值
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    // 返回设置完成的配置对象，其中已经包括了xml配置中给定的信息
    return configuration;
}

// 最终解析xml为mybatis配置的建造者
private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
    // 这里创建，初始化了一个了mybatis的配置
    super(new Configuration());
    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);
    // 这里设置mybatis配置的变量
    this.configuration.setVariables(props);
    this.parsed = false;
    this.environment = environment;
    this.parser = parser;
}
</code></pre><p>字节流的方式加载配置的主要代码：</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
}

// Inputstream方式读取配置
public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {
    this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);
}

//配置创建器通过parse解析xml配置文件
public Configuration parse() {//返回Configuration
    if (parsed) {
        throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);
    }
    parsed = true;
    // 给配置对象设置属性值
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    // 返回设置完成的配置对象，其中已经包括了xml配置中给定的信息
    return configuration;
}

// 最终解析xml为mybatis配置的建造者
private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
    // 这里创建，初始化了一个了mybatis的配置
    super(new Configuration());
    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);
    // 这里设置mybatis配置的变量
    this.configuration.setVariables(props);
    this.parsed = false;
    this.environment = environment;
    this.parser = parser;
}
</code></pre><p>两者其实没有多大区别，只是读取数据源的方式不同而已，最终都是使用XPathParser来对xml进行解析。XPathParser是对jdk中XPath的封装。通过XPathParser创建了与xml配置文件对应的document对象。</p>
<pre><code>//InputStream
public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) {
    commonConstructor(validation, variables, entityResolver);
        // 创建对应的xml文档
    this.document = createDocument(new InputSource(inputStream));
}

//Reader
public XPathParser(Reader reader, boolean validation, Properties variables, EntityResolver entityResolver) {
    commonConstructor(validation, variables, entityResolver);
    this.document = createDocument(new InputSource(reader));
}
</code></pre><p>解析xml配置文件的最终结果是得到一个Configuration对象，使用该对象作为原材料，通过DefaultSqlSessionFactory创建SqlSession对象。SqlSession对象是整个mybatis操作数据库的核心。DefaultSqlSessionFactory创建SQLSession的方法主要有两个：</p>
<ol>
<li><p>根据数据源创建：</p>
<pre><code>private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;
    try {
      final Environment environment = configuration.getEnvironment();
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
        //执行器，用于处理SQL的执行的
      final Executor executor = configuration.newExecutor(tx, execType);
        //SqlSession对象是具有Configuration和Executor的
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeTransaction(tx); // may have fetched a connection so lets call close()
      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
}
</code></pre></li>
<li><p>根据连接（Connection）创建：</p>
<pre><code>private SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) {
    try {
      boolean autoCommit;
      try {
        autoCommit = connection.getAutoCommit();
      } catch (SQLException e) {
        // Failover to true, as most poor drivers
        // or databases won&apos;t support transactions
        autoCommit = true;
      }      
      final Environment environment = configuration.getEnvironment();
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      final Transaction tx = transactionFactory.newTransaction(connection);
      //执行器，用于处理SQL的执行的
      final Executor executor = configuration.newExecutor(tx, execType);
      //SqlSession对象是具有Configuration和Executor的
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
</code></pre></li>
</ol>
<h1 id="SqlSession的工作揭秘"><a href="#SqlSession的工作揭秘" class="headerlink" title="SqlSession的工作揭秘"></a>SqlSession的工作揭秘</h1><p>回到之前介绍的代码使用mybatis的demo代码：</p>
<pre><code>String resourcePath = &quot;./mybatis-config.xml&quot;;
InputStream is = null;
try {
    is = Resources.getResourceAsStream(resourcePath);
} catch (IOException e) {
    e.printStackTrace();
}

SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, &quot;development&quot;);
SqlSession sqlSession = sessionFactory.openSession();//1
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);//2
User user = userMapper.selectUser(id);
</code></pre><p>在上面的代码中的<code>1</code>处，获取了SqlSession,<code>2</code>处使用该SqlSession对象对映射接口进行处理，获取UserMapper的代理对象，在该代理对象的selectUser()方法中增强了一些和处理数据库相关的内容。这个userMapper代理对象生成的时间是在加载配置对象Configuration的时候。生成代理对象的代码：</p>
<pre><code>    private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            // 如果元素的名称是package
            if (&quot;package&quot;.equals(child.getName())) {
                // package元素的name属性就是包名
                String mapperPackage = child.getStringAttribute(&quot;name&quot;);
                // 包包名加入mapper集合,最终依然是调用configuration.addMapper(Class&lt;?&gt;type)方法
                configuration.addMappers(mapperPackage);
            } else {// 元素名称是mapper，一个mapper节点对应一个映射文件
                String resource = child.getStringAttribute(&quot;resource&quot;);
                String url = child.getStringAttribute(&quot;url&quot;);
                String mapperClass = child.getStringAttribute(&quot;class&quot;);
                if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {
                    ErrorContext.instance().resource(resource);
                    InputStream inputStream = Resources.getResourceAsStream(resource);
                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource,
                            configuration.getSqlFragments());
                    // parse()方法中依然是调用了configuration.addMapper(Class&lt;?&gt;type)方法
                    mapperParser.parse();
                } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {
                    ErrorContext.instance().resource(url);
                    // 来自网络的mapper xml
                    InputStream inputStream = Resources.getUrlAsStream(url);
                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url,
                            configuration.getSqlFragments());
                    // parse()方法中依然是调用了configuration.addMapper(Class&lt;?&gt;type)方法
                    mapperParser.parse();
                } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
                    configuration.addMapper(mapperInterface);
                } else {
                    throw new BuilderException(
                            &quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
                }
            }
        }
    }
}
</code></pre><h2 id="解析Mapper-xml文件"><a href="#解析Mapper-xml文件" class="headerlink" title="解析Mapper.xml文件"></a>解析Mapper.xml文件</h2><p>解析mapper文件的工作其实是在加载配置文件的时候就进行的了，解析涉及到的主要代码：</p>
<pre><code>private void parseConfiguration(XNode root) {
    try {
        // issue #117 read properties first
        propertiesElement(root.evalNode(&quot;properties&quot;));
        Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
        loadCustomVfs(settings);
        typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
        pluginElement(root.evalNode(&quot;plugins&quot;));
        objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
        objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
        reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
        settingsElement(settings);
        // read it after objectFactory and objectWrapperFactory issue #631
        environmentsElement(root.evalNode(&quot;environments&quot;));
        databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
        typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
        //从这里开始解析配置文件中mappers元素
        mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
        throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}
</code></pre><p>把解析到的mapper.class存放到Configuration对象中的mapperRegistry对象中，mapperRegistry对象负责管理各个mapper类。</p>
<pre><code>private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            // 如果元素的名称是package
            if (&quot;package&quot;.equals(child.getName())) {
                // package元素的name属性就是包名
                String mapperPackage = child.getStringAttribute(&quot;name&quot;);
                // 包包名加入mapper集合,最终依然是调用configuration.addMapper(Class&lt;?&gt;type)方法
                configuration.addMappers(mapperPackage);
            } else {// 元素名称是mapper，一个mapper节点对应一个映射文件
                String resource = child.getStringAttribute(&quot;resource&quot;);
                String url = child.getStringAttribute(&quot;url&quot;);
                String mapperClass = child.getStringAttribute(&quot;class&quot;);
                if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {
                    ErrorContext.instance().resource(resource);
                    InputStream inputStream = Resources.getResourceAsStream(resource);
                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource,
                            configuration.getSqlFragments());
                    // parse()方法中依然是调用了configuration.addMapper(Class&lt;?&gt;type)方法
                    mapperParser.parse();
                } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {
                    ErrorContext.instance().resource(url);
                    // 来自网络的mapper xml
                    InputStream inputStream = Resources.getUrlAsStream(url);
                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url,
                            configuration.getSqlFragments());
                    // parse()方法中依然是调用了configuration.addMapper(Class&lt;?&gt;type)方法
                    mapperParser.parse();
                } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
                    configuration.addMapper(mapperInterface);
                } else {
                    throw new BuilderException(
                            &quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
                }
            }
        }
    }
}
</code></pre><p>mpper.xml有四种方式可以表示映射资源：</p>
<ol>
<li>mapper.xml所在的包</li>
<li>单个文件的位置resource属性来定位</li>
<li>单个文件的位置url属性来定位</li>
<li>直接指定类的全限定名，通过class属性来定位。</li>
</ol>
<p>无论是哪种方式最终都会转化为mapper.xml文件中的命名空间指定的接口的class对象存放到Configuration对象中的mapperRegistry中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;使用的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯代码&lt;/li&gt;
&lt;li&gt;mybatis配置文件+代码，对于要学习mybatis的源码，这种方式是一
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/25/设计模式/</id>
    <published>2018-03-25T07:50:11.000Z</published>
    <updated>2018-03-25T10:30:23.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，有大神总结了23中设计模式，这些设计模式有各种各样的实现方式。常见的设计模式不过也就哪几种，我们很少使用其他设计模式的原因估计是太难一下记住这么多设计模式，可能有人说记住很简单，但是我要强调的一点是，即便你能全部记住，但是能熟练的使用真的很难，所以本文我只讨论几个比较简单的设计模式。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><ul>
<li><p>公有的静态成员变量来保存这个唯一的对象实例</p>
<pre><code>public class EagerSingleton1 {
    static {
        System.out.println(&quot;load class!&quot;);
    }
    public static final EagerSingleton1 SINGLETON = new EagerSingleton1();

    private EagerSingleton1() {
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement element = elements[2];
        System.out.println(&quot;call constructor!&quot; + element.getClassName());//1
    }

    public void test() {
        System.out.println(&quot;test&quot;);
    }
}
</code></pre><p>  配置：</p>
<pre><code>&lt;bean id=&quot;eagerSingleton1&quot; class=&quot;com.daniel.study.design_model.singleton.EagerSingleton1&quot;&gt;&lt;/bean&gt;
</code></pre><p>  测试：</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath*:/applicationContext.xml&quot;)
public class EagerSingleton1Test {

    @Autowired
    private EagerSingleton1 eagerSingleton1;//使用Spring的Ioc注入

    @Test
    public void test() {
        EagerSingleton1 singleton1 = EagerSingleton1.SINGLETON;
        System.out.println(eagerSingleton1 == singleton1);//2 false，说明破坏了单例
    }

}
</code></pre><p>  输出结果：</p>
<pre><code>load class!
call constructor!com.daniel.study.design_model.singleton.EagerSingleton1
call constructor!sun.reflect.NativeConstructorAccessorImpl
false
</code></pre><p>  对这种方式续做几点说明：</p>
<ol>
<li>这种方式的单例是不安全的，任然可以通过IOC的注入，IOC在实例化eagerSingleton1时调用了private的构造函数。因为Spring的IOC容器在实例化对象时使用反射方式，故知道反射可以破坏单例模式</li>
<li>从结果看1处别调用了两次，第二次是Spring实例化，第一次是在类加载的时候实例化的。</li>
<li>从2处的结果可以看出Spring实例化与类加载的时候实例化是不同的。</li>
</ol>
</li>
<li><p>使用公有的静态成员方法返回实例</p>
<pre><code>//需要单例的类型
public class EagerSingleton2 {
    static {
        System.out.println(&quot;load class!&quot;);
    }
    // 类加载的时候就实例化了
    private static final EagerSingleton2 SINGLETON = new EagerSingleton2();

    private EagerSingleton2() {
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement element = elements[2];
        System.out.println(&quot;call constructor!&quot; + element.getClassName());
    }

    public static EagerSingleton2 getInstance() {
        return SINGLETON;
    }
}
</code></pre><p>  配置：</p>
<pre><code>&lt;bean id=&quot;eagerSingleton2&quot; class=&quot;com.daniel.study.design_model.singleton.EagerSingleton2&quot;&gt;&lt;/bean&gt;
</code></pre><p>  测试：</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath*:/applicationContext.xml&quot;)
public class EagerSingleton2Test {

    @Autowired
    private EagerSingleton2 eagerSingleton2;

    @Test
    public void test() {
        EagerSingleton2 singleton1 = EagerSingleton2.getInstance();
        System.out.println(eagerSingleton2 == singleton1);
    }

}
</code></pre><p>  结果：</p>
<pre><code>load class!
call constructor!com.daniel.study.design_model.singleton.EagerSingleton2
call constructor!sun.reflect.NativeConstructorAccessorImpl
false
</code></pre><p>可以看出与前一种方式没有太大的区别，如果没有反射机制的话，这种两种方式都是比较好的实例化单例的方式，是线程安全的，且效率高。因为这两种方式都是在类加载的时候进行实例化，因为一个类在被卸载前只会加载一次。但由于反射机制的存在导致了单例设计被破坏。因为Spring的实例化就是借助的反射，所以使用Spring进行依赖注入单例对象，导致了创建了两个不同的对象。还有就是上面这两种方式都是饿汉模式，咋类加载的时候就实例化了，而不是在使用的时候实例化。在使用的时候实例化称作懒汉式。</p>
</li>
<li><p>懒汉单例模式</p>
<pre><code>//需要实例化为单例的类
public class LazySingleton1 {
    static {
        System.out.println(&quot;load class!&quot;);
    }
    private static LazySingleton1 lazySingleton1;

    private LazySingleton1() {
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement element = elements[2];
        System.out.println(&quot;call constructor!&quot; + element.getClassName());
    }

    public static LazySingleton1 getInstance() {
        if (lazySingleton1 == null) {
            lazySingleton1 = new LazySingleton1();
        }
        return lazySingleton1;
    }
}
</code></pre><p>  配置：</p>
<pre><code>&lt;bean id=&quot;lazySingleton1&quot; class=&quot;com.daniel.study.design_model.singleton.LazySingleton1&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre><p>  测试：</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath*:/applicationContext.xml&quot;)
public class LazySingleton1Test {

    @Autowired
    private LazySingleton1 lazySingleton1;

    @Test
    public void test() {
        LazySingleton1 lazySingleton2 = LazySingleton1.getInstance();
        System.out.println(lazySingleton1 == lazySingleton2);
    }

}
</code></pre><p>  结果：</p>
<pre><code>load class!
call constructor!sun.reflect.NativeConstructorAccessorImpl //1
call constructor!com.daniel.study.design_model.singleton.LazySingleton1//2
false
</code></pre></li>
</ul>
<p>这种方式也破坏了单例。但这里是Spring先实例化的，测试代码中的实例化是到调用getInstance静态方法的时候开始的，显然两次实例化的对象不一致，也是破坏了单例。上面的代码还有另外一个问题就是其实线程不安全的，为了保证线程安全，这段单例类的代码有两种改进办法：</p>
<pre><code>public class LazySingleton2 {
    static {
        System.out.println(&quot;load class!&quot;);
    }
    private static LazySingleton2 lazySingleton2;

    private LazySingleton2() {
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement element = elements[2];
        System.out.println(&quot;call constructor!&quot; + element.getClassName());
    }
    //方法上加锁
    public static synchronized LazySingleton2 getInstance() {
        if (lazySingleton2 == null) {
            lazySingleton2 = new LazySingleton2();
        }
        return lazySingleton2;
    }
}

//双重锁检查，避免指令重排序
public class Lazysingleton3 {
    static {
        System.out.println(&quot;load class!&quot;);
    }
    private volatile static Lazysingleton3 lazySingleton3;

    private Lazysingleton3() {
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement element = elements[2];
        System.out.println(&quot;call constructor!&quot; + element.getClassName());
    }

    public static Lazysingleton3 getInstance() {
        if (lazySingleton3 == null) {// 这步判断可以减少不必要的获取锁释放锁的操作
            synchronized (Lazysingleton3.class) {
                // 如果thread1来到这里把CPU释放了，同时释放了锁，那么Thread2可以进入这里，
                // 即两个线程中的计数器都已经指到了这里的指令，如果不进行非空判断,势必会破坏单例
                if (lazySingleton3 == null) {
                    lazySingleton3 = new Lazysingleton3();
                }
            }
        }
        return lazySingleton3;
    }
}
</code></pre><ul>
<li><p>静态内部类进行实例化</p>
<pre><code>public class LazySingleton4 {

    static {
        System.out.println(&quot;loader class 1&quot;);
    }

    private LazySingleton4() {
        System.out.println(&quot;LazySingleton4 class loaded!&quot;);
    }

    static {
        System.out.println(&quot;loader class 2&quot;);
    }

    private static class SingletongHandler {
        static {
            System.out.println(&quot;loader class 3&quot;);
        }
        private static final LazySingleton4 lazySingleton4 = new LazySingleton4();
        static {
            System.out.println(&quot;loader class 4&quot;);
        }
    }

    public static LazySingleton4 getInstance() {
        return SingletongHandler.lazySingleton4;
    }

}
</code></pre><p>  配置：</p>
<pre><code>&lt;bean id=&quot;lazySingleton4_1&quot; class=&quot;com.daniel.study.design_model.singleton.LazySingleton4&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre><p>  测试：</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath*:/applicationContext.xml&quot;)
public class LazySingleton4Test {

    @Autowired
    private LazySingleton4 lazySingleton4_1;

    @Test
    public void test() {
        LazySingleton4 lazySingleton4_2 = LazySingleton4.getInstance();
        System.out.println(lazySingleton4_1 == lazySingleton4_2);
    }

}
</code></pre><p>  结果：</p>
<pre><code>loader class 1
loader class 2
LazySingleton4 class loaded!//Spring实例化
loader class 3
LazySingleton4 class loaded!//代码中使用getInstance的地方
loader class 4
false
</code></pre></li>
</ul>
<p>这里的懒汉式与前面不同，前面使用的方式是用代码来控制懒加载的，这里使用的是jvm加载类的原理来进行懒加载的。只有在调用LazySingleton4.getInstance()的时候才会加载类SingletongHandler，而类在卸载前只会被加载一次，故保证了单例的唯一性。但是我们仍需要注意到，Spring的实例化并不是单例对象，即这种方式也会通过反射破坏单例。</p>
<p>上面的方式，在反射面前都不能保证单例了（Spring就是通过反射的方式实例化对象的，这里用Spring进行实例化的时候，都导致了单例被破坏）。下面介绍一种反射不能破坏的单例模式。</p>
<ul>
<li><p>使用枚举实现单例</p>
<pre><code>public enum EnumSingleton {
    INSTANCE;
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void test() {
        System.out.println(this.getName());
    }
}
</code></pre><p>  Spring配置枚举的实例：</p>
<pre><code>&lt;bean id=&quot;INSTANCE&quot; class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot;&gt;    
    &lt;property name=&quot;staticField&quot; value=&quot;com.daniel.study.design_model.singleton.EnumSingleton.INSTANCE&quot; /&gt;    
&lt;/bean&gt;
</code></pre><p>  测试：</p>
</li>
</ul>
<pre><code>    public class EnumSingletonTest {

        @Test
        public void testTest() {
            ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:./applicationContext.xml&quot;);
            EnumSingleton singleton1 = (EnumSingleton) ctx.getBean(&quot;INSTANCE&quot;);
            EnumSingleton singleton2 = EnumSingleton.INSTANCE;
            System.out.println(&quot;EnumSingleton:&quot;+singleton1 == singleton2);
        }

    }

结果：

    EnumSingleton:true
</code></pre><p>可以看出使用Enum实现的单例没有被Spring的实例化破坏，即反射不能破坏Enum单例模式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反射可以破坏单例模式，在设计单例类的时候需要注意这一点，除了反射外，序列化/反序列化，clone（所以单例类不能继承Clonable接口）也会破坏单例模式。如果想单例模式不被反射破坏，可以使用Enum（枚举）来设计单例类。这种方式也可以阻止序列化/反序列化对单例模式的破坏。</p>
<p>为了保证单例模式不被反射或者序列化/反序列化破坏，可以这样做:声明一个私有的静态成员变量，用来做flag，如果已经调用构造函数实例化了，第二次就不能实例化了。这种方式的依据是无论是反射实例化，还是正常的实例化最终都需要调用构造方法。不过如果getInstance的执行在反射实例化之后，这种方法可能会导致通过getInstance方法获取实例不生效。对于序列化类的实例化，在类中加入readResolve就可以避免单例模式被破坏。</p>
<p>综上，使用枚举实现单例模式是即安全，有快捷的。</p>
<pre><code>//加了标志的单例类
public class GoodSingleton {
    private static boolean flag = false;
    private static final GoodSingleton SINGLETON = new GoodSingleton();
    static {
        System.out.println(&quot;class load&quot;);
    }

    private GoodSingleton() {
        if (flag) {
            throw new RuntimeException(&quot;破坏了单例模式&quot;);
        }
        flag = true;
        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        StackTraceElement element = elements[2];
        System.out.println(&quot;first call&quot;);
        System.out.println(&quot;call constructor!&quot; + element.getClassName());
    }

    public static GoodSingleton getInstance() {
        return SINGLETON;
    }
}
</code></pre><p>   配置：</p>
<pre><code>&lt;bean id=&quot;goodSingleton1&quot; class=&quot;com.daniel.study.design_model.singleton.GoodSingleton&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre><p>   测试：</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath*:/applicationContext.xml&quot;)
public class GoodSingletonTest {

    @Autowired
    private GoodSingleton goodSingleton1;

    @Test
    public void test() {
        GoodSingleton goodSingleton2 = GoodSingleton.getInstance();
        System.out.println(goodSingleton1 == goodSingleton2);
    }

}
</code></pre><p>   结果：</p>
<pre><code>first call
call constructor!com.daniel.study.design_model.singleton.GoodSingleton//1
class load

Caused by: java.lang.RuntimeException: 破坏了单例模式 //2
at com.daniel.study.design_model.singleton.GoodSingleton.&lt;init&gt;(GoodSingleton.java:12)
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:170)
... 43 more
</code></pre><p>类GoodSingleton加载的时候执行了实例化，就是结果中的1，在这里第一次调用了构造函数。在Spring准备实例化GoodSingleton的时候，flag已是true，所以抛出了异常，即不准调用构造函数两次。对于序列化/反序列化破坏了单例的情况便不能用以上面这种方式解决了，因为反序列化不需要调用构造函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;众所周知，有大神总结了23中设计模式，这些设计模式有各种各样的实现方式。常见的设计模式不过也就哪几种，我们很少使用其他设计模式的原因估计是太
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring源码解析——想到哪里就说到哪里</title>
    <link href="http://yoursite.com/2018/03/24/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%83%B3%E5%88%B0%E5%93%AA%E9%87%8C%E5%B0%B1%E8%AF%B4%E5%88%B0%E5%93%AA%E9%87%8C/"/>
    <id>http://yoursite.com/2018/03/24/Spring源码解析——想到哪里就说到哪里/</id>
    <published>2018-03-24T13:32:13.000Z</published>
    <updated>2018-03-25T10:31:28.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p>事件的基础类是java.util.EventObject,其中有一个属性是source，类型是Object，表示的是事件发生的地方（源头）。在Spring中继承这个类后构成了自己的一个Spring的事件的基础类ApplicationEvent，该类在整个Spring的上下文中都有用，是一个抽象类。ApplicationEvent中新增了一个属性就是timeStamp时间戳，表示事件发生的时间。Spring中的事件对象的层次结构：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/spring-events.png" alt="Spring Events"></p>
<p>四个ApplicationContextEvent的实现都很简单，就是定义了一个参数类型为ApplicationContext的构造函数，这个参数是作为事件源的。</p>
<p>RequestHandleEvent应用上下文中的请求事件，添加了一些区别请求的属性。</p>
<p>PayloadApplicationEvent，是这个家族中较复杂的事件了，表示上下文过载事件。<br>BrokerAvailabilityEvent用于通知message可以用的事件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件机制&quot;&gt;&lt;a href=&quot;#事件机制&quot; class=&quot;headerlink&quot; title=&quot;事件机制&quot;&gt;&lt;/a&gt;事件机制&lt;/h1&gt;&lt;p&gt;事件的基础类是java.util.EventObject,其中有一个属性是source，类型是Object，表示的是事件发生
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://yoursite.com/2018/03/18/MyBatis/"/>
    <id>http://yoursite.com/2018/03/18/MyBatis/</id>
    <published>2018-03-18T07:45:07.000Z</published>
    <updated>2018-03-18T16:01:37.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置文件中的元素"><a href="#配置文件中的元素" class="headerlink" title="配置文件中的元素"></a>配置文件中的元素</h1><p>根元素：</p>
<pre><code>&lt;configuration&gt;&lt;/configuration&gt;
</code></pre><p><configuration\>的子元素:</configuration\></p>
<pre><code>&lt;properties&gt;&lt;/properties&gt;
&lt;settings&gt;&lt;/settings&gt;
&lt;typeAliases&gt;&lt;/typeAliases&gt;
&lt;environments&gt;&lt;environments&gt;
&lt;typeHandlers&gt;&lt;typeHandlers&gt;
&lt;objectFactory&gt;&lt;/objectFactory&gt;
&lt;plugins&gt;&lt;/plugins&gt;
</code></pre><h2 id="类型处理器typeHandlers"><a href="#类型处理器typeHandlers" class="headerlink" title="类型处理器typeHandlers"></a>类型处理器typeHandlers</h2><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。例如：</p>
<pre><code>// ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
</code></pre><p>在配置文件中配置该类型处理器：</p>
<pre><code>&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre><p>使用如上的类型处理器的作用：</p>
<ol>
<li>将会覆盖已经存在的处理Java的String类型属性的类型处理器。</li>
<li>将会覆盖已经存在的处理VARCHAR参数及结果的类型处理器。</li>
</ol>
<p>因为Mybatis不会知道数据库元信息来决定使用哪种类型，所以必须在参数和结果映射中指明那个是VARCHAR类型的字段，以使其能够绑定到正确的类型处理器上。</p>
<p>通过类型处理器的泛型，如上的<string>，Mybatis可以得知该类型处理器处理的Java类型，但是这种行为可以通过两种方式改变：</string></p>
<ul>
<li><p>在类型处理器的配置元素（typeHandler element）上增加一个 javaType 属性。</p>
<pre><code>&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot; javaType=&quot;String&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre></li>
<li>在类型处理器的类上（TypeHandler class）增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表，<strong>如果在 javaType 属性中也同时指定，则注解方式将被忽略.</strong></li>
</ul>
<p>可以通过两种方式来指定被关联的JDBC类型：</p>
<ul>
<li><p>在类型处理器的配置元素上增加一个 jdbcType 属性</p>
<pre><code>&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot; jdbcType=&quot;String&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre></li>
<li>在类型处理器的类上（TypeHandler class）增加一个 @MappedJdbcTypes 注解来指定与其关联的 JDBC 类型列表，<strong>如果在 jdbcType 属性中也同时指定，则注解方式将被忽略。</strong></li>
</ul>
<h2 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h2><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<h2 id="配置环境（environments）"><a href="#配置环境（environments）" class="headerlink" title="配置环境（environments）"></a>配置环境（environments）</h2><p>Mybatis可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置。</p>
<p>不过要记住的是：<strong>每个数据库对应一个 SqlSessionFactory 实例</strong>。</p>
<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p>
<pre><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);
</code></pre><h3 id="事务管理器transactionManager"><a href="#事务管理器transactionManager" class="headerlink" title="事务管理器transactionManager"></a>事务管理器transactionManager</h3><p>Mybatis有两种类型的事务管理器：</p>
<ul>
<li>JDBC 直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域</li>
<li>MANAGED 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）</li>
</ul>
<p><strong>如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</strong></p>
<p>上面提到的两种事务管理器都不需要任何属性，它们都是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。</p>
<pre><code>public interface TransactionFactory {
  void setProperties(Properties props);  
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);  
}
</code></pre><p>你也需要创建一个 Transaction 接口的实现类，这个接口也很简单：</p>
<pre><code>public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}
</code></pre><p><strong>使用这两个接口，你可以完全自定义 MyBatis 对事务的处理</strong>。</p>
<h3 id="数据源-DataSource"><a href="#数据源-DataSource" class="headerlink" title="数据源 DataSource"></a>数据源 DataSource</h3><p>Mybatis有三种内置的数据源类型：</p>
<ul>
<li>UNPOOLED 这个数据源的实现只是每次被请求时打开和关闭连接，没有连接池的必要的应用或数据库可以选择这种类型。这种类型的数据源只需要配置五种属性：driver、url、username、password和defaultTransactionIsolationLevel（默认的事务隔离级别）</li>
<li>POOLED 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。</li>
<li>JNDI 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种类型的数据源有两个属性：initial_context （用来在 InitialContext 中寻找上下文）和data_source （这是引用数据源实例位置的上下文的路径）</li>
</ul>
<p><strong>使用第三方数据源</strong> 你可以通过实现接口 org.apache.ibatis.datasource.DataSourceFactory 来使用第三方数据源：</p>
<pre><code>public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}
</code></pre><p>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：</p>
<pre><code>import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

  public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
  }
}
</code></pre><h2 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h2><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可：</p>
<pre><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt;
</code></pre><h2 id="映射器-mapper"><a href="#映射器-mapper" class="headerlink" title="映射器 mapper"></a>映射器 mapper</h2><p>告诉mybatis去哪里寻找SQL的映射语句。</p>
<h1 id="XML映射文件中元素"><a href="#XML映射文件中元素" class="headerlink" title="XML映射文件中元素"></a>XML映射文件中元素</h1><p>SQL 映射文件有很少的几个顶级元素：</p>
<ul>
<li>cache 给定命名空间的缓存配置</li>
<li>cache-ref 其他命名空间的缓存的引用</li>
<li>resultMap 是最复杂也最强的的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li>sql 可被其他语句引用的可重用语句块</li>
<li>insert 映射插入语句</li>
<li>update 映射更新语句</li>
<li>delete 映射删除语句</li>
<li>select 映射查询语句</li>
</ul>
<p>语句中的#{xxx}告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中。</p>
<h2 id="select的常见属性"><a href="#select的常见属性" class="headerlink" title="select的常见属性"></a>select的常见属性</h2><pre><code>&lt;select
  id=&quot;selectPerson&quot;
  parameterType=&quot;int&quot;
  parameterMap=&quot;deprecated&quot;
  resultType=&quot;hashmap&quot;
  resultMap=&quot;personResultMap&quot;
  flushCache=&quot;false&quot;
  useCache=&quot;true&quot;
  timeout=&quot;10000&quot;
  fetchSize=&quot;256&quot;
  statementType=&quot;PREPARED&quot;
  resultSetType=&quot;FORWARD_ONLY&quot;&gt;
</code></pre><ul>
<li>id 在命名空间中唯一的标识符，可以被用来引用这条语句。</li>
<li>parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</li>
<li>resultType 从这条语句中返回的期望类型的类的完全限定名或别名。<strong>注意如果是集合情形，那应该是集合可以包含的类型，</strong>而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</li>
<li>resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</li>
<li>flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</li>
<li>useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</li>
<li>timeout 这个设置是在抛出异常之前(有异常就会立即返回)，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）</li>
<li>fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）</li>
<li>statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED</li>
<li>resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。</li>
<li>databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</li>
<li>resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</li>
<li>这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。</li>
</ul>
<h2 id="delete、update和insert的常见属性"><a href="#delete、update和insert的常见属性" class="headerlink" title="delete、update和insert的常见属性"></a>delete、update和insert的常见属性</h2><pre><code>&lt;insert
  id=&quot;insertAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  keyProperty=&quot;&quot;
  keyColumn=&quot;&quot;
  useGeneratedKeys=&quot;&quot;
  timeout=&quot;20&quot;&gt;

&lt;update
  id=&quot;updateAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;

&lt;delete
  id=&quot;deleteAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;
</code></pre><p>与select相同的属性在这里就不解释了，解释select没有的</p>
<ul>
<li>useGeneratedKeys 这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键</li>
<li>keyProperty 唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值</li>
<li>keyColumn 通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。</li>
</ul>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为:</p>
<pre><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;
    keyProperty=&quot;id&quot;&gt;
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
&lt;/insert&gt;
</code></pre><p>${xxx} 映射语句内部的参数传递。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>对于数值类型，还有一个小数保留位数的设置，来确定小数点后保留的位数。</p>
<pre><code>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}
</code></pre><p><strong>字符串替换</strong>：</p>
<p>默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数并安全地设置参数（就像使用 ? 一样）。这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串。比如，像 ORDER BY，你可以这样来使用：</p>
<pre><code>ORDER BY ${columnName} -- 这里 MyBatis 不会修改或转义字符串。即不会被？替换
</code></pre><p><strong>注：用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。</strong></p>
<h2 id="Result-Maps"><a href="#Result-Maps" class="headerlink" title="Result Maps"></a>Result Maps</h2><p>ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 </p>
<p>ResultMap有许多的子元素，下面是其元素的概念图：</p>
<ul>
<li>constructor   用于在实例化类时，注入结果到构造方法中<ul>
<li>idArg   ID 参数;标记出作为 ID 的结果可以帮助提高整体性能</li>
<li>arg  将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>id 一个 ID 结果;标记出作为 ID 的结果可以帮助提高整体性能</li>
<li>result  注入到字段或 JavaBean 属性的普通结果.</li>
<li>association 一个复杂类型的关联;许多结果将包装成这种类型。<ul>
<li>嵌套结果映射 – 关联可以指定为一个 resultMap 元素，或者引用一个</li>
</ul>
</li>
<li>collection  一个复杂类型的集合<ul>
<li>嵌套结果映射 – 集合可以指定为一个 resultMap 元素，或者引用一个</li>
</ul>
</li>
<li>discriminator  使用结果值来决定使用哪个 resultMap<ul>
<li>case – 基于某些值的结果映射<ul>
<li>嵌套结果映射 – 一个 case 也是一个映射它本身的结果,因此可以包含很多相 同的元素，或者它可以参照一个外部的 resultMap</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。<br>xml映射器中常用的用于组装动态SQL的元素：</p>
<ul>
<li>if</li>
<li>choose(when,otherwise)</li>
<li>trim(where,set)</li>
<li>foreach</li>
</ul>
<p>自定义 trim 元素来定制 where 元素的功能:</p>
<pre><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;
  ... 
&lt;/trim&gt;
</code></pre><p>set 元素等价的自定义 trim 元素:</p>
<pre><code>&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;
  ...
&lt;/trim&gt;
</code></pre><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：</p>
<pre><code>&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;
  &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + _parameter.getTitle() + &apos;%&apos;&quot; /&gt;
  SELECT * FROM BLOG
  WHERE title LIKE #{pattern}
&lt;/select&gt;
</code></pre><h1 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h1><p>MyBatis的主要接口就是SqlSession，可以通过这个接口来执行命令，获取映射器和管理事务。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象包含创建 SqlSession 实例的所有方法。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或手动配置 Java 代码来创建 SqlSessionFactory</p>
<p>注意：当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）同时使用时，SqlSessions 将被依赖注入框架所创建，所以你不需要使用 SqlSessionFactoryBuilder 或者 SqlSessionFactory。</p>
<p>MyBatis中比较重要的三个类：</p>
<ul>
<li>SqlSessionFactoryBuilder 用于创建SqlSessionFactory</li>
<li>SqlSessionFactory 用于创建SqlSession</li>
<li><p>SqlSession SqlSession 实例在 MyBatis 中是非常强大的一个类,其中包括超过20个方法，对这些方法进行简单的分类：</p>
<ul>
<li>执行语句的方法</li>
<li>提交或回滚事务的方法</li>
<li><p>获取映射器实例的方法</p>
<h2 id="执行语句的方法"><a href="#执行语句的方法" class="headerlink" title="执行语句的方法"></a>执行语句的方法</h2><p>这些方法被用来执行定义在 SQL 映射的 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。它们都会自行解释，每一句都使用语句的 ID 属性和参数对象，参数可以是原生类型（自动装箱或包装类）、JavaBean、POJO 或 Map。这些方法如下：</p>
<p>  <t> T selectOne(String statement, Object parameter)<br>  <e> List<e> selectList(String statement, Object parameter)<br>  <k,v> Map<k,v> selectMap(String statement, Object parameter, String mapKey)<br>  int insert(String statement, Object parameter)<br>  int update(String statement, Object parameter)<br>  int delete(String statement, Object parameter)</k,v></k,v></e></e></t></p>
</li>
</ul>
</li>
</ul>
<p>selectMap 稍微特殊一点，因为它会将返回的对象的其中一个属性作为 key 值，将对象作为 value 值，从而将多结果集转为 Map 类型值。</p>
<h2 id="事务控制方法"><a href="#事务控制方法" class="headerlink" title="事务控制方法"></a>事务控制方法</h2><p>如果你已经设置了自动提交或你正在使用<strong>外部事务管理器</strong>，这就没有任何效果了。然而，如果你正在使用 JDBC 事务管理器，由Connection 实例来控制，那么这四个方法就会派上用场：</p>
<pre><code>void commit()
void commit(boolean force)
void rollback()
void rollback(boolean force)
</code></pre><p>MyBatis-Spring 和 MyBatis-Guice 提供了声明事务处理，所以如果你在使用 Mybatis 的同时使用了Spring 或者 Guice，那么请参考它们的手册以获取更多的内容。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>MyBatis使用了两种缓存:本地缓存（local cache）和二级缓存（second level cache）。</p>
<p>每当一个新 session 被创建，MyBatis 就会创建一个与之相关联的本地缓存。任何在 session 执行过的查询语句本身都会被保存在本地缓存。默认情况下，本地缓存数据可在整个 session 的周期内使用，这一缓存需要被用来解决循环引用错误和加快重复嵌套查询的速度，所以它可以不被禁用掉，但是你可以设置localCacheScope=STATEMENT 表示缓存仅在语句执行时有效本地缓存会被增删改、提交事务、关闭事务以及关闭 session 所清空。</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p> #{param}和${param}的区别？</p>
<pre><code>答：前者可以防止SQL注入；参数中含有单引号的时候可以自动转义；把参数值转为字符串的形式。后者可以用来拼接SQL，必须用${param}的地方： order by   ${column}。
</code></pre><p>如果xml中有特殊符号的处理方式？</p>
<pre><code>答：加上转义标签&lt;![CDATA[sql语句]]&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置文件中的元素&quot;&gt;&lt;a href=&quot;#配置文件中的元素&quot; class=&quot;headerlink&quot; title=&quot;配置文件中的元素&quot;&gt;&lt;/a&gt;配置文件中的元素&lt;/h1&gt;&lt;p&gt;根元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;configuration&amp;gt;&amp;lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协议</title>
    <link href="http://yoursite.com/2018/03/17/%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/03/17/协议/</id>
    <published>2018-03-17T01:16:00.000Z</published>
    <updated>2018-06-01T00:09:22.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP的全称是超文本传输协议（Hyper Text Transfer Protocol）,用于从万维互联网服务器传输超文本到本地浏览器的协议，是基于TCP、IP通信协议来传输数据的。</p>
<p>主要特点：</p>
<ul>
<li>简单快捷，客户向服务器请求服务时，只需要请求方法和路径，请求方法有POST、GET、PUT等。由于HTTP简单，所以网络通信中的处理速度很快。</li>
<li>灵活， 可以传输任意类型的数据对象，正在传输的类型由Content-Type确定。</li>
<li>无连接，限制每次连接只处理一次请求。服务器处理完请求后，把响应给到客户端，就关闭了连接。节省请求的排队等待时延。</li>
<li>无状态，指的是对事物处理没有记忆功能，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
<li>支持B/S和C/S模式。</li>
</ul>
<h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p><a href="http://localhost:8080/home/index.htm?username=1234&amp;age=24#name" target="_blank" rel="external">http://localhost:8080/home/index.htm?username=1234&amp;age=24#name</a></p>
<ul>
<li>协议部分：指明了本次请求使用的协议，可以有http，https等。</li>
<li>域名部分：就是服务器IP地址。</li>
<li>端口部分：跟在域名后的数字就是端口，与域名之间用“：”分割</li>
<li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。不是URL的必须部分</li>
<li>文件名部分：从最后一个“/”开始到URL结尾，或者到“？”，又或者到“#”</li>
<li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，多个参数之间用“&amp;”分割</li>
<li>锚部分从“#”开始到最后，都是锚部分。</li>
</ul>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><ul>
<li>Web上使用的任何资源都可以由URI（Uniform Resource Identifier,统一资源标识）来定位。</li>
<li>URL（Uniform Resource Locator，统一资源定位器)它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源</li>
<li>URN（Uniform Resource Name，统一资源命名）是通过名字来标识资源。</li>
</ul>
<p>总之，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>请求消息的格式：</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/http2.png" alt=""></p>
<p>请求消息包括请求行、请求头部、空行和请求数据四部分。</p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>HTTP响应的消息格式：<br><img src="https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>响应消息包括状态行、消息报头、空行和响应正文。</p>
<p>空行的作用是为了区分不同类型的请求或响应的数据位置。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>由三位数字组成，第一位定义了响应的类别</p>
<ul>
<li>1xx:指示信息，表示请求已接收，正在处理</li>
<li>2xx:成功，表示请求已经被成功接收，理解和处理。</li>
<li>3xx:重定向，要完成请求必须进行更进一步的操作</li>
<li>4xx:客户端错误，请求有语法错误，或者请求无法实现</li>
<li>5xx:服务端错误，服务端未能实现合法的请求。</li>
</ul>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>HTTP1.0定义了三种：GET、POST和HEAD<br>HTTP1.1新增了五中：OPTIONS、PUT、DELETE、TRACE和CONNECT</p>
<ul>
<li>GET 请求指定的页面信息，并返回实体主体，请求的数据通过URL设置</li>
<li>HEAD 类似于GET请求，只不过返回的响应中没有具体内容，用于获取报头</li>
<li>POST 向指定资源提交数据进行处理请求，<strong>数据被包含在请求体中</strong>。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT 文档内容的替换</li>
<li>DELETE 请求服务器删除指定资源</li>
<li>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>
<li>OPTIONS 允许客户端查看服务器的性能</li>
<li>TRACE 回显服务器请求，主要用于测试和诊断。</li>
</ul>
<p>HTTP是基于TCP套接字传输的，TCP连接的释放是由服务端主动发起的，客户端被动接受。 </p>
<h3 id="POST和GET比较"><a href="#POST和GET比较" class="headerlink" title="POST和GET比较"></a>POST和GET比较</h3><ul>
<li>请求报文不一样</li>
<li>数据携带的方式不一样</li>
<li>能传输的数据大小不一样</li>
<li>安全性不一样</li>
<li></li>
</ul>
<p>注意：POST不支持复杂的数据类型。soap：是http post的一个专用版本，遵循一种特殊的xml消息格式，Content-type设置为: text/xml 任何数据都可以xml化。</p>
<h2 id="HTTPs"><a href="#HTTPs" class="headerlink" title="HTTPs"></a>HTTPs</h2><p>HTTP的缺点：</p>
<ul>
<li>通信使用明文，内容可能被窃听</li>
<li>不验证通信房的身份，因此有可能遭遇伪装</li>
</ul>
<p>解决如上的HTTP问题我们能想到的是：</p>
<ul>
<li>进行通信加密，HTTP协议中没有加密机制，但可以通过和SSL或TLS（Transport LayerSecurity,传输层安全协议）的组合加密。    加密的是HTTP的通信内容。用SSL建立安全通信线路后，就可以在这条线路上进行HTTP通信了。</li>
<li>内容加密，把参与通信的内容本身进行加密。由于HTTP协议中没有加密机制，那几对HTTP传输的内容进行加密。这种情况下客户端和服务端对数据内容都要有一个加解密的过程。</li>
</ul>
<p><strong><em>注：第三方证书颁发机构的主要目的是提供可靠的客户端或服务端。</em></strong></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>HTTP+ 加密 + 认证 + 完整性保护 =HTTPS。证书可以证明服务端和客户端的身份。HTTPs并非应用层的一种协议，知识HTTP通信接口部分用SSL和TLS协议替代而已。通常HTTP直接和TCP通信，当使用SSL后，演变成了先和SSL通信，然后SSL在和TCP通信。</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/https.png" alt=""></p>
<h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL是独立与HTTP的协议，所以不光是HTTP协议，其他的运行在应用层的协议，如SMTP、Telnet等均可配合SSL协议使用，SSL是当今世界上应用最为广泛的网络安全技术。</p>
<h3 id="HTTPs的加密机制"><a href="#HTTPs的加密机制" class="headerlink" title="HTTPs的加密机制"></a>HTTPs的加密机制</h3><p>什么是共享秘钥加密？</p>
<p>加密和解密都使用同一个秘钥的方式称为共享秘钥加密，也叫对称加密。</p>
<p>什么是公开秘钥加密？</p>
<p>使用两把秘钥中的公开秘钥加密，用自己保留的私有秘钥进行解密，即加密和解密的秘钥不一样，也称非对称秘钥加密。</p>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。<strong>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</strong></p>
<h3 id="使用第三方认证机构进行安全通信的原理"><a href="#使用第三方认证机构进行安全通信的原理" class="headerlink" title="使用第三方认证机构进行安全通信的原理"></a>使用第三方认证机构进行安全通信的原理</h3><ol>
<li>服务器的运营人员向数字证书认证机构提出公开秘钥的申请，对已申请的公开秘钥做数字签名，然后分配这个已签名的公开秘钥，并将该公开密钥放入公钥证书后绑定在一起。之后把该证书发给服务器。</li>
<li>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。</li>
<li>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</li>
<li>怎么能把认证机构的公开秘钥给到客户端呢？其实很简单，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</li>
<li>客户端就可以使用服务端的公开秘钥进行加密了，把加密后的数据发送给服务器，只有服务器有私有秘钥，因此也只有他才能解析数据。</li>
</ol>
<h3 id="SSL和TSL"><a href="#SSL和TSL" class="headerlink" title="SSL和TSL"></a>SSL和TSL</h3><p>SSL最初是由网景公司开发的，最高版本是SSL3.0。后来 IETF（Internet Engineering Task Force，Internet 工程任务组）在SSL基础上开发了TSL。当前主流的版本是SSL3.0 和 TLS1.0。</p>
<h2 id="HTTP和HTTPs"><a href="#HTTP和HTTPs" class="headerlink" title="HTTP和HTTPs"></a>HTTP和HTTPs</h2><p>HTTPs是比HTTP慢，一种是通信慢，一种是CPU处理慢。</p>
<ol>
<li>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</li>
<li>SSL必须进行加解密处理，在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</li>
</ol>
<h2 id="处理HTTP请求并发量大的问题"><a href="#处理HTTP请求并发量大的问题" class="headerlink" title="处理HTTP请求并发量大的问题"></a>处理HTTP请求并发量大的问题</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>使用Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）技术，实现页面上的异步刷新，减少HTTP通信中的数据发送量。Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。</p>
<p>解决了通信过程中的数据量问题，但可能引入了更多的HTTP请求。同样Ajax也不能解决HTTP本身的问题</p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。</p>
<p>为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet 也仍未解决 HTTP 协议本身存在的问题。</p>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><p>陆续出现的 Ajax 和 Comet 等提高易用性的技术，一定程度上使 HTTP 得到了改善，但 HTTP 协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP 所遭遇的瓶颈。</p>
<h2 id="Web攻击技术"><a href="#Web攻击技术" class="headerlink" title="Web攻击技术"></a>Web攻击技术</h2><p>HTTP协议本身并不具备安全功能，有些协议本身是具有安全的功能，比如远程登录用到的SSH协议，SSH 具备协议级别的认证及会话管理等功能。</p>
<h3 id="在客户端篡改请求"><a href="#在客户端篡改请求" class="headerlink" title="在客户端篡改请求"></a>在客户端篡改请求</h3><p>在Web应用中，从浏览器接收到的HTTP请求的全部内容，都可以在客户端自由的变更，篡改。所有Web服务可能会接收到与预期不符的请求数据。在HTTP请求的报文内中加入攻击代码，就可以对Web应用进行攻击。</p>
<p>通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。</p>
<p>对web应用的攻击机模式主要有两种，主动攻击和被动攻击。</p>
<p><strong>主动攻击</strong></p>
<p>攻击这通过直接访问Web应用，把攻击代码传入的攻击模式。直接针对服务器上的资源进行攻击，因此需要能访问那些资源。具有代表性的主动攻击有：SQL注入攻击和OS命令注入攻击。</p>
<p><strong> 被动攻击 </strong></p>
<p>利用社会工程学执行攻击代码的攻击模式。攻击者不直接对目标Web应用发起攻击。常见的被动攻击：跨站脚本攻击和跨站点请求伪造。</p>
<h3 id="常见的攻击"><a href="#常见的攻击" class="headerlink" title="常见的攻击"></a>常见的攻击</h3><p><strong>跨站脚本攻击</strong>（Cross-Site Scripting，XSS）：通过在存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分可能隐藏着安全漏洞。</p>
<p>跨站攻击的可能影响：</p>
<ol>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下帮攻击者发送恶意请求。</li>
<li>显示伪造的文章和图片。</li>
</ol>
<p><strong>HTTP首部注入攻击</strong>（HTTP Header Injection）：攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击，属于被动攻击模式。向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTP Response SplittingAttack）。</p>
<p>HTTP首部注入攻击的影响：</p>
<ol>
<li>设置任何Cookie的信息</li>
<li>重定向至任一URL</li>
<li>显示任意的主体</li>
</ol>
<p><strong>SQL注入攻击</strong>（SQL Injection）：针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。如果在调用 SQL 语句的方式上存在疏漏，就有可能执行被恶意注入（Injection）非法 SQL 语句。</p>
<p>SQL注入攻击可能的影响：</p>
<ol>
<li>非法查看或篡改数据</li>
<li>规避认证</li>
</ol>
<p><strong>OS命令注入攻击</strong>（OS Command Injection）指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。可以从 Web 应用中通过 Shell 来调用操作系统命令。倘若调用 Shell 时存在疏漏，就可以执行插入的非法 OS 命令</p>
<p><strong>开放重定向</strong>（Open Redirect）：对指定的任意 URL 作重定向跳转的功能。此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。这种情况会导致钓鱼攻击，用户重定向到了一个钓鱼网站。</p>
<p><strong>点击劫持</strong>（Clickjacking）：利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。又叫页面伪装。</p>
<p><strong>DOS攻击</strong>（Denial of Service attack，拒绝服务攻击）：让运行中的服务成停止状态的攻击，DOS攻击的对象不仅限于Web网站，还包括网络设备和服务器等。</p>
<p>主要的攻击方式是：</p>
<ol>
<li>几种利用访问访问请求，造成资源过载，资源用尽的同时，实际上服务也就成停止状态。</li>
<li>通过攻击安全漏洞，让服务停止。</li>
</ol>
<p>多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial of Service attack）。DDoS 攻击通常利用那些感染病毒的计算机（肉机）作为攻击者的攻击跳板</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;应用层协议&quot;&gt;&lt;a href=&quot;#应用层协议&quot; class=&quot;headerlink&quot; title=&quot;应用层协议&quot;&gt;&lt;/a&gt;应用层协议&lt;/h1&gt;&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java面试宝典</title>
    <link href="http://yoursite.com/2018/03/10/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    <id>http://yoursite.com/2018/03/10/Java面试宝典/</id>
    <published>2018-03-10T03:02:34.000Z</published>
    <updated>2018-03-13T14:50:35.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="JDK目录结构"><a href="#JDK目录结构" class="headerlink" title="JDK目录结构"></a>JDK目录结构</h2><ul>
<li>bin JDK开发工具的可执行文件，配置java的环境变量的时候Path需要指向该目录</li>
<li>lib 开发工具使用的归档包路径</li>
<li>jre java运行时环境的根目录，包含java虚拟机，运行时的类包，java应用的启动器,java应用程序要运行起来依赖的最小目录</li>
<li>include 包含C语言头文件,支持Java本地接口与Java虚拟机调试程序接口。</li>
<li><p>jre/lib 代码库、树形设置以及JRE使用的源文件。rt.jar是java运行时类库，是用得最多的基础类库，包含java.lang,java.io,java.net,java.util等。</p>
<ol>
<li>java.lang：其下的类不需要显示import，包括object类，数据类型相关类（Integer等），Class类，线程相关类Thread，异常类Throable。</li>
<li>java.io：I/O操作相关的类，包括文件File，FileReader，FileWriter，输入输出流InputStream/OutputStream等。</li>
<li>java.net：网络相关类，HTTP链接类HttpURLConnecion,socket类等。</li>
<li>java.util：数据结构相关的类ArrayList、Hashmap，日期类Date，随机数类Random类等。</li>
</ol>
</li>
<li>/jre/lib/ext Java平台的扩展程序(插件等)的默认安装目录。</li>
<li>/jre/lib/security 包含用于安全管理的文件。这些措施包括安全策略（java.policy）和安全性（java.security）文件。</li>
<li>db Java实现的数据库</li>
</ul>
<p>JDK包含了java程序的运行环境和开发工具。借助java开发工具中的编译器javac.exe，我们可以把.java文件编译为在任何平台上都一样的.class文件。jre（包含jvm，java运行时类库和动态链接库（.dll）等信息）为java的执行提供了运行环境，可以加载javac.exe编译后的.class文件，并把其转化为对应平台上的机器码，由此可见在不同的平台上jvm的实现是不一样的。</p>
<h2 id="I-O体系架构"><a href="#I-O体系架构" class="headerlink" title="I/O体系架构"></a>I/O体系架构</h2><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul>
<li><strong>按方向：输入流（Reader和InputStream）和输出流（Writer和OutputStream）</strong>。输入输出是对程序运行的内存来说的，程序运行的部分始终处于内存中。</li>
<li><strong>按操作单元：字符流(Writer和Reader)和字节流（OutputStream和InputStream）</strong>。字符流操作的单元是两个字节（16bit）,字节流操作的单位是一个字节（8bit）。由此可知java的字符的长度为两个字节。</li>
<li><strong>按角色划分：节点流和处理流。</strong>可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流。节点流也被称为低级流。当使用节点流进行输入输出的时候，程序直接连接到实际的数据源，和实际的输入/输出节点进行连接。处理流则用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能。处理流也被称为高级流。当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入和输出节点连接。使用处理流的一个明显的好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装的节点流的变化，程序实际所访问的数据源也相应的发生变化。处理流最终必须“套接”在节点流上才能完成输入输出。<br><img src="http://img.blog.csdn.net/20160505135650158" alt=""><h2 id="流的原理"><a href="#流的原理" class="headerlink" title="流的原理"></a>流的原理</h2>所有的输入流都是基于InputStream和Reader的；所有的输出流都是基于OutputStream和Writer的。</li>
</ul>
<p>输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或者Reader里面取出一个或者多个“水滴”后，记录指针自定向后移动；除此之外，InputStream和Reader里面都提供了一些方法来控制记录指针的移动。</p>
<p>同样，当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐示指针来标识当前水滴即将放入的位置，每当程序向OutputStream或者Writer里面输出一个或者多个水滴后，记录指针自动向后移动。</p>
<p><strong><em>注意的一点是字符流与字节流的指针的移动步长不一致。</em></strong></p>
<p>处理流可以“嫁接”在任何已存在的流（可以节点流，也可以是处理流）的基础之上，这就允许Java应用程序采用相同的代码，透明的方式来访问不同的输入和输出设备的数据流。</p>
<p><strong><em>处理流使用了装饰模式进行设计。</em></strong></p>
<h2 id="流的使用总结"><a href="#流的使用总结" class="headerlink" title="流的使用总结"></a>流的使用总结</h2><ul>
<li>如果是操作二进制文件那我们就使用字节流，如果操作的是文本文件那我们就使用字符流。</li>
<li>尽可能的多使用处理流，这会使我们的代码更加灵活，复用性更好。</li>
</ul>
<h2 id="NIO体系架构"><a href="#NIO体系架构" class="headerlink" title="NIO体系架构"></a>NIO体系架构</h2><p>三个核心模块：</p>
<ul>
<li>Selector</li>
<li>Channel</li>
<li>Buffer</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector帮助开发者突破IO的瓶颈，它提供了单线程处理多个 Channel的机制。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。<br>要使用Selector，得先向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等.</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel是一个对象，可以通过它读取和写入数据，所有的IO在NIO中都从一个Channel 开始。Channel中的数据要么写入Buffer，要么从Buffer读取。通道与流的不同之处在于通道是双向的，而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道可以用于读、写或者同时用于读写。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。Buffer其实就是一块缓存区，内部使用字节数组存储数据，并维护几个特殊变量，实现数据的反复利用。一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。尽管缓冲区作用于它们存储的原始数据类型,但缓冲区十分倾向于处理字节。非字节缓冲区可以在后台执行从字节或到字节的转换,这取决于缓冲区是如何创建的。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ed571e5b8793cae275479b761393a6f0" alt=""></p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0fc724bf520f4db008a73c597e7eadef" alt=""></p>
<h2 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h2><ol>
<li>Java IO的各种流是阻塞的；ava NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞的写也是如此。</li>
<li>流失单向的；通道（Channel）是双向的。</li>
<li>IO是面向流；NIO面向缓冲；</li>
<li>IO无选择器；NIO有选择器；</li>
<li>如果一个连接的数据量比较大使用基于IO的服务器，如果连接很多，且每个连接需要传输的数据量不大，可以使用基于NIO的服务器。</li>
</ol>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h3><ul>
<li>Collection Collection体系中的集合存储的是元素本身，只是每个实现的存储方式不一样。</li>
<li>Map Map体系中存储的是键值对。</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/916361/201603/916361-20160322135512683-168468369.jpg" alt=""></p>
<ol>
<li>List、Set和Queue等属于Collection接口，其中定义了List、Set和Queue的基本方法增删改查。</li>
<li>ArrayList是List的一个实现，底层是有数组实现的，其中元素可以重复。</li>
<li>HashSet是Set的一个实现，元素无序，并且不能重复。</li>
<li>Map提供一种映射关系，元素以键值对的形式存在，能根据键快速查询到值。Map中的键值对以Entry类型的对象实例存在。key值不能重复，value可以重复，即键值的关系是多对一。</li>
<li>HashMap是Map的一个实现，是基于hash表实现的，HashMap中的Entry对象是无序的，key和value都可以是null,但是key只能有一个是null（因为键不能重复）。</li>
</ol>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>特点：</p>
<ol>
<li>元素是有序的，可以使用索引访问指定的元素。</li>
<li>其中的元素不能重复。</li>
<li>除了iterator()方法外，List还提供了一个专有的方法listIterator(),用于返回一个ListIterator接口，和Iterator接口相比，能向前或向后遍历。</li>
</ol>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol>
<li>实现了List和queue接口。</li>
<li>允许有null值</li>
<li>扩充了一些方法，可以用来模拟堆栈（stack）,队列（queue），双向队列（deque）。</li>
<li>LinkedList没有同步方法，所有<strong>不是线程安全</strong>的。如果多个线程同时访问这个List，需要自己进行同步控制。一种解决办法：Listlist=Collections.synchronizedList(newLinkedList(…));这个时候的List就是同步的了。</li>
</ol>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li>底层实现是数组，大小可动态扩展</li>
<li>操作的方法没有进行同步控制，所以<strong>不是线程安全</strong>，并发操作时需要手动确保同步。</li>
<li>CopyOnWriteArrayList提供了线程安全的ArrayList。不过其add方法的同步是通过创建数组副本来实现的，效率较低。</li>
</ol>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol>
<li>Vector非常类似ArrayList，但是Vector<strong>是线程安全的</strong>。</li>
<li>效率较低，很少使用了。</li>
<li>java.util 包中的集合类都返回 fail-fast迭代器，这意味着它们假设线程在集合内容中进行迭代时，集合不会更改它的内容。如果 fail-fast迭代器检测到在迭代过程中进行了更改操作，那么它会抛出 ConcurrentModificationException</li>
</ol>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ol>
<li>父类是Vector。</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li>具有与Collection完全一样的接口。</li>
<li>Set不保存重复元素。</li>
<li>加入Set的元素都必须定义equals()方法以确保对象的唯一性。</li>
<li>其中的元素无序。</li>
</ol>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ol>
<li>元素不重复</li>
<li>元素无序</li>
<li>允许至多一个null元素</li>
<li><strong>不是线程安全的</strong></li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ol>
<li>可以实现排序，元素添加到集合中的时候会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素组成按照“升序”排列。</li>
<li>检索效率比ArrayList高，ArrayList是O(n),TreeSet是log(n)</li>
<li>TreeSet要维护父子节点之间的关系，所以其占有的资源相对较多。</li>
<li>数据插入的速度也较ArrayList块。</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ol>
<li>具有Link和HashSet的特点。查询按HashSet来，速度快；还能保证数据插入的顺序，这个是因为数据使用Link链表进行存储的。</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li>四个实现类：HashMap Hashtable LinkedHashMap 和TreeMap。</li>
<li>存储键值对，键不可以重复，值可以重复。</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol>
<li>根据键的hashcode存储数据。</li>
<li>根据键可以和快查询到其值。</li>
<li>HashMap<strong>不是线程安全的，</strong>其中的操作方法并没有并发控制。</li>
<li>如果需要其同步可以使用Collections的synchronizedMap方法。</li>
<li>键和值可以是null，但只允许一个键是null</li>
<li>每一个键值对存在在一个Entry对象中，而Entry对象又是存储在一个Set中，Set中不能有重复元素，即是要Entry对象不重复，而Entry对中的键就可以保证Entry对象不重复。</li>
</ol>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ol>
<li>根据键的hashcode存储数据</li>
<li>根据键可以快速查询到其值</li>
<li><strong>是线程安全的，</strong>因此写入效率较低。</li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ol>
<li>保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历 的时候会比HashMap慢。</li>
<li><strong>不是线程安全的。</strong></li>
</ol>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol>
<li>保存的记录根据键进行排序，默认按升序，可以指定排序的比较器。</li>
<li>当用Iterator 遍历TreeMap时，得到的记录是排过序的。</li>
<li><strong>不是线程安全的</strong>。</li>
</ol>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections是针对集合类的一个帮助类。提供了一系列静态方法实现对各种集合的搜索、排序、线程完全化等操作。<br>相当于对Array进行类似操作的类——Arrays。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>容器类只是持有对象的一份引用，所以一旦将对象放入容器中，就失去了对象的类型信息。</li>
<li>在所有的Set中，TreeSet的效率是最低，但是其中的元素是排序的。</li>
<li>LinkedList可以用来模拟stack、queue等。</li>
<li>Set和Collection有一模一样的接口。</li>
<li>哈希码就是将对象的信息经过一些转变形成一个独一无二的int值，这个值存储在一个array中。我们都知道所有存储结构中，array查找速度是最快的。所以，可以加速查找。</li>
<li>线程安全的集合：Vector 、HashTable，线程安全了也导致其效率变低了。</li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>创建线程的三种方式：</p>
<ol>
<li>继承Thread</li>
<li>实现Runable</li>
<li>实现Callable，使用Future对象接收Callable的call方法返回的值或抛出的异常，并把Future对象给Thread对象启动线程。</li>
</ol>
<p>启动线程的两种方式：</p>
<ol>
<li>使用线程池启动线程。</li>
<li>使用Thread对象的start()方法</li>
</ol>
<p>注意：run或call方法不能直接调用，而是线程内部自己处理的，调用了OS的线程启动方法。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Executors工具可以创建普通的线程池以及schedule调度任务的调度池，其实两者实现上还是有一些区别，但是理解了ThreadPoolExecutor，在看ScheduledThreadPoolExecutor就非常轻松了。</p>
<h2 id="语言本身"><a href="#语言本身" class="headerlink" title="语言本身"></a>语言本身</h2><p>创建java对象的几种方式：</p>
<ul>
<li>使用new关键字，可以调用有任意个参数的的构造函数。</li>
<li>使用Class对象的newInstance()方法，只能调用无参构造函数。</li>
<li><p>使用类的构造器，通过构造器的newInstance()方法创建类的对象，实际上Class的 newInstance()方法就是调用Constructor的newInstance()。</p>
<pre><code>Constructor&lt;ClassTest&gt; constructor = ClassTest.class.getConstructor();
Object object2 = constructor.newInstance();
</code></pre></li>
<li><p>使用Clone的方式，无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将调用clone方法的对象的内容全部考备进去，使用clone方法创建对象并不会调用构造函数，要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。</p>
<pre><code>Student stu = new Student();
Student stu1 = (Student)stu.clone();
</code></pre></li>
<li><p>使用反序列化，在反序列化时，JVM创建对象并不会调用任何构造函数。</p>
<pre><code>ObjectInputStream in = new ObjectInputStream (new FileInputStream(&quot;data.obj&quot;)); Student stu3 = (Student)in.readObject();
</code></pre><p>注意：<strong>Class类的newInstance需要其构造方法是共有的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。</strong></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;JDK目录结构&quot;&gt;&lt;a href=&quot;#JDK目录结构&quot; class=&quot;headerlink&quot; title=&quot;JDK目录结构&quot;&gt;&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://yoursite.com/2018/02/09/MySQL/"/>
    <id>http://yoursite.com/2018/02/09/MySQL/</id>
    <published>2018-02-09T11:11:00.000Z</published>
    <updated>2018-03-11T08:45:11.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><pre><code>-- ALTER 增加索引
ALTER table user_t add index first_index(id);

ALTER table user_t add UNIQUE second_index(id)

ALTER TABLE user_t ADD PRIMARY KEY(id);

-- create方式增加索引
CREATE INDEX create_first_index on user_t (user_name);

create UNIQUE INDEX create_second_index on user_t (password,user_name,id);
</code></pre><p>在主键上创建索引不用给定名称，因为主键对于一张表来说是唯一的。</p>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><pre><code>-- 删除索引
DROP INDEX first_index on user_t;
ALTER TABLE user_t DROP INDEX first_index;
ALTER TABLE user_t drop PRIMARY KEY;
</code></pre><p>删除 primary key不用指定名称，因为一张表上只可能有一个 primary key索引。执行第三条语句的时候，如果表上没有创建primary key索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除了某列，会对索引有影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ol>
<li>索引不包含重复值，则索引应该创建为 primary Key或Unique。对于单列唯一性约束来说，保证单列不包含重复值，对于多列唯一性索引，多列的值的组合不重复。PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引</li>
</ol>
<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><pre><code>show index from user_t;
</code></pre><p>结果：</p>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foaffzkkpfj21aa09b0u8.jpg" alt=""></center>


<ul>
<li>Table 表的名称。</li>
<li>Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。</li>
<li>Key_name 索引的名称。</li>
<li>Seq_in_index 索引中的列序列号，从1开始。</li>
<li>Column_name 列名称。</li>
<li>Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。</li>
<li>Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。</li>
<li>Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</li>
<li>Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。</li>
<li>Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。</li>
<li>Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</li>
<li>Comment</li>
</ul>
<h2 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h2><ol>
<li>BTREE, </li>
<li>FULLTEXT, </li>
<li>HASH, </li>
<li>RTREE</li>
</ol>
<h2 id="MySQL的索引的原理"><a href="#MySQL的索引的原理" class="headerlink" title="MySQL的索引的原理"></a>MySQL的索引的原理</h2><h3 id="索引数据结构B-Tree-和-B-Tree"><a href="#索引数据结构B-Tree-和-B-Tree" class="headerlink" title="索引数据结构B-Tree 和 B+Tree"></a>索引数据结构B-Tree 和 B+Tree</h3><p>MySQL使用的是B+Tree作为索引的数据结构。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。应该尽量减少磁盘I/O次数。</p>
<ol>
<li><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
</li>
<li><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
</li>
</ol>
<p>B+Tree:</p>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foah7rvrxmj20f6089gli.jpg" alt="B+Tree"></center>

<p>B-Tree:</p>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foahaxvy5oj20m406kjrc.jpg" alt="B-Tree"></center>

<p>比较B-Tree和B+Tree,B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<pre><code>dmax=floor(pagesize/(keysize+datasize+pointsize))
</code></pre><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<h2 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。</p>
<h3 id="MyISAM-索引"><a href="#MyISAM-索引" class="headerlink" title="MyISAM 索引"></a>MyISAM 索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/8.png" alt="主索引"></center>

<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/9.png" alt="辅助索引"></center>

<p>主索引与辅助索引在结构上没有什么区别。主索引要求key是唯一的，而辅助索引的key可以重复。</p>
<h3 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<ol>
<li>第一个重大区别是InnoDB的数据文件本身就是索引文件。 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</li>
</ol>
<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/10.png" alt="主索引"></center>

<p>可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。<strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键</strong>（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<ol>
<li>第二个与MyISAM索引的不同是InnoDB的辅助索引<strong>data域存储相应记录主键的值</strong>而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</li>
</ol>
<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/11.png" alt="辅助索引"></center>

<p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。所以一般来说INNODB的索引都是创建在主键上。</p>
<p>根据INNODB的特征，不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</p>
<h2 id="索引的使用策略"><a href="#索引的使用策略" class="headerlink" title="索引的使用策略"></a>索引的使用策略</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<ol>
<li>表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引。</li>
<li>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值： Index Selectivity = Cardinality / #T。显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。</li>
</ol>
<p>查询中只有用到条件，索引才会起作用。而且索引列要起作用还必须是查询的条件之一。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。</p>
<p>在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的索引 O(log(N)) 运算来更新表的索引。</p>
<h2 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h2><p>MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1, a2,="" …,="" an="">，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为1的特例。如果在进行精确匹配的时候，使用的是隔断精确匹配，则只有最前面的连续的几个字段的索引会陪用到。</a1,></p>
<p>什么时候索引会被用到？</p>
<ol>
<li>当按照索引中所有列进行精确匹配时，索引可以被用到。这里的所谓精确匹配是指使用‘=’和‘IN’进行匹配。</li>
<li>当查询条件精确匹配索引的左边连续一个或几个列时,索引可以被用到,但是只能用到一部分，即条件所组成的最左前缀。如果使用索引中的列不连续，只会用到最左边连续的几个。后面的索引因为隔断将不会被使用。</li>
<li>如果查询条件没有指定索引第一列，这样的查询就会用不到索引。</li>
<li>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。这里的范围就是’&lt;’,’&gt;’等条件。索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</li>
<li>如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引。</li>
</ol>
<p><strong>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</strong></p>
<h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><ol>
<li><p>为什么数据库的索引使用的B+树的数据结构，而不使用hash表？尽管hash的搜索的最好情况是O(1)。</p>
<p> 答：</p>
<ul>
<li>Hash不能使用范围查询，只能用于“=”，“in”，“&lt;=&gt;”(等价)等查询</li>
<li>联合索引中，Hash索引不能利用部分索引键查询。并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。 </li>
<li>Hash索引无法避免数据的排序操作。由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。</li>
<li>Hash索引任何时候都不能避免表扫描。Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。 </li>
<li>Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高 </li>
</ul>
</li>
<li><p>怎么知道mysql使用的索引的数据结构是是B+Tree 而不是Hash Table？</p>
<p> 答：如果一个数据库中使用的索引过多会导致数据库的insert和delete操作速度比较慢，因为B+Tree是一棵自平衡树，在插入和删除记录的时候会不断的在调整树的结构，导致操作比较慢。</p>
</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>不是所有的数据库引擎都支持事务，MySQL支持事务的引擎有InnoDB,但MyISAM不支持事务。</p>
<h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><ol>
<li>事务不支持嵌套功能，当用户在未结束第一个事务又重新打开一个事务，则前一个事务会自动提交。</li>
<li>事务的性质：“ACID”原则即原子性（A）、稳定性（C）、隔离性（I）和持久性（D）。<ul>
<li>原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。 </li>
<li>稳定性：数据库在事务执行前后状态都必须是稳定的。 </li>
<li>隔离性：事务之间不会相互影响。 </li>
<li>持久性：事务执行成功后必须全部写入磁盘。</li>
</ul>
</li>
</ol>
<h2 id="事务的问题"><a href="#事务的问题" class="headerlink" title="事务的问题"></a>事务的问题</h2><p>数据库事务会导致脏读、不可重复读和幻影读等问题。</p>
<ol>
<li>脏读：事务还没提交，他的修改已经被其他事务看到。 </li>
<li>不可重复读：同一事务中两个相同SQL读取的内容可能不同。两次读取之间其他事务提交了修改可能会造成读取数据不一致。 </li>
<li>幻读：同一个事务突然发现他以前没发现的数据，两次读取数据之间其他事务提交了新的数据。</li>
</ol>
<p>为了解决以上问题，INNODB引入了四种不同的机制保证数据的隔离性。事务的四种隔离级别：</p>
<ol>
<li>READ UNCOMMIT（读未提交），允许某个事务看到其他事务并没有提交的数据。可能会导致脏读、不可重复读、幻影数据。这种隔离级别不会采用任何锁。</li>
<li>READ COMMIT（读已提交），允许某个事务看到其他事务已经提交的数据。可能会导致不可重复读和幻读。这种隔离级别，数据的读是不加锁的，但是数据的写入、修改、删除加锁，避免了脏读。</li>
<li>REPEATABLE READ（可重复读），同一个事务的两次相同读取肯定是一样的（对行来说），其他事务的提交的insert和delete可能会对本次事务有影响。这种级别的隔离，数据的读、写都会加锁（行级锁），当前事务如果占据了锁，其他事务必须等待本次事务提交完成释放锁后才能对相同的<strong>数据行</strong>进行操作。这种级别的隔离会导致幻读。</li>
<li>SERIALIZABLE（序列化），这种级别的隔离是在表上加锁，锁粒度比较到，可以完美的避免脏读、不可重复读和幻读，但是由于锁级别是在表上，影响数据库的效率。</li>
</ol>
<p><strong><em>注意：幻读出现的情况应该是针对插入（insert）和删除(delete)。可重复读对应的是更新（update）。</em></strong></p>
<h2 id="原子性、稳定性和持久性实现原理"><a href="#原子性、稳定性和持久性实现原理" class="headerlink" title="原子性、稳定性和持久性实现原理"></a>原子性、稳定性和持久性实现原理</h2><p>原子性、稳定性和持久性是通过redo 和 undo 日志文件实现的，不管是redo还是undo文件都会有一个缓存我们称之为redo_buf和undo_buf。同样，数据库文件也会有缓存称之为data_buf。</p>
<h3 id="undo-日志文件"><a href="#undo-日志文件" class="headerlink" title="undo 日志文件"></a>undo 日志文件</h3><p><center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fob9zgu8xij208w0i3glj.jpg" alt="undo日志文件保证原子性、稳定性和持久性的原理图"></center><br>说明：</p>
<ol>
<li>如果事务在F之前崩溃由于数据还没写入磁盘，所以数据不会被破坏。 </li>
<li>如果事务在G之前崩溃或者回滚则可以根据undo恢复到初始状态。</li>
<li>数据在任务提交之前写到磁盘保证了持久性。但是单纯使用undo保证原子性和持久性需要在事务提交之前将数据写到磁盘，浪费大量I/O。</li>
</ol>
<h3 id="redo-undo-日志文件"><a href="#redo-undo-日志文件" class="headerlink" title="redo/undo 日志文件"></a>redo/undo 日志文件</h3><p><center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobaafvyt4j20ag0m93yj.jpg" alt="undo/redo日志文件保证原子性、稳定性和持久性的原理图"></center><br>说明：</p>
<ol>
<li>通过undo保证事务的原子性，redo保证持久性。</li>
<li>F之前崩溃由于所有数据都在内存，恢复后重新冲磁盘载入之前的数据，数据没有被破坏。 </li>
<li>FG之间的崩溃可以使用redo来恢复。 </li>
<li>G之前的回滚都可以使用undo来完成。</li>
</ol>
<h2 id="模拟不同的事务级别对数据安全的影响"><a href="#模拟不同的事务级别对数据安全的影响" class="headerlink" title="模拟不同的事务级别对数据安全的影响"></a>模拟不同的事务级别对数据安全的影响</h2><p>实验准备：</p>
<ol>
<li>安装mysql数据库</li>
<li>打开两个mysql命令行客户端，模拟多用户多事务场景。</li>
<li>导入官方推荐的数据库 employees。<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="测试read-uncommitted-级别"><a href="#测试read-uncommitted-级别" class="headerlink" title="测试read uncommitted 级别"></a>测试read uncommitted 级别</h3></li>
<li><p>查看当前的数据库隔离级别</p>
<pre><code>mysql&gt; select @@tx_isolation;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcqcxqidj20a3051dfo.jpg" alt="查看数据库的当前的隔离级别"></p>
</li>
<li><p>在A客户端（打开的mysql命令行客户端），设置当前会话的事务隔离级别为 read uncommitted</p>
<pre><code>set session transaction isolation level read uncommitted；
start transaction;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcr48xktj20hy0d2jrn.jpg" alt=""></p>
</li>
<li><p>在B客户端（打开的另一个mysql命令行客户端），设置当前会话的事务隔离级别为 read uncommitted，并更新数据。</p>
<pre><code>set session transaction isolation level read uncommitted;
start transaction;
update salaries set salary=salary+100 where emp_no = 100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcrinkm2j20ix06raa2.jpg" alt=""></p>
</li>
<li><p>在A中再次执行相同的查询数据</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcrsldjtj20eo09c0sq.jpg" alt=""></p>
</li>
</ol>
<p>结论：一个事务没有提交，但是在另外的事务中却可以查看到这个事务没有提交的数据。这是所有隔离级别中最低级的一种。<br>导致的问题：可以读取到事务未提交的数据，俗称<strong>脏读</strong></p>
<h3 id="read-committed-级别"><a href="#read-committed-级别" class="headerlink" title="read committed 级别"></a>read committed 级别</h3><ol>
<li><p>查询B客户端的当前会话的事务的级别</p>
<pre><code>select @@tx_isolation;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdrdhmn2j20b704jdfo.jpg" alt=""></p>
</li>
<li><p>将B客户端的当前会话的事务级别设置为read committed，查询当前的数据。</p>
<pre><code>set session transaction isolation level read committed;
start transaction;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdu7zrmvj20f00baaa4.jpg" alt=""></p>
</li>
<li><p>在A客户端的会话中启动事务，对数据进行修改</p>
<pre><code>start transaction;
select * from salaries where emp_no=100000;
update salaries set salary=salary-200 where emp_no=100000;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdulbvghj20k50qadgo.jpg" alt=""></p>
</li>
<li><p>在B客户端的会话中查询</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobduz0fusj20fn09wwel.jpg" alt=""></p>
</li>
<li><p>提交A客户端中会话的事务</p>
<pre><code>commit
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdyqktp6j20fr0cvmxc.jpg" alt=""></p>
</li>
<li><p>在B客户端会话中查看数据</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdyqktp6j20fr0cvmxc.jpg" alt=""></p>
</li>
</ol>
<p>结论：可见在A中修改的数据，在A中的事务被提交前，在B中是看不见的。一旦A提交，B中再次查询就可以看见了。如果当前会话的隔离级别是 read committed的，当前会话只能读取到其他事务提交的数据，未提交的数据是读不到的。<br>导致的问题：两次读取的结果不同，导致了<strong>不可重复读</strong>。</p>
<h3 id="Repeatable-read级别"><a href="#Repeatable-read级别" class="headerlink" title="Repeatable read级别"></a>Repeatable read级别</h3><p>这个是MySQL的默认事务级别。</p>
<ol>
<li><p>查询B客户端的当前会话的事务的级别</p>
<pre><code>select @@tx_isolation;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobep7am6xj20az05qjr8.jpg" alt=""></p>
</li>
<li><p>设置B客户端中的会话的隔离级别为repeatable read(可重复读，保证了两次读取的数据一致)。</p>
<pre><code>set session transaction isolation level repeatable read;
start transaction;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobepmfqibj20i00dx3ys.jpg" alt=""></p>
</li>
<li><p>在客户端A中的会话中启动一个事务,在事务里执行添加一条记录,并提交该事务。</p>
<pre><code>start transaction;
insert into salaries (emp_no,salary,from_date,to_date) value(100000,21232323,&apos;2017-06-29&apos;,&apos;2018-07-01&apos;);
select * from salaries where emp_no=100000;
commit;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobfphq7lxj20vc0efaah.jpg" alt=""></p>
</li>
<li><p>在客户端B的会话中查询数据，</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobfq8jd5mj20i50azdfz.jpg" alt=""></p>
</li>
<li><p>在客户端B的会话中插入一条与第三步插入的记录的<code>emp_no</code>和<code>from_date</code>都相同的数据</p>
<pre><code>insert into salaries (emp_no,salary,from_date,to_date) value(100000,1000000,&apos;2017-06-29&apos;,&apos;2020-07-01&apos;);
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobfqkg9znj20vg02iwed.jpg" alt=""></p>
</li>
<li><p>在客户端B的会话中查询数据，</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foberfvn12j20f209imx6.jpg" alt=""></p>
</li>
</ol>
<p>结论：会话使用事务的级别为repeatable read，保证了在事务提交前的每次查询数据都是一样的，避免了不可重复读的问题，<br>导致的问题：从上述的实验中不难看出问题，就是在第五步出现的该问题，明明在当前会话中查询的数据没有与要提交的的数据冲突，可是在插入的时候却提示已经有该主键的数据记录了。看不见记录，却提示已存在该记录，这种情况称为<strong>幻读</strong>。</p>
<h3 id="serializable级别"><a href="#serializable级别" class="headerlink" title="serializable级别"></a>serializable级别</h3><p>serializable级别是隔离级别最高的，是最安全的，但也是最耗资源的。</p>
<ol>
<li><p>查询B客户端的当前会话的事务的级别</p>
<pre><code>select @@tx_isolation;
</code></pre></li>
<li><p>设置B客户端会话的事务级别为 serializable</p>
<pre><code>set session transaction isolation level serializable;
-- 启动事务
start transaction;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgq6qmduj20i903hjr9.jpg" alt=""></p>
</li>
<li><p>在B客户端的会话中查询数据</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgqunr43j20f00b8q2z.jpg" alt=""></p>
</li>
<li><p>在A客户端会话中启动事务，查询数据，并插入一条数据。</p>
<pre><code>start transaction
select * from salaries where emp_no=100000;
insert into salaries (emp_no,salary,from_date,to_date) value(100000,2000000,&apos;2015-06-29&apos;,&apos;2020-07-01&apos;);
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgqunr43j20f00b8q2z.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgrek0cnj20uz031wed.jpg" alt=""></p>
<p> 可以看到插入数据并没有成功，尽管库中并没有相同主键的记录。</p>
</li>
<li><p>在A客户端插入数据的时候，同时在B客户端提交事务。</p>
<pre><code>-- 客户端A
insert into salaries (emp_no,salary,from_date,to_date) value(100000,2000000,&apos;2015-06-29&apos;,&apos;2020-07-01&apos;);

-- 客户端B
commit
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgx2jlpbj20v508e74c.jpg" alt=""></p>
</li>
</ol>
<p>由上面的结果看，A中的insert语句在等待执行期间，如果B客户端的事务执行了commit，那么A中的insert就会执成功，否则就会超时。</p>
<h1 id="自问自答-1"><a href="#自问自答-1" class="headerlink" title="自问自答"></a>自问自答</h1><ol>
<li><p>什么时候更能体现出索引查询的优势？</p>
<pre><code>答：因为索引是基于B+tree的，因此查询到一条记录的时间复杂度是O(logN),所以查询的记录越多，更能体现出索引的优势，在数据量不大的情况下，通过索引查询与不通过索引查询的时间相差不多。
</code></pre></li>
<li><p>数据库索引的工作原理是？</p>
<pre><code>答：把添加索引的列在内存中创建一棵以索引列的值为key的B+tree。
</code></pre></li>
<li><p>为什么说索引不是越多越好？</p>
<pre><code>答：数据维护索引需要消耗资源，因为索引的数据结构是B+树，在插入/删除数据的时候都需要调整树的平衡，调整树的平衡是需要耗时的，还有可能涉及到磁盘等的操作。这就减慢了插入/删除操作的速度。
</code></pre></li>
<li><p>阵列与hash表的区别</p>
<pre><code>答：搜索的复杂度不同，阵列是O(n),hash表是O(1)。阵列需要一次性加载到内存中，有时候这显得有点不现实。hash可以分不同的&quot;桶&quot;加载到内存中。
</code></pre></li>
<li></li>
</ol>
<h1 id="数据设计原则"><a href="#数据设计原则" class="headerlink" title="数据设计原则"></a>数据设计原则</h1><p>三范式：</p>
<ol>
<li>第一范式（1NF）：属性必须是原子性的约束，要求属性具有原子性，即属性不能再分解。</li>
<li>第二范式（2NF）：对记录唯一性的约束，要求记录有唯一的标识，即实体的唯一性。</li>
<li>第三范式（3NF）：对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ol>
<p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降 低范式。</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>PK是供程序员使用的表间连接工具，可以是一无物理意义的数字串, 由程序自动加1来实现。也可以是有物理意义的字段名或字段名的组合。不过前者比后者好。当PK是字段名的组合时，建议字段的个数不要太多，多了不但索引占用空间大，而且速度也慢。</p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>隔离了真实数据和操作人员，保证了数据的安全性。</p>
<h2 id="提高数据库运行效率的方法"><a href="#提高数据库运行效率的方法" class="headerlink" title="提高数据库运行效率的方法"></a>提高数据库运行效率的方法</h2><ol>
<li>在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。</li>
<li>当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。 </li>
<li>发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，以该表主键PK的某个值为界线，将该表的记录水平分割为两个表（即可以表维护 表行数过大 手动分割为两个  建个两表union的视图对程序透明）。若发现某个表的字段太多，例如超过八十个，则垂直分割该表，将原来的一个表分解为两个表。</li>
<li>对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。</li>
<li>在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。总之，要提高数据库的运行效率，<strong>必须从数据库系统级优化、数据库设计级优化、程序实现级优化，</strong>这三个层次上同时下功夫。</li>
</ol>
<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><ul>
<li><p>分表</p>
<ol>
<li>水平分表：解决的是记录过多，如果进联表（union）等操作，导致要进行不断的IO，另外数据过多比较的目标数就会过多，浪费比较的时间，如果进行分表，如果一开始就能定位所需要的数据在哪张子表就会减少IO操作，也减少了比较的次数。</li>
<li>垂直分表：解决的数据记录并不多，但是属性过多，导致检索的时候会进行过多的IO操作。垂直分表的原则是把大字段分到单独表中，同时必须保证该表与原表是一对一的关系（即使用主外键关联）。</li>
</ol>
</li>
<li><p>其他</p>
<ol>
<li>存放图片、文件等大文件用文件系统存储。数据库只存储路径，图片和文件存放在文件系统，甚至单独存放在一台服务器(图床)。</li>
<li><p>数据参数的配置。最重要的参数就是内存，我们主要用的innodb引擎，所以下面两个参数调的很大：</p>
<pre><code>innodb_additional_mem_pool_size=64M
innodb_buffer_pool_size=1G
</code></pre></li>
<li>合理的硬件资源和操作系统。如果机器的内存超过4G，那么应当采用64位操作系统和64位MySQL。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;创建索引&quot;&gt;&lt;a href=&quot;#创建索引&quot; class=&quot;headerlink&quot; title=&quot;创建索引&quot;&gt;&lt;/a&gt;创建索引&lt;/h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://yoursite.com/2018/02/01/Spring/"/>
    <id>http://yoursite.com/2018/02/01/Spring/</id>
    <published>2018-02-01T13:19:17.000Z</published>
    <updated>2018-03-25T08:29:41.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ol>
<li>BeanFactory</li>
<li>ApplicationContext</li>
<li>BeanDefinition</li>
<li>Resource</li>
</ol>
<h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><ol>
<li>Bean定义资源的定位</li>
<li>Bean定义资源的载入</li>
<li>Bean定义资源的解析  </li>
</ol>
<h2 id="IoC容器初始化的基本步骤"><a href="#IoC容器初始化的基本步骤" class="headerlink" title="IoC容器初始化的基本步骤"></a>IoC容器初始化的基本步骤</h2><ol>
<li>初始化的入口是通过调用容器中的refresh()方法实现的</li>
<li>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition，其大致过程：<blockquote>
<p>通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。</p>
<p>如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的。</p>
<p>容器通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition  这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现</p>
<p>注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.</p>
</blockquote>
</li>
</ol>
<ol>
<li>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方</li>
</ol>
<h2 id="Beanfactory-和-Factory-Bean"><a href="#Beanfactory-和-Factory-Bean" class="headerlink" title="Beanfactory  和 Factory Bean"></a>Beanfactory  和 Factory Bean</h2><ol>
<li>BeanFactory 指的是 IOC 容器的编程抽象,比如 ApplicationContext， XmlBeanFactory 等。</li>
<li>FactoryBean 只是一个可以在 IOC而容器中被管理的一个 bean,是对各种处理过程和资源使用的抽象,Factory bean 在需要时产生另一个对象，而不返回 FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了。</li>
</ol>
<h2 id="IoC容器的依赖注入"><a href="#IoC容器的依赖注入" class="headerlink" title="IoC容器的依赖注入"></a>IoC容器的依赖注入</h2><p>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入</p>
<h3 id="依赖注入发生的时机"><a href="#依赖注入发生的时机" class="headerlink" title="依赖注入发生的时机"></a>依赖注入发生的时机</h3><ol>
<li>用户第一次通过getBean方法向IoC容索要Bean时，IoC容器触发依赖注入。</li>
<li>当用户在Bean定义资源中为<bean>元素配置了lazy-init属性，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入</bean></li>
</ol>
<p>如果Bean定义的单态模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean定义还可以扩展为指定其生命周期范围。</p>
<p>一般来说依赖注入发生在向容器索取bean的时候，即调用各个getBean方法的时候；但当Bean定义资源的<bean>元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候就已经完成</bean></p>
<h2 id="IOC的高级应用"><a href="#IOC的高级应用" class="headerlink" title="IOC的高级应用"></a>IOC的高级应用</h2><p>Dereference(解引用)：一个在C/C++中应用比较多的术语，在C++中，”*”是解引用符号，而”&amp;”是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。</p>
<p>Spring IoC容器提供了两种管理Bean依赖关系的方式：</p>
<ol>
<li>显式管理：通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理。</li>
<li>autowiring：Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的Bean，从而自动地完成依赖注入。</li>
</ol>
<p>Spring IoC容器的autowiring属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。</p>
<h2 id="应用中启动应用Spring容器"><a href="#应用中启动应用Spring容器" class="headerlink" title="应用中启动应用Spring容器"></a>应用中启动应用Spring容器</h2><ul>
<li>把配置文件放到web.xml中，随应用程序被Tomcat等servlet容器加载的时候加载。</li>
<li><p>在code中手动加载，下面是一种加载方式：</p>
<pre><code>//启动上下文容器
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:./applicationContext.xml&quot;);
//获取配置文件中配置的实例对象，或者是通过注解注释的类的对象
EagerSingleton1 singleton1 = ctx.getBean(&quot;eagerSingleton1&quot;, EagerSingleton1.class);
</code></pre></li>
</ul>
<h3 id="Spring实例化bean方式"><a href="#Spring实例化bean方式" class="headerlink" title="Spring实例化bean方式"></a>Spring实例化bean方式</h3><ul>
<li><p>使用setter</p>
<pre><code>public class StudentHandler {
    public Student addName(String name) {
        Student student = new Student();
        student.setName(name);
        System.out.println(&quot;handler add name&quot;);
        return student;
    }
}

public class StudentServiceImpl implements IStudentService {
    private StudentHandler handler;

    @Override
    public String getSudentName() {
        Student student = handler.addName(&quot;fengyu&quot;);
        return student.getName();
    }

    public StudentHandler getHandler() {
        return handler;
    }
    //这个方法时必须的，不然注入不了实例化对象
    public void setHandler(StudentHandler handler) {
        this.handler = handler;
    }

}
</code></pre><p>  配置：</p>
<pre><code>&lt;!-- 使用setter方式实例化 --&gt;
&lt;bean id=&quot;handler&quot; class=&quot;com.daniel.study.spring.handler.StudentHandler&quot;&gt;
&lt;/bean&gt;
&lt;bean id=&quot;studentManager&quot; class=&quot;com.daniel.study.spring.service.impl.StudentServiceImpl&quot;&gt;
    &lt;property name=&quot;handler&quot; ref=&quot;handler&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>  测试：</p>
<pre><code>@Test
public void test() {
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:./applicationContext.xml&quot;);
    IStudentService studenManager = (IStudentService) ctx.getBean(&quot;studentManager&quot;);
    String stName = studenManager.getSudentName();
    System.out.println(stName);
}
</code></pre></li>
<li><p>使用构造器，上面的handler实例的定义就是通过构造器实现的，只不过没有参数而已。</p>
<p>  测试：</p>
<pre><code>@Test
public void test1() {
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:./applicationContext.xml&quot;);
    StudentHandler handler = ctx.getBean(&quot;handler&quot;, StudentHandler.class);
    Student student = handler.addName(&quot;fengyu&quot;);
    System.out.println(student.getName());
}
</code></pre></li>
<li><p>静态构造方法</p>
<pre><code>public class Student {
    private String name;
    private int age;

    private Book book;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Book getBook() {
        return book;
    }

    public void setBook(Book book) {
        this.book = book;
    }
    //静态工厂方法
    public static Student getStudentInstance() {
        return new Student();
    }
}
</code></pre><p>  配置：</p>
<pre><code>&lt;！-- lazy-init只有到了真正使用的时候才实例化 --&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.daniel.study.spring.entity.Student&quot; factory-method=&quot;getStudentInstance&quot; lazy-init=&quot;true&quot;&gt;&lt;/bean&gt; 
</code></pre><p>  测试：</p>
<pre><code>@Test
public void test() {
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:./applicationContext.xml&quot;);
    Student student = ctx.getBean(&quot;student&quot;, Student.class);
    System.out.println(student.getName());
}
</code></pre></li>
<li><p>实例化工厂方法</p>
<pre><code>//需要实例化的类
public class Book {
    private String name;
    private String publisher;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPublisher() {
        return publisher;
    }

    public void setPublisher(String publisher) {
        this.publisher = publisher;
    }

}

//需要实例化的工厂
public class BookFactory {
    public Book createBook() {
        return new Book();
    }
}
</code></pre><p>  配置：</p>
<pre><code>&lt;!-- 工厂实例化方法 --&gt;
&lt;bean id=&quot;bookFactory&quot; class=&quot;com.daniel.study.spring.factory.BookFactory&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;book&quot; factory-bean=&quot;bookFactory&quot; factory-method=&quot;createBook&quot; &gt;&lt;/bean&gt;
</code></pre><p>  测试：</p>
<pre><code>@Test
public void test() {
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:./applicationContext.xml&quot;);
    Book book = ctx.getBean(&quot;book&quot;, Book.class);
    System.out.println(book.getName());
}
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ioc&quot;&gt;&lt;a href=&quot;#Ioc&quot; class=&quot;headerlink&quot; title=&quot;Ioc&quot;&gt;&lt;/a&gt;Ioc&lt;/h1&gt;&lt;h2 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h2&gt;&lt;o
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://yoursite.com/2018/01/28/JVM/"/>
    <id>http://yoursite.com/2018/01/28/JVM/</id>
    <published>2018-01-28T01:09:55.000Z</published>
    <updated>2018-03-17T02:35:54.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h1><h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><ol>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>寄存器（程序计数器）</li>
<li>堆区</li>
<li>方法区</li>
</ol>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07ly1fnw6oozzasj20x80k13z0.jpg" alt="JVM内存模型"></center>

<h2 id="各个内存模块的作用"><a href="#各个内存模块的作用" class="headerlink" title="各个内存模块的作用"></a>各个内存模块的作用</h2><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ol>
<li>程序逻辑运行的区域，可固定，可扩展。如果固定，当其中的某个线程需要执行内存（在栈空间上），而恰好分配的栈区不足就会出现StackOverflowError异常（运行时异常）。如果可扩展，当其中的某个线程需要执行内存（在栈空间上，而恰好内存已经使用完，会出现OutofMemeryError。</li>
<li>每个线程在其中都开辟了一个栈空间，线程的栈空间为固定大小，其中存储有运行时的方法，本地变量，对象引用等。线程栈是线程独享。</li>
<li>本质上来说程序的运行时依赖于方法的，所以在运行某个方法的时候都会为该方法创建一个栈帧，栈帧的作用是用来存在这个方法的操作数栈，局部变量表，方法出口，动态链接等信息，并把这个栈帧压入响应的线程栈中。</li>
<li>线程栈运行时创建，栈帧运行时创建<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3></li>
<li>本地方法栈是在调用本地方法时本地方法运行的内存空间。严格来说这里结构不由JVM管理，只是由JVM调用。</li>
</ol>
<h3 id="寄存器（程序计数器）"><a href="#寄存器（程序计数器）" class="headerlink" title="寄存器（程序计数器）"></a>寄存器（程序计数器）</h3><ol>
<li>线程独占</li>
<li>用于记录程序当前执行到的位置（指令地址）</li>
<li>如果当前某个线程正在执行某个本地方法，则该线程对应的计数器中的值为空。</li>
</ol>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><ol>
<li>线程共享</li>
<li>启动即创建</li>
<li>存储数组和对象，数组也是对象</li>
<li>详细可以划分为，新生代，老年代等</li>
<li>是垃圾回收的主要场所。</li>
<li>GC算法就主要是针对堆区设计的。</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol>
<li>堆区的一个逻辑分区，本质上也是堆</li>
<li>线程共享</li>
<li>主要用于存储类的信息、常量池、方法数据、方法代码等</li>
<li>这个区也会发生垃圾回收，但是频率很低。</li>
</ol>
<p>注：方法区是java虚拟机的一个规范，至于怎么实现，有虚拟机开发者自行确定。</p>
<h4 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h4><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是<strong>方法区</strong>。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且<strong>只有 HotSpot 才有PermGen space</strong>，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出</p>
<p>注：<em>整个区在java8后就被移除了，即在java8后使用元空间来表示方法区，即元空间是方法区的另一种实现方式。</em></p>
<h4 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h4><p>java8后使用元空间替换了永久代（PermGen）来实现方法区。元空间与永久代的不同：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p>
<p>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<h3 id="每个内存区域出现异常的情形"><a href="#每个内存区域出现异常的情形" class="headerlink" title="每个内存区域出现异常的情形"></a>每个内存区域出现异常的情形</h3><center><img src="https://images2015.cnblogs.com/blog/539365/201511/539365-20151119105947202-10960285.png" alt=""></center>

<ol>
<li>堆或方法区的内存不够分配都会出现OutOfMemoryError。</li>
<li>栈区只有在多线程的情况下才会出现OutOfMemoryError，在单线程的情况下只会出现StackOverflowError。</li>
<li>栈区在多线程的情况下会出现StackOverflowError，这是因为某个线程使用的栈深度超过了JVM定义的深度。</li>
<li>程序计数器理论上回出现OutOfMemoryError，但实际情况下是不会出现的，除非线程栈的大小小于计数器。</li>
</ol>
<p>注意：以上所说的各个区并不是在物理上进行分割的，而是在逻辑上进行分割的。比如堆区就可以分配在整个内存区域的不连续的空间中。</p>
<h1 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h1><pre><code>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
</code></pre><p>-Xmx128m：设置JVM最大可用内存为128M。</p>
<p>-Xms128m：设置JVM最小内存为128m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<p>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p>
<p>-Xss128k：设置每个线程的堆栈大小。 JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更 多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<p>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p>
<p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p>-XX:MaxPermSize=16m：设置持久代大小为16m。</p>
<p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。<br> – Ratio 比率<br> – Eden 伊甸<br> – Survivor 幸存者</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>类的生命周期：</p>
<ol>
<li>加载</li>
<li>链接（验证+准备+解析）</li>
<li>初始化（使用前的准备）</li>
<li>使用</li>
<li>卸载</li>
</ol>
<p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定。这里的几个阶段是<strong>按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol>
<li>通过类的全限定名获取类的字节码文件，以字节流的方式加载入jvm中</li>
<li>将这个字节流所代表的静态存储结构转为方法区的运行时数据结构。</li>
<li>在推中生成一个代表这个类的Class对象。<strong>说明这个Class对象是在class加载阶段创建的。</strong></li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol>
<li>验证：确保被加载类的正确性； </li>
<li>准备：为类的静态变量分配内存，并将其初始化为默认值； </li>
<li>解析：把类中的符号引用转换为直接引用；</li>
</ol>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>时机：</p>
<ol>
<li>创建实例时</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法 </li>
<li>反射</li>
<li>初始化一个类的子类，如果该类没有初始化，就会被初始化</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类。</li>
</ol>
<p>初始化的顺序：</p>
<ol>
<li>如果这个类还没有被加载和链接，那先进行加载和链接。</li>
<li>假如这个类存在直接父类，并且这个类还没有被初始化，那就初始化直接的父类（不适用于接口） </li>
<li>加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。</li>
<li>总的来说，初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法。</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol>
<li>BootstrapClassLoader负责加载$JAVA_HOME$/jre/lib/rt.jar里的所有class，，加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar，C++实现。</li>
<li>ExtensionClassLoader负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。载System.getProperty(“java.ext.dirs”)所指定的路径或jar。父类加载器为null</li>
<li>AppClassLoader负责加载classpath中指定的jar包及目录中的class文件。</li>
<li>CustomClassLoader属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现</li>
</ol>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。</p>
<p>类加载的机制是使用双亲委派模型，这样做的好处是<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，</strong>当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>常见的GC算法：</p>
<ol>
<li>标记清除</li>
<li>复制算法</li>
<li>标记整理</li>
<li>分代收集：主要是对新生代来说的，分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。新生代一般选择的是复制算法。</li>
</ol>
<h3 id="java堆的逻辑划分"><a href="#java堆的逻辑划分" class="headerlink" title="java堆的逻辑划分"></a>java堆的逻辑划分</h3><p>java堆逻辑上被分为3大部分：新生代、老生代和永久代，其中的新生代有被划分为Eden、Suvivor0和Suvivor1三个区。Suvivor0和Suvivor1两个区的大小相等，新生代的垃圾回收策略是基于复制回收算法的。这里提到的永久带就是我们说的方法区，只有在HotSpot虚拟机中才存在该区。并非所有的对象创建都会在Eden区中分配内存空间。对于Serial和ParNew垃圾收集器,通过指定-XX:PretenureSizeThreshold={size}来设置超过这个阈值大小的对象直接进入老年代。</p>
<p><img src="http://ocytp9y7u.bkt.clouddn.com/jvm%20memory.png" alt=""></p>
<h2 id="java命令"><a href="#java命令" class="headerlink" title="java命令"></a>java命令</h2><p>java 虚拟机参数分为基本和扩展两类，基本的选项列表通过在命令行窗口中输入java 列出，扩展的选项列表通过java -X命令就可以查看。</p>
<p>java命令的基本格式：</p>
<pre><code>java [-options] class [args...]
</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/z-sm/p/5674684.html" target="_blank" rel="external">Java 命令行运行参数大全</a></li>
<li><a href="http://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="external">深入理解Java类加载器</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM的内存模型&quot;&gt;&lt;a href=&quot;#JVM的内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM的内存模型&quot;&gt;&lt;/a&gt;JVM的内存模型&lt;/h1&gt;&lt;h2 id=&quot;JVM内存划分&quot;&gt;&lt;a href=&quot;#JVM内存划分&quot; class=&quot;header
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础网络知识</title>
    <link href="http://yoursite.com/2018/01/21/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/01/21/基础网络知识/</id>
    <published>2018-01-21T13:08:21.000Z</published>
    <updated>2018-01-21T14:50:27.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>网络七层模型：应用层，会话层，表示层，传输层，网络层，链路层和物理层<br>网络五层模型：应用层，传输层，网络层，链路层，物理层</p>
<p>其中s的含义：SSL/TSL(Security Socket Layer/)TSL是SSL的一个升级</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于公钥加密算法，对称加密/非对称加密。<br>对称加密：加密和解密都是使用的相同的秘钥，可能网络中有很多网络实体是具有这个相同的秘钥的，可能不够安全。<br>非对称加密：公钥加密，私钥解密。公钥由服务器分发。所有客户端都有相同的公钥，但只有服务端有私钥。</p>
<p>握手：</p>
<ol>
<li>客户端先向服务端请求公钥</li>
<li>服务端给请求的客户端返回双方（客户端和服务端）通信的公钥</li>
<li>客户端使用私钥加密通信的数据</li>
<li>服务端用私钥解密公钥加密的数据</li>
</ol>
<p>以上的通信方式看似没有安全性问题，其实也存在中间人攻击的可能：</p>
<ol>
<li>攻击则可以冒充服务端，分发公钥。</li>
<li>攻击则可以冒充服务端，拦截数据后，把数据传递给服务端，服务端响应公钥，攻击者获取加密公钥，然后用自己的公钥替换真的公钥返回给客户端，之后客户端响应的数据都是用的攻击者的公钥加密，攻击者可以使用自己的私钥解密加密的报文并进行篡改。同时用真的公钥加密篡改后的数据响应给服务端</li>
</ol>
<p>引入数字证书颁发机构：</p>
<ol>
<li>客户端向服务端请求公钥，服务端把公钥给到第三方数字证书颁发机构。</li>
<li>第三方数字证书颁发机构使用自己的私钥对服务端的公钥进行加密，生成数字证书，并把该数字证书发送给客户端。</li>
<li>客户端使用本地存储的第三方机构的公钥对证书进行解密，获取服务端的公钥，使用该服务端公钥对数据进行加密，把加密后的数据发送给服务端。</li>
</ol>
<p>以上的流程其实还是存在被攻击的可能。因为攻击者还是有可能替换其中的公钥为自己的公钥的，因为他也有第三方机构的公钥。为解决该问题就需要保证证书是可以在客户端验证真伪的。这样的证书怎么制作呢？</p>
<ol>
<li>第三方证书颁发机构获取到公钥后，使用某种算法依据服务端的公钥生成一个证书编码，这个算法也是证书的一部分。</li>
<li>当客户端收到第三方颁发的证书后，通过证书中的算法和其中的加密公钥分析出证书编码，分析出的证书编码与证书本身的编码进行比较，如果相同，说明公钥没有被篡改。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h1&gt;&lt;p&gt;网络七层模型：应用层，会话层，表示层，传输层，网络层，链路层和物理层&lt;br&gt;网络五层模型：应用层，传输层，网络层，链
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gradle 版本依赖工具</title>
    <link href="http://yoursite.com/2018/01/21/gradle-%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/01/21/gradle-版本依赖工具/</id>
    <published>2018-01-21T09:18:26.000Z</published>
    <updated>2018-01-21T10:10:56.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><a href="http://services.gradle.org/distributions/" target="_blank" rel="external">下载</a></li>
<li><a href="https://gradle.org/install/#manually" target="_blank" rel="external">安装指导</a>或如果你下载的包中包含有文档，在解压后的根目录下有个文件getting-started.html，双击，使用浏览器打开，其中也有安装的指导</li>
<li>设置环境变量</li>
<li><p>检查是否安装成功,如果执行如下命令后看到版本信息，则表明安装成功</p>
<pre><code>gradle -v
</code></pre><p>注意：<em>修改版本包缓存的目录。默认情况下{user}/.gradle目录下，我们需要修改到指定的目录下(Windows),在bin/gradle.bat的相应位置设置如下的第二行脚本：</em></p>
<pre><code># Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script
set GRADLE_OPTS=-Dgradle.user.home=/yourpath/gradle/gradle_cache
</code></pre><p>如果使用的是大于4.3的版本，构建project的时候，使用：</p>
<pre><code>gradle build --scan
</code></pre></li>
</ol>
<h1 id="使用gradle构建Spring"><a href="#使用gradle构建Spring" class="headerlink" title="使用gradle构建Spring"></a>使用gradle构建Spring</h1><p>一定要使用相应版本的gradle构建，不然会出现难以预料的问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://services.gradle.org/distributions/&quot; target=&quot;_bla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-boot 学习</title>
    <link href="http://yoursite.com/2018/01/13/Spring-boot-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/01/13/Spring-boot-学习/</id>
    <published>2018-01-13T07:03:18.000Z</published>
    <updated>2018-01-15T13:05:16.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><ol>
<li>以远程方式启动应用</li>
<li>在eclipse中配置远程调试：Debug As =&gt; Debug Confirgurations =&gt; Remote Java Application,</li>
<li>配置好应用运行的环境的IP和监听debug调试的端口</li>
</ol>
<h1 id="启动Spring-boot应用"><a href="#启动Spring-boot应用" class="headerlink" title="启动Spring boot应用"></a>启动Spring boot应用</h1><ol>
<li>在IDE中启动</li>
<li><p>把应用打成jar，使用命令：</p>
<pre><code>java -jar myproject.jar //普通的启动
java -jar myproject.jar --debug //可以在控制台输出相关的debug日志信息
</code></pre></li>
</ol>
<h1 id="外化配置"><a href="#外化配置" class="headerlink" title="外化配置"></a>外化配置</h1><p>Spring Boot 允许你外化你的配置，这样你就可以在不同的环境中使用相同的应用程序代码。你可以使用properties文件，YAML文件，环境变量和命令行参数等外化你的配置。</p>
<h1 id="使用Spring-Boot开发应用"><a href="#使用Spring-Boot开发应用" class="headerlink" title="使用Spring Boot开发应用"></a>使用Spring Boot开发应用</h1><h2 id="Spring-MVC自配置"><a href="#Spring-MVC自配置" class="headerlink" title="Spring MVC自配置"></a>Spring MVC自配置</h2><p>Spring Boot为Spring MVC提供了自动配置    ，这在大多数程序中都很适用。</p>
<p>自动配置在Spring默认配置的基础上添加了如下的特性：</p>
<ol>
<li>包含<code>ContentNegotiatingViewResolver</code> 和 <code>BeanNameViewResolver</code>  beans。</li>
<li>支持为静态资源提供服务，包括支持webjar</li>
<li><code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code> 的自动注册</li>
<li>支持<code>HttpMessageConverters</code> </li>
<li><code>MessageCodesResolver</code> 的自动注册</li>
<li>静态文件<code>index.html</code>的支持</li>
<li>支持自定义图标</li>
<li>自动适用<code>ConfigurableWebBindingInitializer</code> bean</li>
</ol>
<p>如果你想保留Spring Boot MVC的特征，且你只想增加附加的MVC配置（如拦截器，格式化和视图控制器等），你可以增加你自己的<code>@Configuration</code> 类类型<code>WebMvcConfigurerAdapter</code>，但是没有<code>@EnableWebMvc</code>。如果你希望提供定制化的<code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> 或<code>ExceptionHandlerExceptionResolver</code> 的实例，你可以声明一个<code>WebMvcRegistrationsAdapter</code> 实例来提供这些组件。</p>
<p>如果你想要完全控制Spring MVC，你可以使用<code>@EnableWebMvc</code>增加你自己的<code>@Configuration</code>注解。</p>
<h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST(Representational State Transfer，表述性状态转移)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;远程调试&quot;&gt;&lt;a href=&quot;#远程调试&quot; class=&quot;headerlink&quot; title=&quot;远程调试&quot;&gt;&lt;/a&gt;远程调试&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;以远程方式启动应用&lt;/li&gt;
&lt;li&gt;在eclipse中配置远程调试：Debug As =&amp;gt; Debug 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Socket 编程</title>
    <link href="http://yoursite.com/2018/01/07/Java-Socket-%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/07/Java-Socket-编程/</id>
    <published>2018-01-07T05:17:58.000Z</published>
    <updated>2018-03-11T15:42:29.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket在网络编程中所处的位置"><a href="#Socket在网络编程中所处的位置" class="headerlink" title="Socket在网络编程中所处的位置"></a>Socket在网络编程中所处的位置</h1><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><center><img src="http://img.blog.csdn.net/20161209121343020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWpwMTk4NzEwMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></center><br>基于TCP/IP协议族的网络，共分四层：</p>
<ol>
<li>应用层，例如HTTP，FTP。它们都是基于TCP/UDP设计出来的</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p>Socket是位于应用层之下，传输层之上的接口，也就是操作系统提供给用户访问网络的系统接口。我们可以借助于Socket接口层，对传输层，网际层以及网络接口层进行操作，来实现我们不同的应用层协议。对于应用层，我们想实现网络功能，归根究底都是要通过Socket来实现的，否则，我们无法访问处于操作系统的传输层，网际层以及网络接口层。</p>
<p>Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。一般由操作系统或者JVM自己实现。java.net中的socket其实就是对底层的抽象调用。</p>
<p>套接字关联的数据结构：</p>
<ol>
<li>该套接字所关联的本地和远程互联网地址和端口。</li>
<li>一个FIFO队列用于存放接收到的等待分配的数据（RecvQ），以及一个用于存放等待传输数据的的队列（SendQ）</li>
<li>对于TCP套接字，还包含了与打开关闭TCP握手相关的额外协议状态信息。</li>
</ol>
<p>在JAVA中，我们用 ServerSocket、Socket类创建一个套接字连接，从套接字得到的结果是一个InputStream以及OutputStream对象，以便 将连接作为一个IO流对象对待。通过IO流可以从流中读取数据或者写数据到流中，读写IO流会有异常IOException产生。向输出流写数据并不意味着数据实际上已经被发送，它们只是被复制到了发送缓冲区队列SendQ，就是在Socket的OutputStream上调用 flush()方法，也不能保证数据能够立即发送到网络。<strong>真正的数据发送是由操作系统的TCP协议栈模块从缓冲区中取数据发送到网络来完成的</strong>。当有数据从网络来到时，TCP协议栈模块接收数据并放入接收缓冲区队列RecvQ，输入流InputStream通过read方法从RecvQ中取出数据。</p>
<p>套接字底层是基于TCP的，所以socket的超时和TCP超时是相同的。如果TCP的三次握手超时，那这个socket连接也会超时。</p>
<p>TCP/UDP，两者最大的区别在于，TCP是可靠的，也就是说，我们通过TCP发送的数据，网络协议栈会保证数据可靠的传输到对端，而UDP是不可靠的，如果出现丢包，协议栈不会做任何处理，可靠性的保证交由应用层处理。因此，TCP的性能会比UDP低，但是可靠性会比UDP好很多。除此之外，两者在传输数据时，也有形式上的不同，TCP的数据是流，大家可以类比文件流，而UDP则是基于数据包，也就是说数据会被打成包发送。流和数据包的最大区别在于流没有数据边界，数据包有数据边界，UDP每次发送的数据都独立成包。</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2></li>
</ul>
<ol>
<li>TCP连接的建立需要通过三次握手来完成 </li>
<li><p>TCP连接的关闭通过四次挥手来完成。</p>
<h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><p>目前常见的服务器模型主要有三种：</p>
</li>
<li><p>阻塞服务器</p>
</li>
<li>并发服务器</li>
<li><p>异步服务器</p>
<ul>
<li>阻塞式服务器是最好实现的服务器，也是问题最多的服务器。客户端发送到服务端的请求会进行排队，服务器会一次处理这些请求，前一个请求没有处理完，就不会处理下一个请求，这种服务器很容易受到攻击，只需要发送一个处理时间很长的请求就可以阻塞其他的请求。因此这种服务器也只能作为理论上的模型。</li>
<li>并发式服务器。这种服务器处理请求的时候，会为每个接收到的请求创建独立的线程来处理该请求。好处是不会出现请求被阻塞的情况，但也存在一些问题，如果线程过多会把服务器的资源耗尽，导致服务器不能提供服务。不过好在有别的方式可以规避这种情况，就是在服务端建立线程池来处理请求。线程池虽然避免了服务器资源耗尽的问题，但是也存在一些自身的不足，比如线程池资源被用完后，后续的请求也会出现阻塞的情况。</li>
<li>异步服务器。这种服务器借助系统的异步IO机制，当一个请求到来，我们可以先将请求注册，当有数据可以读取时，会得到通知，这时我们处理请求，这样服务器没有必要阻塞线程，也不会存在很大的系统开销，因此对于并发量比较高的服务器，一般都采用这种方式。</li>
</ul>
</li>
</ol>
<p>服务器的优化之路：单个线程阻塞模式；一个请求一个线程处理；多线程+线程池；NIO中的多路复用技术，一个线程管理多个请求。这里的请求都是服务端的接收套接字接收到客户端的连接请求。</p>
<h1 id="Java异步编程"><a href="#Java异步编程" class="headerlink" title="Java异步编程"></a>Java异步编程</h1><p>JAVA平台,实现异步调用的角色有如下三个角色：</p>
<ol>
<li>调用者</li>
<li>取货凭证</li>
<li>真实数据</li>
</ol>
<p>一个调用者在调用耗时操作,不能立即返回数据时,先返回一个取货凭证.然后在过一断时间后凭取货凭证来获取真正的数据。所以连结调用者和真实数据之间的桥梁是取货凭证。</p>
<h2 id="Java中的回调"><a href="#Java中的回调" class="headerlink" title="Java中的回调"></a>Java中的回调</h2><p>java中的回调就是将规定一个接口，然后设计一个类（该类与接口存在关联或者依赖关系），最后，当使用这个类的时候，实现之前规定的接口，这就是java中的回调。简单的说，在Java中，通常就是编写下层的人规定一个接口，由上层来实现这个接口；然后上层就可以把这个接口的一个对象作为参数传给下层，下层就会通过那个接口来调用由上层编写的函数。</p>
<p>java的回调是以接口的形式实现的。从类之间的关系角度看，有关联与依赖之分。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Socket在网络编程中所处的位置&quot;&gt;&lt;a href=&quot;#Socket在网络编程中所处的位置&quot; class=&quot;headerlink&quot; title=&quot;Socket在网络编程中所处的位置&quot;&gt;&lt;/a&gt;Socket在网络编程中所处的位置&lt;/h1&gt;&lt;h2 id=&quot;网络分层&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习JMS</title>
    <link href="http://yoursite.com/2018/01/07/%E5%AD%A6%E4%B9%A0JMS/"/>
    <id>http://yoursite.com/2018/01/07/学习JMS/</id>
    <published>2018-01-07T02:41:45.000Z</published>
    <updated>2018-01-07T02:42:26.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JMS使用中遇到的问题"><a href="#JMS使用中遇到的问题" class="headerlink" title="JMS使用中遇到的问题"></a>JMS使用中遇到的问题</h1><h2 id="使用spring的消息转换器时提示的安全问题"><a href="#使用spring的消息转换器时提示的安全问题" class="headerlink" title="使用spring的消息转换器时提示的安全问题"></a>使用spring的消息转换器时提示的安全问题</h2><p>自定义了一个普通的java对象Email,希望通过spring提供的消息对象转换器把其转为对应的jms消息对象，但在转发消息时候出现如下日志提示的错误。</p>
<p>错误日志：</p>
<p><code>Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class com.daniel.study.jms.model.Email! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.</code></p>
<p>导致的原因是在5.12.2 and 5.13.0版本后为了传输的对象是安全的，强制要求用户指定需要传输的对象所在的包（package），只有在指定的包下的类的对象才能使用ObjectMessage进行安全转换，也就是要指定能进行转换的对象的类所在包作为一个白名单。有两种配置白名单的方式：</p>
<ol>
<li>客户端配置，该方式是在5.12.2和5.13.1及之后的版本中提供的配置方式，这种方式是常用的。</li>
</ol>
<p>Spring配置文件中配置，配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;  </div><div class="line">	    &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;</div><div class="line">	    &lt;!-- 指定可以通过ObjectMessage进行安全转换的对象的类所在的包 --&gt;</div><div class="line">	    &lt;property name=&quot;trustedPackages&quot;&gt;</div><div class="line">	        &lt;list&gt;</div><div class="line">	            &lt;value&gt;com.daniel.study.jms.model&lt;/value&gt;</div><div class="line">	        &lt;/list&gt;</div><div class="line">        &lt;/property&gt;  </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;  </div><div class="line">	    &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;</div><div class="line">	    &lt;property name=&quot;trustAllPackages&quot; value=&quot;true&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>如上的配置就是把com.daniel.study.jms.model下的所有类都加入白名单，在该白名单下的类的对象都是可以通过spring提供的转换器进行转换的。<a href="http://activemq.apache.org/objectmessage.html" target="_blank" rel="external">参考</a></p>
<p>java代码中设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);</div><div class="line">factory.setTrustedPackages(new ArrayList(Arrays.asList(&quot;org.apache.activemq.test,org.apache.camel.test&quot;.split(&quot;,&quot;))));</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);</div><div class="line">factory.setTrustAllPackages(true);</div></pre></td></tr></table></figure>
<ol>
<li>还可以在服务端（activeMq broker）中进行配置，这种方式的配置开始于activeMq的5.12.2和5.13.0版本，在${ACTIVEMQ_HOME}/bin/env中配置activeMq的系统属性ACTIVEMQ_OPTS：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dorg.apache.activemq.SERIALIZABLE_PACKAGES=java.lang,javax.security,java.util,org.apache.activemq,org.fusesource.hawtbuf,com.thoughtworks.xstream.mapper,com.daniel.study.jms.model</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Dorg.apache.activemq.SERIALIZABLE_PACKAGES=*`</div></pre></td></tr></table></figure>
<p>如上的设置，其中com.daniel.study.jms.model是加入白名单的包，对于broker的，其余的包默认是必须的。</p>
<h1 id="JMS事务管理之JNDI数据源配置"><a href="#JMS事务管理之JNDI数据源配置" class="headerlink" title="JMS事务管理之JNDI数据源配置"></a>JMS事务管理之JNDI数据源配置</h1><h2 id="什么是jndi"><a href="#什么是jndi" class="headerlink" title="什么是jndi"></a>什么是jndi</h2><p>jndi(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象。目录服务是一种命名服务，在这种服务里，对象不但有名称，还有属性。也就是说目录服务是一种特殊的命名服务。</p>
<h2 id="Tomcat容器"><a href="#Tomcat容器" class="headerlink" title="Tomcat容器"></a>Tomcat容器</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p><strong>全局：</strong></p>
<ol>
<li>在tomcat的conf文件夹下的context.xml配置文件中加入：<br>` &lt;Resource name=”jndi/mysql”   <pre><code>auth=&quot;Container&quot;   
type=&quot;javax.sql.DataSource&quot;   
driverClassName=&quot;com.mysql.jdbc.Driver&quot;   
url=&quot;jdbc:mysql://localhost:3306/test&quot;   
username=&quot;root&quot;   
password=&quot;root&quot;   
maxActive=&quot;20&quot;   
maxIdle=&quot;10&quot;   
maxWait=&quot;10000&quot;/&gt; 
</code></pre>`</li>
<li>在项目的web.xml中加入资源引用：<br><code>&lt;resource-ref&gt;  
&lt;description&gt;JNDI DataSource&lt;/description&gt;  
&lt;res-ref-name&gt;jndi/mysql&lt;/res-ref-name&gt;  
&lt;res-ref-type&gt;javax.sql.DataSource&lt;/res-ref-type&gt;  
&lt;res-auth&gt;Container&lt;/res-auth&gt;  
&lt;/resource-ref&gt;</code></li>
<li>在mybatis配置文件中加入:<br>`<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"><pre><code>&lt;property name=&quot;jndiName&quot;&gt;
    &lt;value&gt;java:comp/env/jdbc/mysql&lt;/value&gt;
&lt;/property&gt;
</code></pre> </bean><br>`<br><strong>单个项目：</strong></li>
<li>在META-INF中创建一个名为context.xml文件，在其中加入：<br>`&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br><context><br> &lt;Resource  name=”jdbc/mysql” auth=”Container” <pre><code>type=&quot;javax.sql.DataSource&quot;                                                     
driverClassName=&quot;com.mysql.jdbc.Driver&quot;                                 
url=&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&quot;
username=&quot;root&quot;
password=&quot;root&quot;
maxActive=&quot;50&quot;
maxIdle=&quot;30&quot;
maxWait=&quot;10000&quot; /&gt;
</code></pre></context><br>`</li>
<li>其他的同全局配置</li>
</ol>
<h2 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h2><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><h2 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h2><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><h3 id="配置方式-3"><a href="#配置方式-3" class="headerlink" title="配置方式"></a>配置方式</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是指一个工作单元，它包含了一组添加，删除，修改等具有逻辑关系的多个操作,作为一个单元整体执行，这组命令要么都执行成功，要么全部恢复</p>
<h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>分布式事务是指事务的参与者、支持事务的服务器、资源管理器以及事务管理器分别位于分布式系统的不同节点之上<br>在两个或多个网络计算机资源上访问并且更新数据。将对两个或多个网络计算机的数据进行的多次操作作为一个整体进行处理。如：不同银行账户之间转账。</p>
<p>一个分布式事务(distributed  transaction)包括一个事务管理器(transaction  manager)和一个或多个资源管理器(resource manager)</p>
<ol>
<li>一个资源管理器(resource  manager)是任意类型的持久化数据存储(数据库)。</li>
<li>事务管理器(transaction manager)承担着所有事务参与单元者的相互通讯的责任。</li>
</ol>
<h2 id="分布式事务处理流程"><a href="#分布式事务处理流程" class="headerlink" title="分布式事务处理流程"></a>分布式事务处理流程</h2><p>分布式事务处理允许JDBC驱动程序支持两段式提交协议</p>
<p>阶段一：开始向事务涉及到的全部资源发送提交前信息。此时，事务涉及到的资源还有最后一次机会来结束事务。如果任意一个资源决定结束事务，则整个事务取消，不会进行资源的更新。否则，事务将正常执行。为了防止发生资源更新失败，所有资源的更新都会写入到日志中。这些日志是永久性的，因此，这些日志在更新失败之后可以重新对所有资源进行恢复。(更新内存数据)</p>
<p>阶段二：只在阶段一没有异常结束的时候才会发生。此时，所有的资源管理器都开始执行真正的数据更新。 (更新数据库数据)</p>
<p>能实现分布式事务管理的事务管理器：</p>
<ol>
<li>JTA允许应用程序执行分布式事务处理。支持JTA的JDBC驱动程序极大地增强了数据访问能力。如果计划使用JTA来处理分布式事务,需要一个实现了以下接口的JDBC驱动</li>
</ol>
<p><code>javax.sql.XADataSource:获得XAConnection对象的工厂
javax.sql.XAConnection:继承PooledConnection,为分布式事务提供支持，事务管理器(通常为中间层服务器的一部分)通过XAResource对象管理XAConnection对象
javax.sql.DataSource</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JMS使用中遇到的问题&quot;&gt;&lt;a href=&quot;#JMS使用中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;JMS使用中遇到的问题&quot;&gt;&lt;/a&gt;JMS使用中遇到的问题&lt;/h1&gt;&lt;h2 id=&quot;使用spring的消息转换器时提示的安全问题&quot;&gt;&lt;a hr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaWeb 关键知识点答疑</title>
    <link href="http://yoursite.com/2018/01/01/JavaWeb-%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AD%94%E7%96%91/"/>
    <id>http://yoursite.com/2018/01/01/JavaWeb-关键知识点答疑/</id>
    <published>2018-01-01T06:16:59.000Z</published>
    <updated>2018-01-19T14:22:37.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-xml的作用"><a href="#web-xml的作用" class="headerlink" title="web.xml的作用"></a>web.xml的作用</h1><p>web.xml文件并不是web工程必须的，只有你需要配置欢迎页、servlet、filter等的时候，才需要配置它。web.xml的模式文件是由Sun公司定义的，每个web.xml文件的根元素<web-app>中，都必须标明这个web.xml使用的是哪些模式文件。</web-app></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;2.5&quot;
    xmlns=&quot;http://Java.sun.com/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;
&lt;/web-app&gt;
</code></pre><p>Tomcat加载欢迎页面的顺序：</p>
<ol>
<li>如果web中的web.xml文件中配置了欢迎页面，访问web的时候，就返回那个指定的欢迎页面</li>
<li>如果web中没有web.xml，或者web.xml中没有指定欢迎页面，Tomcat默认先查询index.html</li>
<li>如果第2步没有找到index.html，那就会去找index.jsp</li>
<li>如果以上步骤都没有找到合适的欢迎页面，那就返回<code>resource (/XXX) is not available</code></li>
</ol>
<h2 id="web-xml中命名与定制URL"><a href="#web-xml中命名与定制URL" class="headerlink" title="web.xml中命名与定制URL"></a>web.xml中命名与定制URL</h2><p>命名必须在定制URL之前</p>
<ol>
<li><p>servlet命名</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;
    &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
</code></pre></li>
<li><p>为servlet定制URL</p>
<pre><code>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></li>
</ol>
<h2 id="web-xml的加载顺序"><a href="#web-xml的加载顺序" class="headerlink" title="web.xml的加载顺序"></a>web.xml的加载顺序</h2><h3 id="根据节点确定加载顺序"><a href="#根据节点确定加载顺序" class="headerlink" title="根据节点确定加载顺序"></a>根据节点确定加载顺序</h3><ol>
<li>启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取<listener>和<context-param>两个结点。</context-param></listener></li>
<li>紧急着，容器创建一个ServletContext（servlet上下文），这个web项目的所有部分都将共享这个上下文。</li>
<li>容器将<context-param>转换为键值对，并交给servletContext。</context-param></li>
<li>容器创建<listener>中的类实例，创建监听器。</listener></li>
</ol>
<h3 id="根据oad-on-startup-元素的值确定加载顺序"><a href="#根据oad-on-startup-元素的值确定加载顺序" class="headerlink" title="根据oad-on-startup 元素的值确定加载顺序"></a>根据oad-on-startup 元素的值确定加载顺序</h3><p>oad-on-startup 元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候，加载这个servlet 。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。</p>
<h3 id="加载优先级的一些补充"><a href="#加载优先级的一些补充" class="headerlink" title="加载优先级的一些补充"></a>加载优先级的一些补充</h3><p>首先可以肯定的是，加载顺序与它们在 web.xml 文件中的先后顺序无关。即不会因为 filter 写在 listener 的前面而会先加载 filter。</p>
<p>按元素节点加载的顺序：context-param -&gt; listener -&gt;filter -&gt; servlet 。但对于同一类的元素节点，加载的顺序是和在web.xml中的配置顺序有关的</p>
<h1 id="servlet基础知识"><a href="#servlet基础知识" class="headerlink" title="servlet基础知识"></a>servlet基础知识</h1><h2 id="实现一个用户自己的servlet"><a href="#实现一个用户自己的servlet" class="headerlink" title="实现一个用户自己的servlet"></a>实现一个用户自己的servlet</h2><ol>
<li>所有用户自定义的servlet都必须要么继承javax.servlet.GenericServlet ，要么继承 javax.servlet.http.HttpServlet。前者是普通的servlet，后者是和HTTP相关servlet，这里介绍的和web相关的servlet一般都是继承自HttpServlet</li>
<li>在用户自定义的servlet中需要重写doGet和doPost方法，当一个GET或者POST请求到来后会映射到相应的方法。</li>
<li>可以重写别的一些方法，它们可以用来在运行时控制用</li>
<li>HttpServletRequest 和 HttpServletResponse 是所有doXXX()方法的默认参数。</li>
<li>为了发送内容给客户端，你需要使用从 HttpServletResponse 里获取的 PrintWriter 对象。任何写到这个对象的内容都会被写进outputstream里，并会把内容发送回给客户端。</li>
</ol>
<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><ol>
<li>初始阶段，web容器通过调用init()方法来初始化Servlet实例。这个方法在Servlet实例的生命周期里只调用一次。</li>
<li>处理客户端请求，web容器调用Servlet的service()方法来处理每一个请求。service() 方法定义了能够处理的请求类型并且调用适当方法来处理这些请求。编写Servlet的开发者必须实现这些请求对应的方法，否则就会调用父类对应的方法</li>
<li>消亡期，web容器调用destroy()方法来终结Servlet。如果你想在Servlet的生命周期内关闭或者销毁一些文件系统或者网络资源，你可以调用这个方法来实现。destroy() 方法和init()方法一样，在Servlet的生命周期里只能调用一次。</li>
</ol>
<h2 id="Servlet的优势"><a href="#Servlet的优势" class="headerlink" title="Servlet的优势"></a>Servlet的优势</h2><ol>
<li>Java Servlets如此有用的原因之一是Servlet能动态显示网页内容。</li>
<li>Servlet可以轻松创建一个基于请求和响应生命周期的web应用。</li>
<li>它们能够提供HTTP响应并且可以使用同一段代码来处理业务逻辑。处理业务逻辑的能力使Servlet比标准的HTML代码更强大。</li>
</ol>
<h2 id="容器的概念"><a href="#容器的概念" class="headerlink" title="容器的概念"></a>容器的概念</h2><ol>
<li>什么是服务器？</li>
</ol>
<p>就是应用运行的环境</p>
<ol>
<li>什么是servlet容器？</li>
</ol>
<p>如果服务器是一个Java web服务器，那么这个web服务器中就必须包含一个Servlet容器。</p>
<h3 id="容器事件监听器"><a href="#容器事件监听器" class="headerlink" title="容器事件监听器"></a>容器事件监听器</h3><p>为了创建一个基于容器事件执行动作的监听器，你必须创建一个实现 ServletContextListener 接口的类。这个类必须实现的方法有 contextInitialized() 和 contextDestroyed()。这两个方法都需要 ServletContextEvent 作为参数，并且在每次初始化或者关闭Servlet容器时都会被自动调用。</p>
<h2 id="servlet过滤器"><a href="#servlet过滤器" class="headerlink" title="servlet过滤器"></a>servlet过滤器</h2><p>Web过滤器在给定的URL被访问时对请求进行预处理并调用相应的功能是很有用的。相 比于直接调用给定URL请求的Servlet，包含相同URL模式的过滤器（filter）会在Servlet调用前被调用。过滤器必须要实现 javax.servlet.Filter 接口。这个接口包含了init()，descriptor()和doFilter()这些方法。init()和destroy()方法会被容器调用。 doFilter()方法用来在过滤器类里实现逻辑任务。如果你想把过滤器组成过滤链（chain filter）或者存在多匹配给定URL模式的个过滤器，它们就会根据web.xml里的配置顺序被调用。过滤器的URL必须对应需要过滤的servlet，两者的URL必须一模一样，在进入servlet前，web容器都会先调用相应的filter。</p>
<h1 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h1><p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。用来告诉客户端所获取的文件的类型，使得客户端可以调用相应的插件或应用来处理这个请求相应回来的文件。</p>
<h1 id="请求转发和请求重定向"><a href="#请求转发和请求重定向" class="headerlink" title="请求转发和请求重定向"></a>请求转发和请求重定向</h1><h2 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h2><p>有时候，你的应用需要把一个Servlet要处理的请求转让给另外的Servlet来处理并完成任务。而且，转让请求时不能重定向客户端的URL。即浏览器地址栏上的URL不会改变。在 ServletContext 里已经内置了实现上面需求的方法。所以，当你获取了 ServletContext 的引用，你就可以简单地调用getRequestDispatcher() 方法去获取用来转发请求的 RequestDispatcher 对象。当调用 getRequestDispatcher() 方法时，需要传递包含servlet名的字符串，这个Servlet就是你用来处理转让请求的Servlet。获取 RequestDispatcher 对象后，通过传递 HttpServletRequest 和HttpServletResponse 对象给它来调用转发方法。转发方法负责对请求进行转发。</p>
<pre><code>RequestDispatcher rd = servletContext.getRequestDispatcher(&quot;/NextServlet&quot;);
rd.forward(request, response);
</code></pre><h2 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h2><p>尽管有时候，你不想在Servlet发送重定向时通知用户，就像我们在上面那段看到的一样。但是在某些情况下，我们确实想要通知用户。当应用内的特定URL被访问时，你想把浏览器的URL重定向到另外一个。<br>要实现这种功能，你需要调用 HttpServletResponse 对象的sendRedirect()方法。</p>
<pre><code>httpServletResponse.sendRedirect(&quot;/anotherURL&quot;);
</code></pre><h1 id="Web服务器，应用服务器，Web容器"><a href="#Web服务器，应用服务器，Web容器" class="headerlink" title="Web服务器，应用服务器，Web容器"></a>Web服务器，应用服务器，Web容器</h1><h2 id="Web服务器和应用服务器"><a href="#Web服务器和应用服务器" class="headerlink" title="Web服务器和应用服务器"></a>Web服务器和应用服务器</h2><p>在以前这两者是有明显的区别，但是现在这两者的区别逐渐合并，甚至于在某些情况下可以把二者看为一件事物了（实体）。</p>
<p>一开始，<strong>web服务器</strong>足够简单，只提供基于HTTP协议的静态页面内容和图片，在那个时候，大部分的内容都是静态的，HTTP1.0协议只是把静态文件移动来移动去。但是之后很快web server演进到有了CGI的能力，这意味着有效地在每个web请求上启动一个进程来生成动态内容，这个时候的HTTP协议更加成熟，web server变得更加的复杂，其增加了许多的功能，如缓存，安全和会话管理等。随着技术的进一步成熟，我们从Kiva和NetDynamics获得了公司特有的基于java的服务器端技术，这些技术最终都集成到JSP中，这项技术我们今天任然用在大部分的应用开发中。</p>
<p>与web server对应的应用服务器（application servers）演进和存在了很长时间。一些公司为Unix发布产品，如Tuxedo, TopEnd, Encina ，它们都是基于大型机应用管理和类似IMS和CICS的模拟环境的哲学上的演进思想。这些产品中的大多数都指定了“封闭”的特定于产品的通信协议，将“重量级”客户端与服务器互连。90年代，这些传统的应用服务器产品开始演进出基于HTTP的通信协议的能力，一开始是经由网关，但很快这两种方式的界限就变得模糊不清了。</p>
<p>与此同时，web server因为能处理更高的加载，更多的并发和更好的特性。应用服务器开始发布越来越多的基于HTTP协议的通信能力，这就导致了web服务和应用服务器的之间的界限越来越窄。</p>
<p>现今，web服务器和应用服务器已经无多大区别，但有时候人们还会基于一些重要的特征来区别它们。</p>
<h2 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h2><center> <img src="https://howtodoinjava.com/wp-content/uploads/web-server-servlet-container.jpg" alt="web server与web container的区别"> </center>

<p>Web Container，是java中的一种特殊说法，应该指的就是servlet容器。servlet容器就是web服务器的一个组件，它可以与servlet交互。一个web容器负责管理servlet的生命周期，映射一个URL到一个特殊的servlet，并确保这个URL请求有正确的访问权限和更多这样的服务。总之，据以上所述，servlet容器就是servlet的运行环境和它的生命周期的维护位置。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>对于java而言，servlet让你可以编写服务端组件，这些组件有助于生成基于请求的动态内容。实际上，servlet是javax.servlet包中的一个接口，其中为一个servlet的生命周期声明了三个重要的方法——init(),service()和destroy()。每个servlet都会实现这三个方法，它们会在servlet的生命周期中的特定时间被调用。servlet是运行与服务端的，独立与平台和协议的技术。</p>
<center><img src="http://img.blog.csdn.net/20150420163121018" alt="servlet的工作流程"></center>

<p>在浏览器中输入一个URL地址后发生的事：</p>
<ol>
<li>根据输入的地址找到服务器</li>
<li>根据端口找到服务器上对应的在该端口上监听的程序（Tomcat）</li>
<li>进入找到的服务器程序</li>
<li>在服务器程序中找到servlet容器</li>
<li>在servlet容器中根据URL定位到提供服务的servlet的名称,如果没有找到对应的servlet类，就会调用Tomcat定义的DefaultServlet来直接访问webapp目录下的金泰资源</li>
<li>根据servlet名称找到servlet对应的servlet类</li>
<li>根据servlet类反射获取指定的方法</li>
<li>指定的方法动态生成响应</li>
<li>响应返回给服务器程序</li>
<li>服务器程序把响应传回给客户端程序（浏览器）</li>
</ol>
<p>Servlet类通过类加载器动态地加载到容器中，既可以通过懒加载的方式，也可以通过饿加载的方式。每个请求都有自己的线程，在同一时间，一个servlet可以服务于多个线程。当servlet对象不再使用了就会被JVM垃圾回收。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>当servlet容器启动时，它会部署和加载所有的应用，当一个应用被加载的时候，servlet容器会为每个应用创建一个ServletContext，且把它保留在内存中。web应用的web.xml会被解析，在web.xml中的每一个Servlet，Filter和Listener都会被创建一次，并也会保留在服务器的内存中。当servlet容器关闭的时候，会卸载所有的应用和ServletContext，所有的Servlet，Filter和Listener也都会被销毁。</p>
<p>按java文档所描述的，ServletContext定义了一系列servlet用来与它的容器通信的方法，例如过去文件的MIME类型，分发请求，或写日志文件等。在一个web应用在它的发布描述符中标记“分布式”的情况下，每个虚拟机会有一个context实例。在这种情况下，context不能用作共享全局信息的位置（因为信息不是真的全局的）。需要使用一个额外的资源，比如数据库。</p>
<h2 id="ServletRequest-和-ServletResponse-适合在servlet生命周期的那个阶段使用"><a href="#ServletRequest-和-ServletResponse-适合在servlet生命周期的那个阶段使用" class="headerlink" title="ServletRequest 和 ServletResponse 适合在servlet生命周期的那个阶段使用"></a>ServletRequest 和 ServletResponse 适合在servlet生命周期的那个阶段使用</h2><p>servlet容器绑定到一个web服务器上，该web服务器在某个端口上监听HTTP请求，通常是在80端口上。当一个客户端发送一个HTTP请求，servlet容器会创建一个新的HttpServletRequest 和 HttpServletResponse对象，并通过已经创建的URL模式匹配请求URL的filter和servlet实例来传递它们，所有这些都是在一个线程中完成的。</p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>当一个客户端第一次访问web应用，HttpSession会通过request.getSession()第一次被获取，servlet容器会创建它，生成一个长的独一无二的ID，并把它存入服务器内存中，Servlet也会为HTTP响应设置一个cookie，JSESSIONID 作为cookie的名称，独一无二的session ID作为cookie的值。</p>
<p>根据Http cookie的说明文档，只要这个cookie是有效的，在后续的请求中客户端都需要返回这个cookie。servlet容器将确定每一个传入的HTTP请求头，并使用名为JSESSIONID的cookie，使用cookie的值关联server内存中的HttpSession。</p>
<p>HttpSession一直存在，除非超过一定的时间没有被使用了，这个时间通常可以在web.xml中设置，默认值会是30分钟。因此当客户端超过30分钟没有访问应用时，servlet容器会销毁这个session。后续的每个请求，即便是有指定cookie的，也不再能访问相同session。servlet容器会创建一个新的。</p>
<p>另一方面，在客户端的session cookie有一个默认的存在时长，与浏览器的运行一样的时长。所以只要客户端关闭浏览器，在客户端的cookie就会被销毁。重新打开浏览器，与这个会话相关的cookie都不会再被发送。新的request.getSession()将会返回一个新的HttpSession，使用一个新的session ID设置一个新的cookie。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>你应该意识到你不能赋值任何请求或会话作用域的数据为一个servlet或filter的实例的变量。这些变量会在所有的请求会话中共享，这样的话就会导致线程不安全。<br><strong>Servlet在Tomcat中单实例多线程，导致了servlet在多线程下变量共享的线程安全问题。</strong></p>
<p>注：servlet的设计不是singleto模式，知识说servlet容器只创建其一次。</p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>Servlet输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。为解决这个问题，SUN推出了类似于ASP的镶嵌型的JSP，JSP把TAG嵌套到HTML语句中，就大大简化和方便了网页的设计和修改。</p>
<ol>
<li>JSP在本质上就是servlet，但两者的创建方式不一样</li>
<li>servlet是完全有java语言编写，善于流程控制和事务处理，通过servlet来生成动态网页很不直观</li>
<li>JSP由HTML代码和JSP标签组成，可以方便的编写动态网页</li>
</ol>
<p>基于以上原因，实际应用中多采用servlet来控制业务流程，采用JSP来生成动态网页。在MVC框架中，JSP位于视图层，servlet位于控制层。</p>
<ol>
<li>JSP是servlet的技术扩展，本质上就是servlet的简易形式</li>
<li>JSP编译后就是servlet类</li>
<li>servlet和JSP的最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP是Java和HTML组合成一个扩展名为.jsp的文件</li>
<li>JSP侧重于视图，Servlet主要用于控制逻辑。</li>
</ol>
<h3 id="web服务器使用JSP创建网页"><a href="#web服务器使用JSP创建网页" class="headerlink" title="web服务器使用JSP创建网页"></a>web服务器使用JSP创建网页</h3><ol>
<li>对于一个正常的页面，浏览器发送一个HTTP请求到万维网服务器。</li>
<li>网站服务器识别HTTP请求是一个JSP页面，并将其转发给JSP引擎。这是通过使用URL或JSP页面，而这个页面使用 .jsp 后缀，而不是 .html 后缀。</li>
<li>JSP引擎从磁盘加载JSP页面，并将其转换成servlet的内容。这种转换是很简单的，所有的模板文本被转换给println()语句，所有JSP元素被转换为实现该页面相应动态行为的Java代码。</li>
<li>JSP引擎编译成servlet的一个可执行类并转发原始请求到servlet引擎。</li>
<li>一部分Web服务器调用servlet引擎加载Servlet类并执行它。在执行期间，Servlet产生HTML的格式输出，其servlet引擎传递到web服务器响应HTTP请求。</li>
<li>Web服务器响应HTTP转发静态的HTML内容到浏览器。</li>
<li>最后的 web 浏览器处理HTTP响应动态生成的HTML页面完全就像一个静态页面内容。</li>
</ol>
<p><strong><em>JSP可通过servlet引擎动态的编译为静态页面</em></strong></p>
<ol>
<li><p>JSP脚本，JSP语法：</p>
<pre><code>&lt;% code fragment %&gt;
</code></pre><p>或XML语法：</p>
<pre><code>&lt;jsp:scriptlet&gt;
       code fragment
&lt;/jsp:scriptlet&gt;
</code></pre></li>
<li><p>JSP声明，JSP语法：</p>
<pre><code>&lt;%! declaration; [ declaration; ]+ ... %&gt;
</code></pre><p>或XML语法：</p>
<pre><code>&lt;jsp:declaration&gt;
       code fragment
&lt;/jsp:declaration&gt;
</code></pre></li>
<li><p>JSP表达式，JSP语法：</p>
<pre><code>&lt;%= expression %&gt;
</code></pre><p>或XML语法：</p>
<pre><code>&lt;jsp:expression&gt;
       expression
&lt;/jsp:expression&gt;
</code></pre></li>
<li><p>JSP注释，JSP语法：</p>
<pre><code>&lt;%-- This is JSP comment --%&gt;
</code></pre></li>
<li><p>JSP指令</p>
<pre><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;
</code></pre><p>有三种类型的指令标记：</p>
<pre><code>&lt;%@ page ... %&gt;&lt;!--定义页面依赖属性，例如脚本语言，错误页面和缓冲的要求--&gt;
&lt;%@ include ... %&gt;&lt;!--包括在转换阶段的文件--&gt;
&lt;%@ taglib ... %&gt;&lt;!--声明了一个标签库，包含自定义动作，用在页面中--&gt;
</code></pre></li>
<li><p>JSP动作，JSP动作使用XML语法结构来控制Servlet引擎的行为。可以动态地插入文件，重用JavaBeans组件，用户转发到另一个页面，或为Java插件生成HTML。语法：</p>
<pre><code>&lt;jsp:action_name attribute=&quot;value&quot; /&gt;    
</code></pre></li>
<li>JSP隐式对象</li>
</ol>
<p>JSP支持九种自动定义的变量，这也被称为隐式对象。这些变量是：</p>
<ul>
<li>request：这是与请求相关联的HttpServletRequest对象</li>
<li>response：这是用于响应客户端相关联的HttpServletResponse对象</li>
<li>out：这是用于将输出发送给客户端的PrintWriter对象</li>
<li>session：这是与请求相关联的HttpSession对象</li>
<li>application：这是应用程序上下文关联的ServletContext对象</li>
<li>config：这是与页面关联的ServletConfig对象</li>
<li>pageContext：这封装采用类似更高的性能JspWriters服务器特定的功能</li>
<li>page：这是一个简单的代名词，是用来调用由转换servlet类中定义的方法</li>
<li>Exception：Exception对象允许例外的数据由JSP指定访问</li>
</ul>
<h2 id="JSP对象的范围"><a href="#JSP对象的范围" class="headerlink" title="JSP对象的范围"></a>JSP对象的范围</h2><ul>
<li>page范围：使用此JSP对象可以在其中创建的页面内使用。</li>
<li>Request 范围：使用该JSP对象可以在请求服务任何地方使用。</li>
<li>Session 范围:使用该JSP的对象可用于在属于同一个会话页面。</li>
<li>Application 范围：使用该JSP的对象可以在整个应用程序页面中使用。</li>
</ul>
<h2 id="JSP中使用Javabean"><a href="#JSP中使用Javabean" class="headerlink" title="JSP中使用Javabean"></a>JSP中使用Javabean</h2><p>嵌入一个Java bean到JSP网页，有三个基本动作或标签：<jsp:usebean>, <jsp:setproperty>, <jsp:getproperty></jsp:getproperty></jsp:setproperty></jsp:usebean></p>
<ul>
<li><jsp:usebean>：这个标签是用来给bean指定“id”和“scope”属性相关联。</jsp:usebean></li>
<li><jsp:setproperty>：这个标签被用于设置一个beans属性的值，主要使用“name”属性已经定义的Javabean对象的ID。其他属性是 “property”, “param”, “value”</jsp:setproperty></li>
<li><jsp:getproperty>：个标签是用来获取引用Bean实例属性并将其存储到隐式out对象。</jsp:getproperty></li>
</ul>
<p>bean的规则：</p>
<ul>
<li>包应该是java bean的第一行</li>
<li>Bean应该有一个空的构造</li>
<li>所有的bean中的变量应该设置有“get”，“set”方法。</li>
<li>属性名应以大写字母开头在使用“set”，“get”方法时。</li>
<li>例如变量“名称”的get，set方法就是getName(), setName(String)</li>
<li>设置方法应该返回像一个空(void)值： “return void()”</li>
</ul>
<h2 id="JSP的运行机制"><a href="#JSP的运行机制" class="headerlink" title="JSP的运行机制"></a>JSP的运行机制</h2><center><img src="http://www.blogjava.net/images/blogjava_net/fancydeepin/myself/jsp.png" alt=""></center>

<ol>
<li>当客户端浏览器向服务器请求一个 JSP 页面时，服务器收到该请求后，首先检查所请求的这个JSP 文件内容 ( 代码 ) 是否已经被更新，或者是否是 JSP 文件创建后的第一次被访问</li>
<li>如果是，那么，这个 JSP 文件就会在服务器端的 JSP 引擎作用下转化为一个 Servlet 类的 Java 源代码文件。紧接着，这个 Servlet 类会在 Java 编译器的作用下被编译成一个字节码文件，并装载到 jvm 解释执行。剩下的就等同于 Servlet 的处理过程了。</li>
<li>如果被请求的 JSP 文件内容 ( 代码 ) 没有被修改，那么它的处理过程也等同于一个 Servlet 的处理过程。即直接由服务器检索出与之对应的 Servlet 实例来处理。</li>
</ol>
<p><em>注：JSP 文件不是在服务器启动的时候转换成 Servlet 类的。而是在被客户端访问的时候才可能发生转换的 ( 如 JSP 文件内容没有被更新等，就不再发生 Servlet 转换 )。</em><br>对Tomcat而言，打开目录 %Tomcat%/work/%您的工程文件目录%，在里面会有一个子目录：org/apache/jsp，如果没有这个目录，说明项目的JSP文件还没有被访问过。如果有该目录，进入其中会发现一些<em>_jsp.java 和 </em>_jsp.class 文件，这就是 JSP 文件被转换成Servlet 类的源文件和字节码文件了。</p>
<h1 id="java中一些很少用到特性"><a href="#java中一些很少用到特性" class="headerlink" title="java中一些很少用到特性"></a>java中一些很少用到特性</h1><ol>
<li>import static,静态导入</li>
</ol>
<p>import static（静态导入）是JDK1.5中的新特性，一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.<em>;这里多了个static，还有就是类名ClassName后面多了个 .</em> ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名的方式来调用。</p>
<h1 id="路径的特殊处理"><a href="#路径的特殊处理" class="headerlink" title="路径的特殊处理"></a>路径的特殊处理</h1><pre><code>URL url = this.getClass().getClassLoader().getResource(&quot;/&quot;)
</code></pre><p>上面这行代码会获取class目录的路径，如果其所在目录中含有空格等字符，导致通过如下方式</p>
<pre><code>File dir = new File(url.getFile());
</code></pre><p>获取不了class目录。</p>
<p>解决方法：</p>
<pre><code>File dir = new File(URLDecoder.decode(url.getFile(),&quot;utf-8&quot;));
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;web-xml的作用&quot;&gt;&lt;a href=&quot;#web-xml的作用&quot; class=&quot;headerlink&quot; title=&quot;web.xml的作用&quot;&gt;&lt;/a&gt;web.xml的作用&lt;/h1&gt;&lt;p&gt;web.xml文件并不是web工程必须的，只有你需要配置欢迎页、servle
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JNDI介绍</title>
    <link href="http://yoursite.com/2018/01/01/JNDI%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/01/01/JNDI介绍/</id>
    <published>2018-01-01T06:16:00.000Z</published>
    <updated>2018-01-01T07:05:37.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JNDI简介"><a href="#JNDI简介" class="headerlink" title="JNDI简介"></a>JNDI简介</h1><p>JNDI(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。是一种应用程序设计标准和规范，现在JNDI已经成为J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI的服务。为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上</p>
<ol>
<li>命名服务将名称和对象联系起来，使得我们可以用名称访问对象。</li>
<li>目录服务是一种命名服务，在这种服务里，对象不但有名称，还有属性。也就是说目录服务是一种特殊的命名服务。</li>
</ol>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><ol>
<li>JNDI API提供了一种统一的方式，可以在本地或网络上查找和访问服务。各种服务在命名服务器上注册一个名称，需要使用服务的应用程序通过JNDI找到对应服务就可以使用。</li>
<li>远程服务可以是任何的企业服务。DNS、LDAP(Lightweight Directory AccessProtocol 轻型目录访问协议)、 CORBA对象服务、数据源对象，文件系统、WindowsXP/2000/NT/Me/9x的注册表、RMI、EJB、JMS……</li>
<li>JNDI主要有两部分组成：应用程序编程接口和服务供应商接口。a) 应用程序编程接口提供了Java应用程序访问各种命名和目录服务的功能(API).b)服务供应商接口为任意一种服务的服务供应商(SPI:service provider interface)提供了使用JNDI的功能</li>
</ol>
<h1 id="JDBC与JNDI"><a href="#JDBC与JNDI" class="headerlink" title="JDBC与JNDI"></a>JDBC与JNDI</h1><p>JNDI通过注册能操作数据库的服务（如JDBC）就可以实现同JDBC相同的功能。</p>
<ol>
<li>JNDI：可以获得访问数据相关的对象，从而操作数据。本地不需要驱动，也不需要知道数据在哪里，所有需要访问数据库的都可以用。</li>
<li>JDBC：本地有驱动程序，知道数据在哪里，只有一个应用程序能用。</li>
</ol>
<h2 id="JNDI中的数据访问"><a href="#JNDI中的数据访问" class="headerlink" title="JNDI中的数据访问"></a>JNDI中的数据访问</h2><ol>
<li>驱动代码的加载由服务提供方负责</li>
<li>应用程序需要URL找到指定的服务</li>
<li>JNDI  API使应用程序可以通过逻辑名称获得指定的数据源</li>
<li>JNDI  API提供数据库源服务需要以下内容<br>a. 与数据源关联的数据库驱动程序<br>b. 数据源对象的引用名称<h2 id="JDBC访问数据库"><a href="#JDBC访问数据库" class="headerlink" title="JDBC访问数据库"></a>JDBC访问数据库</h2></li>
<li>javax.sql.DataSource接口是在Java程序设计时使用JNDI获得数据库连接的工具</li>
<li>用程序使用JNDI通过注册名称获得的就是DataSource实现类对象</li>
<li>通过DataSource实现类对象可以获得数据库连接对象(Connection)：所有需要访问数据库的应用程序都可以使用此服务，所以需要同时返回多个连接对象—连接池</li>
<li>由驱动程序供应商实现：实现DataSource接口的对象在基于JNDI  API的命名服务中注册后，应用程序就可以通过JNDI获得相关对象，从而访问数据库服务器。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDBC与JNDI：使用JDBC创建一个访问数据库的对象，此对象在JNDI服务器中注册一个逻辑名称，通过JNDI查找到该名称就可以获得相关对象。使得多个应用程序都可以访问数据库。</p>
<p>JNDI能注册各种各样可用的服务，使用JDBC实现的数据访问服务是其中之一</p>
]]></content>
    
    <summary type="html">
    
      JNDI是一种服务标准，定义的怎么使用服务和怎么提供服务，当然这里的使用服务一般来说是java应用程序
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日志系统</title>
    <link href="http://yoursite.com/2017/12/31/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/12/31/日志系统/</id>
    <published>2017-12-31T13:02:45.000Z</published>
    <updated>2017-12-31T14:05:15.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="slf4j-api、slf4j-log4j12以及log4j之间什么关系？"><a href="#slf4j-api、slf4j-log4j12以及log4j之间什么关系？" class="headerlink" title="slf4j-api、slf4j-log4j12以及log4j之间什么关系？"></a>slf4j-api、slf4j-log4j12以及log4j之间什么关系？</h1><p><code>slf4j:Simple Logging Facade for Java</code>，为java提供的简单日志Facade。Facade：门面，更底层一点说就是接口。他允许用户以自己的喜好，在工程中通过slf4j接入不同的日志系统。更直观一点，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。</p>
<p>因此，slf4j入口就是众多接口的集合，他不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。查看slf4j-api源码就可以发现，里面除了public final class LoggerFactory类之外，都是接口定义。因此，slf4j-api本质就是一个接口定义。</p>
<p>一句话总结：slf4j提供接口，各个日志系统或框架实现这些接口。好处是统一了日志系统的管理</p>
<center><img src="http://img.my.csdn.net/uploads/201211/18/1353244238_7191.png" alt="三者之间的关系">     </center>

<p>说明：</p>
<ol>
<li>以slf4j-api作为应用的日志入口</li>
<li>在应用编译的时候slf4j-api中public final class LoggerFactor类中的private final static void bind() 方法会寻找具体的日志实现类绑定，主要是通过StaticLoggerBinder.getSingleton();的语句调用。</li>
<li>slf4j-log4j12作为链接slf4j-api和log4j中间的适配器。它实现了slf4j-api中的StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法</li>
<li>log4j:这个是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。</li>
</ol>
<h1 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h1><p> LogBack 作为一个通用可靠、快速灵活的日志框架，将作为Log4j 的替代和SLF4J 组成新的日志系统的完整实现。官网上称具有极佳的性能，在关键路径上执行速度是log4j 的10 倍，且内存消耗更少。</p>
<h1 id="别的常见的日志方案"><a href="#别的常见的日志方案" class="headerlink" title="别的常见的日志方案"></a>别的常见的日志方案</h1><p>commons-logging+log4j。commons-logging类似于slf4j（slf4j-api）的作用。提供统一的日志接口</p>
]]></content>
    
    <summary type="html">
    
      理清在pom文件中引入的各个与日志相关的包的关系
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git 常用命令总结</title>
    <link href="http://yoursite.com/2017/12/10/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/10/git-常用命令总结/</id>
    <published>2017-12-10T09:07:03.000Z</published>
    <updated>2017-12-10T09:14:13.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="设置换行符转换"><a href="#设置换行符转换" class="headerlink" title="设置换行符转换"></a>设置换行符转换</h2><p>由于不同操作系统的换行符不同，因此如果本地使用window开发，而远程仓库是Linux系统，导致提交不成功。</p>
<h2 id="1-不同操作系统的换行符"><a href="#1-不同操作系统的换行符" class="headerlink" title="1. 不同操作系统的换行符"></a>1. 不同操作系统的换行符</h2><ul>
<li>CR回车 LF换行</li>
<li>Windows/Dos CRLF \r\n</li>
<li>Linux/Unix LF \n</li>
<li>MacOS CR \r</li>
</ul>
<h2 id="2-解决换行符不一致的设置方式"><a href="#2-解决换行符不一致的设置方式" class="headerlink" title="2. 解决换行符不一致的设置方式"></a>2. 解决换行符不一致的设置方式</h2><ul>
<li>提交时转换为LF，检出时转换为CRLF：git config –global core.autocrlf true</li>
<li>提交时转换为LF，检出时不转换：git config –global core.autocrlf input</li>
<li>提交检出均不转换：git config –global core.autocrlf false</li>
<li>拒绝提交包含混合换行符的文件：git config –global core.safecrlf true</li>
<li>允许提交包含混合换行符的文件：git config –global core.safecrlf false</li>
<li>提交包含混合换行符的文件时给出警告：git config –global core.safecrlf warn</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;h2 id=&quot;设置换行符转换&quot;&gt;&lt;a href=&quot;#设置换行符转换&quot; class=&quot;headerlink&quot; title=&quot;设置换行符转换&quot;&gt;&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>eclipse下javaweb 开发环境搭建</title>
    <link href="http://yoursite.com/2017/12/10/eclipse%E4%B8%8BJava%20Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/12/10/eclipse下Java Web开发环境搭建/</id>
    <published>2017-12-10T03:54:47.000Z</published>
    <updated>2017-12-10T10:36:01.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eclipse安装"><a href="#eclipse安装" class="headerlink" title="eclipse安装"></a>eclipse安装</h1><h1 id="Tomcat安装配置"><a href="#Tomcat安装配置" class="headerlink" title="Tomcat安装配置"></a>Tomcat安装配置</h1><ol>
<li><a href="https://tomcat.apache.org/" target="_blank" rel="external">下载</a>需要的版本</li>
<li>解压</li>
<li>启动，进入/bin目录双击startup.bat，启动后通过在浏览器输入<a href="http://localhost:8080访问Tomcat首页，如果启动成功，就会打开Tomcat首页" target="_blank" rel="external">http://localhost:8080访问Tomcat首页，如果启动成功，就会打开Tomcat首页</a></li>
<li>配置环境变量</li>
<li>给eclipse添加本地Tomcat，window-&gt;preferences-&gt;Server-&gt;Runtime Environment。如果eclipse不支持高版本的Tomcat，可以把高版本的Tomcat伪造为eclipse支持的Tomcat。把高版本的Tomcat伪造为低版本的Tomcat：1. <a href="https://www.zhihu.com/question/37809905" target="_blank" rel="external">参考</a>；2. 安装Eclipse Tomcat Plugin</li>
</ol>
<h1 id="Maven安装配置"><a href="#Maven安装配置" class="headerlink" title="Maven安装配置"></a>Maven安装配置</h1><ol>
<li><a href="http://maven.apache.org/" target="_blank" rel="external">下载</a>需要的版本</li>
<li>解压</li>
<li>配置环境变量</li>
<li>检查安装是否成功：命令行输入mvn -version,看到Maven home字样，说明安装成功。</li>
<li>配置：在config/settings.xml中配置本地库目录<code>&lt;localRepository&gt;D:\Software App\Java\Maven\mvn_repository&lt;/localRepository&gt;</code> settings.xml文件是用来设置maven的，对maven的配置基本上都是在这个文件中完成。<br>6.</li>
</ol>
<h2 id="maven功能简介"><a href="#maven功能简介" class="headerlink" title="maven功能简介"></a>maven功能简介</h2><h2 id="maven基本命令"><a href="#maven基本命令" class="headerlink" title="maven基本命令"></a>maven基本命令</h2><h1 id="创建webApp项目"><a href="#创建webApp项目" class="headerlink" title="创建webApp项目"></a>创建webApp项目</h1><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><ol>
<li>右键-&gt;new-&gt;other,找到maven,选择maven project-&gt;next。</li>
<li>选择maven-archetype-webapp后，点击next,注意,可以在filter中先输入webapp,这样就能快速找到maven-archetype-webapp选项,如果此时列出来的选择项仍然很多,就盯着version看,找version是release的。</li>
<li>输入groupid,artifact id和packgage,点击finish,然后耐心等待,第一次新建maven会有很多依赖包要下载,所以会比较慢.取决于你的网速和电脑配置。</li>
<li>创建中的注意事项：groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。artifactId设置为项目名称依照这个设置，你的包结构最好是（域.公司名称.项目名称）打头的.当然你的package可以不是这个,也可以自由输入,输入后你新建的项目默认就会有对应的包。</li>
<li>如果项目中的内容未报错，但项目文件夹上有错误，很可能是项目依赖的jdk版本与settings.xml文件中的java版本不同。只需要把settings.xml文件中java版本改为与eclipse引用的java版本相同即可。</li>
<li>eclipse中使用maven创建项目JDK版本默认是1.5解决方法：1. 修改maven的settings.xml文件。添加以下行，jdk版本改为自己需要的版本：<br>` <profile><br> <id>jdk-1.7</id><br> <activation>  <pre><code>&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  
&lt;jdk&gt;1.7&lt;/jdk&gt;  
</code></pre> </activation><br> <properties>  <pre><code>&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;  
&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  
&lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt;  
</code></pre> </properties><br></profile>`<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><a href="https://www.cnblogs.com/NieXiaoHui/p/5990570.html" target="_blank" rel="external">参考</a></li>
</ol>
<h1 id="MySql安装配置"><a href="#MySql安装配置" class="headerlink" title="MySql安装配置"></a>MySql安装配置</h1><ol>
<li><a href="https://dev.mysql.com/downloads/windows/installer/" target="_blank" rel="external">下载</a>，Windows下只有32位的安装包</li>
<li>安装，与普通软件的安装并没有区别</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eclipse安装&quot;&gt;&lt;a href=&quot;#eclipse安装&quot; class=&quot;headerlink&quot; title=&quot;eclipse安装&quot;&gt;&lt;/a&gt;eclipse安装&lt;/h1&gt;&lt;h1 id=&quot;Tomcat安装配置&quot;&gt;&lt;a href=&quot;#Tomcat安装配置&quot; cla
    
    </summary>
    
    
  </entry>
  
</feed>
