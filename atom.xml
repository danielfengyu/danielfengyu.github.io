<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山间听雨者主页</title>
  <subtitle>个人学习总结</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-31T13:02:45.190Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Daniel</name>
    <email>fengyu153610@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志系统</title>
    <link href="http://yoursite.com/2017/12/31/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/12/31/日志系统/</id>
    <published>2017-12-31T13:02:45.000Z</published>
    <updated>2017-12-31T13:02:45.190Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/12/30/Jms%E5%AD%A6%E4%B9%A0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2017/12/30/Jms学习遇到的坑/</id>
    <published>2017-12-30T02:45:02.134Z</published>
    <updated>2017-12-31T13:38:51.015Z</updated>
    
    <content type="html"><![CDATA[<p>﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿—<br>title: Jms学习遇到的坑<br>date: 2017-12-30 18:48:09<br>categories: 学习<br>tags: 工具类学习</p>
<h2 id="description-Jms学习"><a href="#description-Jms学习" class="headerlink" title="description: Jms学习"></a>description: Jms学习</h2><h1 id="JMS使用中遇到的问题"><a href="#JMS使用中遇到的问题" class="headerlink" title="JMS使用中遇到的问题"></a>JMS使用中遇到的问题</h1><h2 id="使用spring的消息转换器时提示的安全问题"><a href="#使用spring的消息转换器时提示的安全问题" class="headerlink" title="使用spring的消息转换器时提示的安全问题"></a>使用spring的消息转换器时提示的安全问题</h2><p>自定义了一个普通的java对象Email,希望通过spring提供的消息对象转换器把其转为对应的jms消息对象，但在转发消息时候出现如下日志提示的错误。</p>
<p>错误日志：</p>
<p><code>Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class com.daniel.study.jms.model.Email! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.</code></p>
<p>导致的原因是在5.12.2 and 5.13.0版本后为了传输的对象是安全的，强制要求用户指定需要传输的对象所在的包（package），只有在指定的包下的类的对象才能使用ObjectMessage进行安全转换，也就是要指定能进行转换的对象的类所在包作为一个白名单。有两种配置白名单的方式：</p>
<ol>
<li>客户端配置，该方式是在5.12.2和5.13.1及之后的版本中提供的配置方式，这种方式是常用的。</li>
</ol>
<p>Spring配置文件中配置，配置方式如下：</p>
<pre><code>&lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;  
        &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;
        &lt;!-- 指定可以通过ObjectMessage进行安全转换的对象的类所在的包 --&gt;
        &lt;property name=&quot;trustedPackages&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;com.daniel.study.jms.model&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;  
&lt;/bean&gt;
</code></pre><p>或</p>
<pre><code>&lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;  
        &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;
        &lt;property name=&quot;trustAllPackages&quot; value=&quot;true&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>如上的配置就是把com.daniel.study.jms.model下的所有类都加入白名单，在该白名单下的类的对象都是可以通过spring提供的转换器进行转换的。<a href="http://activemq.apache.org/objectmessage.html" target="_blank" rel="external">参考</a></p>
<p>java代码中设置：</p>
<pre><code>ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);
factory.setTrustedPackages(new ArrayList(Arrays.asList(&quot;org.apache.activemq.test,org.apache.camel.test&quot;.split(&quot;,&quot;))));
</code></pre><p>或者</p>
<pre><code>ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);
factory.setTrustAllPackages(true);
</code></pre><ol>
<li>还可以在服务端（activeMq broker）中进行配置，这种方式的配置开始于activeMq的5.12.2和5.13.0版本，在${ACTIVEMQ_HOME}/bin/env中配置activeMq的系统属性ACTIVEMQ_OPTS：</li>
</ol>
<pre><code>Dorg.apache.activemq.SERIALIZABLE_PACKAGES=java.lang,javax.security,java.util,org.apache.activemq,org.fusesource.hawtbuf,com.thoughtworks.xstream.mapper,com.daniel.study.jms.model
</code></pre><p>或</p>
<pre><code>-Dorg.apache.activemq.SERIALIZABLE_PACKAGES=*`
</code></pre><p>如上的设置，其中com.daniel.study.jms.model是加入白名单的包，对于broker的，其余的包默认是必须的。</p>
<h1 id="JMS事务管理之JNDI数据源配置"><a href="#JMS事务管理之JNDI数据源配置" class="headerlink" title="JMS事务管理之JNDI数据源配置"></a>JMS事务管理之JNDI数据源配置</h1><h2 id="Tomcat容器"><a href="#Tomcat容器" class="headerlink" title="Tomcat容器"></a>Tomcat容器</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿—&lt;br&gt;title: Jms学习遇到的坑&lt;br&gt;date: 2017-12-30 18:48:09&lt;br&gt;categories: 学习&lt;br&gt;tags: 工具类学习&lt;/p&gt;
&lt;h2 id=&quot;descriptio
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git 常用命令总结</title>
    <link href="http://yoursite.com/2017/12/10/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/10/git-常用命令总结/</id>
    <published>2017-12-10T09:07:03.000Z</published>
    <updated>2017-12-10T09:14:13.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="设置换行符转换"><a href="#设置换行符转换" class="headerlink" title="设置换行符转换"></a>设置换行符转换</h2><p>由于不同操作系统的换行符不同，因此如果本地使用window开发，而远程仓库是Linux系统，导致提交不成功。</p>
<h2 id="1-不同操作系统的换行符"><a href="#1-不同操作系统的换行符" class="headerlink" title="1. 不同操作系统的换行符"></a>1. 不同操作系统的换行符</h2><ul>
<li>CR回车 LF换行</li>
<li>Windows/Dos CRLF \r\n</li>
<li>Linux/Unix LF \n</li>
<li>MacOS CR \r</li>
</ul>
<h2 id="2-解决换行符不一致的设置方式"><a href="#2-解决换行符不一致的设置方式" class="headerlink" title="2. 解决换行符不一致的设置方式"></a>2. 解决换行符不一致的设置方式</h2><ul>
<li>提交时转换为LF，检出时转换为CRLF：git config –global core.autocrlf true</li>
<li>提交时转换为LF，检出时不转换：git config –global core.autocrlf input</li>
<li>提交检出均不转换：git config –global core.autocrlf false</li>
<li>拒绝提交包含混合换行符的文件：git config –global core.safecrlf true</li>
<li>允许提交包含混合换行符的文件：git config –global core.safecrlf false</li>
<li>提交包含混合换行符的文件时给出警告：git config –global core.safecrlf warn</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;h2 id=&quot;设置换行符转换&quot;&gt;&lt;a href=&quot;#设置换行符转换&quot; class=&quot;headerlink&quot; title=&quot;设置换行符转换&quot;&gt;&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>eclipse下javaweb 开发环境搭建</title>
    <link href="http://yoursite.com/2017/12/10/eclipse%E4%B8%8BJava%20Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/12/10/eclipse下Java Web开发环境搭建/</id>
    <published>2017-12-10T03:54:47.000Z</published>
    <updated>2017-12-10T10:36:01.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eclipse安装"><a href="#eclipse安装" class="headerlink" title="eclipse安装"></a>eclipse安装</h1><h1 id="Tomcat安装配置"><a href="#Tomcat安装配置" class="headerlink" title="Tomcat安装配置"></a>Tomcat安装配置</h1><ol>
<li><a href="https://tomcat.apache.org/" target="_blank" rel="external">下载</a>需要的版本</li>
<li>解压</li>
<li>启动，进入/bin目录双击startup.bat，启动后通过在浏览器输入<a href="http://localhost:8080访问Tomcat首页，如果启动成功，就会打开Tomcat首页" target="_blank" rel="external">http://localhost:8080访问Tomcat首页，如果启动成功，就会打开Tomcat首页</a></li>
<li>配置环境变量</li>
<li>给eclipse添加本地Tomcat，window-&gt;preferences-&gt;Server-&gt;Runtime Environment。如果eclipse不支持高版本的Tomcat，可以把高版本的Tomcat伪造为eclipse支持的Tomcat。把高版本的Tomcat伪造为低版本的Tomcat：1. <a href="https://www.zhihu.com/question/37809905" target="_blank" rel="external">参考</a>；2. 安装Eclipse Tomcat Plugin</li>
</ol>
<h1 id="Maven安装配置"><a href="#Maven安装配置" class="headerlink" title="Maven安装配置"></a>Maven安装配置</h1><ol>
<li><a href="http://maven.apache.org/" target="_blank" rel="external">下载</a>需要的版本</li>
<li>解压</li>
<li>配置环境变量</li>
<li>检查安装是否成功：命令行输入mvn -version,看到Maven home字样，说明安装成功。</li>
<li>配置：在config/settings.xml中配置本地库目录<code>&lt;localRepository&gt;D:\Software App\Java\Maven\mvn_repository&lt;/localRepository&gt;</code> settings.xml文件是用来设置maven的，对maven的配置基本上都是在这个文件中完成。<br>6.</li>
</ol>
<h2 id="maven功能简介"><a href="#maven功能简介" class="headerlink" title="maven功能简介"></a>maven功能简介</h2><h2 id="maven基本命令"><a href="#maven基本命令" class="headerlink" title="maven基本命令"></a>maven基本命令</h2><h1 id="创建webApp项目"><a href="#创建webApp项目" class="headerlink" title="创建webApp项目"></a>创建webApp项目</h1><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><ol>
<li>右键-&gt;new-&gt;other,找到maven,选择maven project-&gt;next。</li>
<li>选择maven-archetype-webapp后，点击next,注意,可以在filter中先输入webapp,这样就能快速找到maven-archetype-webapp选项,如果此时列出来的选择项仍然很多,就盯着version看,找version是release的。</li>
<li>输入groupid,artifact id和packgage,点击finish,然后耐心等待,第一次新建maven会有很多依赖包要下载,所以会比较慢.取决于你的网速和电脑配置。</li>
<li>创建中的注意事项：groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。artifactId设置为项目名称依照这个设置，你的包结构最好是（域.公司名称.项目名称）打头的.当然你的package可以不是这个,也可以自由输入,输入后你新建的项目默认就会有对应的包。</li>
<li>如果项目中的内容未报错，但项目文件夹上有错误，很可能是项目依赖的jdk版本与settings.xml文件中的java版本不同。只需要把settings.xml文件中java版本改为与eclipse引用的java版本相同即可。</li>
<li>eclipse中使用maven创建项目JDK版本默认是1.5解决方法：1. 修改maven的settings.xml文件。添加以下行，jdk版本改为自己需要的版本：<br>` <profile><br> <id>jdk-1.7</id><br> <activation>  <pre><code>&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  
&lt;jdk&gt;1.7&lt;/jdk&gt;  
</code></pre> </activation><br> <properties>  <pre><code>&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;  
&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  
&lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt;  
</code></pre> </properties><br></profile>`<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><a href="https://www.cnblogs.com/NieXiaoHui/p/5990570.html" target="_blank" rel="external">参考</a></li>
</ol>
<h1 id="MySql安装配置"><a href="#MySql安装配置" class="headerlink" title="MySql安装配置"></a>MySql安装配置</h1><ol>
<li><a href="https://dev.mysql.com/downloads/windows/installer/" target="_blank" rel="external">下载</a>，Windows下只有32位的安装包</li>
<li>安装，与普通软件的安装并没有区别</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eclipse安装&quot;&gt;&lt;a href=&quot;#eclipse安装&quot; class=&quot;headerlink&quot; title=&quot;eclipse安装&quot;&gt;&lt;/a&gt;eclipse安装&lt;/h1&gt;&lt;h1 id=&quot;Tomcat安装配置&quot;&gt;&lt;a href=&quot;#Tomcat安装配置&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/20/hello-world/"/>
    <id>http://yoursite.com/2017/10/20/hello-world/</id>
    <published>2017-10-20T12:49:03.277Z</published>
    <updated>2016-09-02T14:57:49.035Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jdk 源码阅读</title>
    <link href="http://yoursite.com/2017/08/30/jdk-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/30/jdk-源码阅读/</id>
    <published>2017-08-30T15:16:11.000Z</published>
    <updated>2017-08-30T15:42:15.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><ul>
<li>Java中一个Unicode字符占两个字节</li>
<li>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII<br>码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中<br>文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java中一个Unicode字符占两个字节&lt;/li&gt;
&lt;li&gt;UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="后端，Java" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习</title>
    <link href="http://yoursite.com/2017/08/06/Vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/08/06/Vue学习/</id>
    <published>2017-08-06T14:53:02.000Z</published>
    <updated>2017-08-06T14:58:52.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法"><a href="#在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法" class="headerlink" title="在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法"></a>在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法</h1><p>方法一、</p>
<p>npm install –save-dev font-awesome</p>
<p>在main.js里添加</p>
<p>import ‘font-awesome/css/font-awesome.css’</p>
<p>方法二、</p>
<p>在官网下载代码到本地，现在应该是font-awesome-4.7，把整个文件夹放到资源文件夹中，然后在index.html中加上：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/font-awesome-4.7/css/font-awesome.min.css&quot;&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      学习Vue中遇到的一些问题的解决方法
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://yoursite.com/2017/07/11/webpack-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/07/11/webpack-入门/</id>
    <published>2017-07-11T13:36:14.000Z</published>
    <updated>2017-07-11T13:56:20.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建第一个webpack的前端项目"><a href="#创建第一个webpack的前端项目" class="headerlink" title="创建第一个webpack的前端项目"></a>创建第一个webpack的前端项目</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>安装nodejs和npm（nodejs package managemer），新版本的nodejs都是自带npm的，安装完nodejs，默认就安装了npm，最好是把npm的包下载路径指向国内的镜像，方便下载。常用的有cnpm。</p>
<h2 id="初始化webpack前端工程"><a href="#初始化webpack前端工程" class="headerlink" title="初始化webpack前端工程"></a>初始化webpack前端工程</h2><ul>
<li>mkdir webpack-demo &amp; cd webpack-demo</li>
<li>npm init -y</li>
<li>npm install –save-dev webpack</li>
</ul>
<h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><ul>
<li>mkdir src</li>
<li>mkdir dist</li>
<li>在src目录下创建 index.js文件，其中的内容</li>
</ul>
]]></content>
    
    <summary type="html">
    
      webpack是前端代码的包管理工具，依赖管理工具，类似后端开发中的maven
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring Framework 指导文档</title>
    <link href="http://yoursite.com/2017/05/02/Spring-Framework-%E6%8C%87%E5%AF%BC%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/2017/05/02/Spring-Framework-指导文档/</id>
    <published>2017-05-02T14:15:58.000Z</published>
    <updated>2017-06-06T15:37:58.620Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring-依赖和依赖于Spring"><a href="#Spring-依赖和依赖于Spring" class="headerlink" title="Spring 依赖和依赖于Spring"></a>Spring 依赖和依赖于Spring</h4><p>尽管Spring为大量的企业和其他非Spring的工具提供集成和支持， 但Spring特意使依赖于它的应用尽可能的依赖一个绝对小的包集合：为了在一个小的用例中使用Spring，你不必搜索（定位）和下载大量的jar库文件。对于基本的依赖注入，只有一个强制的外部依赖，就是日志记录相关的依赖。<br>接下来我们即将概述配置一个依赖于Spring应用所必须的基本步骤，首先，通过maven配置，接着是通过gradle配置，最后是通过Ivy配置。在任何一种配置方式下，如果有不清楚的，参考你的依赖管理系统文档，或者查看一些样例的编码——Spring本身在构建的时候就是使用gradle管理依赖的，我们的样例大多也是是应用gradle和Maven来做依赖管理的。</p>
<h4 id="Maven-依赖管理"><a href="#Maven-依赖管理" class="headerlink" title="Maven 依赖管理"></a>Maven 依赖管理</h4><p>如果你使用的是maven做依赖管理，你甚至不必明确地提供日志相关的依赖，例如，为创建一个应用环境并使用依赖注入来配置一个应用，你的maven依赖如下：</p>
<p><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.0.0.M5&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></p>
<p>正如上面所示，注意，如果你不必依赖于Spring的API编译，那么可以通过<scope>声明为运行时依赖，这是一个典型的关于基本的依赖注入的用例。</scope></p>
<p>上述例子工作在Maven中心库上，为了使用Maven库，必须在maven的配置文件中指定库的位置。只依赖于所有的发布版本的配置：</p>
<p><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;io.spring.repo.maven.release&lt;/id&gt;
        &lt;url&gt;http://repo.spring.io/release/&lt;/url&gt;
        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></p>
<p>依赖于里程碑的配置：</p>
<p><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;io.spring.repo.maven.milestone&lt;/id&gt;
        &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt;
        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></p>
<p>依赖于快照的配置：</p>
<p><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;io.spring.repo.maven.snapshot&lt;/id&gt;
        &lt;url&gt;http://repo.spring.io/snapshot/&lt;/url&gt;
        &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></p>
<h4 id="Maven-依赖“材料清单”"><a href="#Maven-依赖“材料清单”" class="headerlink" title="Maven 依赖“材料清单”"></a>Maven 依赖“材料清单”</h4><p>在使用Maven的时候，可能不慎混合不同的Spring版本，例如，你会发现一个第三方库，或者另一个Spring工程，引入了一个传递依赖，并且该依赖还是一个较早的发行版本。如果你忘了明确的声明一个直接依赖，许多难以预料的问题会发生。</p>
<p>为了克服以上描述的问题，maven提供了一个材料清单（bill of materials，BOM）的概念，为了确保所有的Spring依赖（直接或者间接的）是同一个版本，你可以导入<code>spring-framework-bom</code>到你的<code>dependencyManagement</code>区中：</p>
<p><code>&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;5.0.0.M5&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></p>
<p>使用BOM增加的一个好处是，当依赖Spring框架产品时不必再指定<code>&lt;version&gt;</code>属性：</p>
<p>`<dependencies><br>    <dependency><br>        <groupid>org.springframework</groupid><br>        <artifactid>spring-context</artifactid><br>    </dependency><br>    <dependency><br>        <groupid>org.springframework</groupid><br>        <artifactid>spring-web</artifactid><br>    </dependency></dependencies></p>
<dependencies><code>#### Gradle依赖管理 ####
通过构建系统来使用Spring库，需要在</code>repositories<code>中包含恰当的URL：</code>repositories {<br>    mavenCentral()<br>    // and optionally…<br>    maven { url “<a href="http://repo.spring.io/release" target="_blank" rel="external">http://repo.spring.io/release</a>“ }<br>}<code>你可以根据需求改变</code>repositories<code>中URL的</code>/release<code>为</code>/milestone<code>，或者改变为</code>/snapshot<code>。一旦一个库已经被配置，你可以通过普通的gradle方法声明依赖，如:</code>dependencies{<br>    compile(“org.springframework:spring-context:5.0.0.M5”)<br>    testCompile(“org.springframework:spring-test:5.0.0.M5”)<br> }<code>#### Ivy 依赖管理 ####
如果你更喜欢使用Ivy管理依赖，也有相似的配置选择。配置Ivy指向Spring库（repository）,需增加如下的</code>resolver<code>到你的</code>ivysettings.xml<code>配置文件中：</code><resolvers><a href="ibiblioname=&quot;io.spring.repo.maven.release&quot;m2compatible=&quot;true&quot;root=&quot;http://repo.spring.io/release/&quot;/">ibiblioname=&quot;io.spring.repo.maven.release&quot;m2compatible=&quot;true&quot;root=&quot;http://repo.spring.io/release/&quot;/</a></resolvers><code>你也可以根据需要修改</code>root<code>URL中的</code>/release/<code>为</code>/milestone/<code>或</code>/snapshot/<code>。一旦配置完成，就可以使用通用的方式增加依赖了，例如（在ivy.xml中）：



        &lt;dependency org=&quot;org.springframework&quot; 
                    name=&quot;spring-core&quot; rev=&quot;5.0.0.M5&quot; conf=&quot;compile-&gt;runtime&quot;/&gt;

#### 发布zip文件 ####
尽管建议使用支持依赖管理的构建系统获取Spring Framework，但仍然可以下载发布的zip文件。

发布的zip文件也被提交到Spring Maven 库（这只是为了方便，你不必使用maven或者是其他的构建工具来下载他们）。

下载发布的zip文件，首先打开浏览器，输入 [http://repo.spring.io/release/org/springframework/spring]( http://repo.spring.io/release/org/springframework/spring)，并选择你想下载的版本对应的子文件夹。发布的文件以</code>-dist.zip<code>结尾，如 spring-framework-{spring-version}-RELEASE-dist.zip。发布文件也被提交到 [milestones](http://repo.spring.io/milestone/org/springframework/spring/) 和[snapshots](http://repo.spring.io/snapshot/org/springframework/spring/)。

#### 2.3.2 Logging ####
对于Spring来说logging是一个非常重要的依赖，因为：
a)它是唯一强制依赖的外部依赖
b)每个人都喜欢从他们使用的工具中输出些东西
c)Spring集成了许多其他的工具，这些工具都选择logging作为依赖。应用开发者的一个普遍目标是在一个中间位置使用一个作用于整个应用的统一logging配置，包括应用依赖的第三方组件，这也许是比较难的在有许多logging框架可供选择之前。

Spring强制依赖的logging框架是Jakarta Commons Logging API (JCL)。我们依赖JCL编译，我们也使JCL Log对象对于扩展自Spring Framework的classes是可见的。对于用户来说，重要的是所有的Spring版本都依赖于同一个logging库：因为向后兼容，所以好迁移，扩展自Spring的应用也是支持向后兼容的。为了支持向后兼容，我使Spring中的一个模块明确地依赖上</code>commons-logging<code>（JCL的标准实现），然后使所有的其他Spring模块在编译时期依赖于这个模块。举个例，如果你正在使用Maven，且不知道在哪里记录</code>commons-logging<code>的依赖，其实这个依赖来自Spring，更准确的说是来自Spring的核心模块</code>spring-core<code>。

关于</code>commons-logging<code>的一个好处是你不需要额外的库就能使你的应用正常运行，有一个运行时发掘算法，可以从classpath指定的地方寻找别的logging框架，并使用一个它认为合适的（或者你可以直接告诉这个算法你要使用哪一个）。如果没有可用的logging框架，你还可以使用JDK自带的logging框架（java.util.logging，JUL）。当你的Spring应用运行起来后，你应该会看到console窗口快速的输出大部分重要情况下的日志。
##### 不用 Common Loging #####
不幸的是，</code>commons-logging<code>中的运行时探查算法尽管方便了终端用户，但也是有问题的。回到之前，我们重新启动，Spring会使用一个不同的日志依赖。我们的首选可能是 Simple Logging Facade for Java ( 面向Java的简单日志管理，SLF4J),它也被用在人们使用的许多其他工具中，这些工具和Spring一起被使用在人们的应用中。

这有两种基础的方法来关闭</code>commons-logging<code>：
1. 从</code>spring-core<code>（因为它是唯一明确依赖</code>commons-logging<code>的模块）模块中排出</code>commons-logging<code>相关的依赖，

2. 依赖一个特殊的</code>commons-logging<code>依赖，该依赖被一个空的jar包替换（更多详情见 [SLF4J FAQ](https://www.slf4j.org/faq.html#excludingJCL)）。

为了排出</code>commons-logging<code>，增加如下内容到</code>dependencyManagement`标签中：<br><br>    <dependencies><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-core</artifactid><br>            <version>5.0.0.M5</version><br>            <exclusions><br>                <exclusion><br>                    <groupid>commons-logging</groupid><br>                    <artifactid>commons-logging</artifactid><br>                </exclusion><br>            </exclusions><br>        </dependency><br>    </dependencies>

<p>这时这个应用可能出现问题，因为在classpath中没有JCL API的实现，为了修复这个问题，需要提供一个新的实现。在下一节，我们将通过使用SLF4J作为例子，介绍怎么样提供一个可选择的JCL实现。</p>
<h5 id="使用SLF4J"><a href="#使用SLF4J" class="headerlink" title="使用SLF4J"></a>使用SLF4J</h5><p>比起<code>commons-logging</code>，SLF4J是一个更轻量的依赖，且在运行时更有效，因为它是在编译时期绑定，而别的集成日志框架是在运行时刻发现。这也就意味着你必须更加明确在运行期需要做什么，并因此声明，或者配置它。SLF4J给许多通用日志框架提供粘合剂，因此你通常可以选择一个你已经在使用的日志框架，并通过绑定到SLF4J上对它配置和管理。</p>
<p>SLF4J给许多通用日志框架提供粘合剂功能，配合JCL，它也可以做一些别致的事：把别的日志框架和它本身连接起来。因此为了在Spring中使用SLF4J，你必须用SLF4J-JCL替换<code>commons-logging</code>依赖。一旦你替换了<code>commons-logging</code>依赖，日志调用将由Spring内部转变为SLF4J API调用，所以如果在你的应用中别的库使用了<code>commons-logging</code>依赖，你都可以在一个单一地方配置和管理日志。</p>
<p>一个普遍的选择将有可能是在Spring和SLF4J中架起桥梁，在SLF4J和Log4j之间提供明确的绑定。你需要提供几种依赖（消除存在的<code>common-logging</code>依赖）：桥梁，SLF4J 实现Log4j，Log4j实现它自身，在Maven中，你可以想这样配置：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;5.0.0.M5&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
        &lt;version&gt;1.7.22&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>这看起来似乎有许多依赖，而且只是为了看到一些日志。对，就是如此，但这是可选的，而且考虑到类加载器的问题，尤其是在一个有限制的容器中，如OSGi平台，比起<code>common-logging</code>,上面的这种选择应该更好，综上，使用SLF4J-JCL有一个性能上的好处，因为它的绑定时在编译期，而不是运行期。</p>
<p>在SLF4J的用户中，一个更常见的选择是，直接绑定<a href="https://logback.qos.ch/" target="_blank" rel="external">Logback</a>,因为它使用较少的步骤和生成较少的依赖。Logback消除了额外的绑定步骤，因为它直接实现了SLF4J，因此你只需要绑定两个（<code>jcl-over-slf4j</code> 和<code>logback</code>）而不是四个库。如果你绑定的是Logback，你还需要消除来自其他依赖（不是Spring）的对slf4j-api的依赖，因为你需要确保在classpath中只依赖一个slf4j版本的API。</p>
<h5 id="Using-Log4j"><a href="#Using-Log4j" class="headerlink" title="Using Log4j"></a>Using Log4j</h5><p>Note：Log4j1.x已经不更新了，下面讲解的是Log4j2。</p>
<p>为了配置和管理的目的，许多人使用Log4j作为日志框架。Log4j是高效和稳定的，实际上它也正是我们在构建和测试Spring的运行时刻所使用的。Spring也提供了一些实用工具来配置和初始化Log4j，所以在Spring的一些模块中Log4j是一个可选择的编译时依赖。</p>
<p>为了并用Log4j和JCL，你所需要做的就是把Log4j加入classpath中，并为他提供一个配置文件（<code>log4j2.xml</code>,<code>log4j2.properties</code>,或者它支持的其他配置格式），对于Maven的使用者，最少的依赖配置是：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>如果你还希望使用SLF4J，如下的依赖是必要的：</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
    &lt;version&gt;2.7&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>这里有一个关于把日志定向到控制台的<code>log4j2.xml</code>配置例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;WARN&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;
    &lt;/Console&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Logger name=&quot;org.springframework.beans.factory&quot; level=&quot;DEBUG&quot;/&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Console&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre><h5 id="自带本地JCL的运行时容器"><a href="#自带本地JCL的运行时容器" class="headerlink" title="自带本地JCL的运行时容器"></a>自带本地JCL的运行时容器</h5><p>许多人在一个实现了JCL的的容器中运行他们的Spring应用。IBM的Websphere 应用服务器（WAS）就是一个这样的容器。这样的容器经常出现问题，不幸的是还没有一个好的解决方案；大部分情况下，只是简单的把<code>common-logging</code>从你的应用中排出是远远不够的。</p>
<p>必须清晰的认识到：问题的报告通常不是通过JCL的，甚至也不是通过<code>common-logging</code>，尽管他们把<code>common-logging</code>绑定到了其他的框架（通常是Log4j）上了。这个可能失败的原因为】是<code>common-logging</code>改变了他们上报的方式，在运行时刻发现在一些容器中使用较老的版本（1.0），然而现在许多人用的却是新的版本（1.1）。Spring不使用不通用的JCL API，因此在这里没有问题，但是一旦Spring或者你的应用尝试做一些日志操作，你可能会发现你所绑定的Log4j是不起作用的。</p>
<p>在这种情况下的 WAS ，最简单的事是反转类加载的层级（IBM称“parent last”），因此是应用控制了JCL的依赖，而不是容器。这种选择不总是可行的，但在公共领域有许多别的建议作为供选择的方法， 依赖正确的版本和容器的特性集合你的旅程可能会产生变化。</p>
<h1 id="二、核心技术"><a href="#二、核心技术" class="headerlink" title="二、核心技术"></a>二、核心技术</h1><p>这部分指导文档包含了所有的绝对完整的Spring Framework技术。</p>
<p>其中最重要的是Spring Framework的控制反转（IoC）容器。深入处理Spring Framework的IoC容器离不开Spring的面向切面编程（AOP）的技术，该技术是广泛应用的。spring Framework拥有自己的AOP框架，从概念上来说是比较简单的，在Java的企业级编程中成功的占据了AOP需求的80%的热点。</p>
<p>这部分内容也会涉及到Spring中集成的AspectJ（一种当前最完善，最成熟的企业级AOP实现的框架）</p>
<ul>
<li>第三章，IoC容器</li>
<li>第四章，资源</li>
<li>第五章，校验、数据绑定和类型转换</li>
<li>第六章，Spring表达式语言（SpEL）</li>
<li>第七章，Spring的面向切面编程</li>
<li>第八章，Spring AOP APIs</li>
</ul>
<h2 id="3-IoC容器"><a href="#3-IoC容器" class="headerlink" title="3. IoC容器"></a>3. IoC容器</h2><h3 id="3-1-Spring-IoC容器和Beans的介绍"><a href="#3-1-Spring-IoC容器和Beans的介绍" class="headerlink" title="3.1 Spring IoC容器和Beans的介绍"></a>3.1 Spring IoC容器和Beans的介绍</h3><p>本质涵盖Spring框架中控制反转规则的实现。IoC也以依赖注入而著称。依赖注入是一种对象凭借什么来定义他们的依赖的方法，依赖指的是对象能有效完成它的工作所借助的其他对象，这些依赖只有通过构造器的参数，工厂方法的参数，或是对象实体的属性来设置，这个对象实体或是被构造的，或是由工厂方法返回的。当容器创建bean的时候，它会注入bean的依赖。这种方式是反转的基础，之所以叫做控制反转（IoC）,是因为bean通过直接使用本身的类构造器，或者是像服务定位器模式的机制来控制实例，或是定位自身的依赖。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="external"><code>BeanFactory</code></a>接口提供一个高级的，能管理各种对象类型的配置机制。<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="external"><code>ApplicationContext</code></a>是一个<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="external"><code>BeanFactory</code></a>的子接口，<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="external"><code>ApplicationContext</code></a>增加了Spring AOP易集成的特性；甚至发布了消息，资源处理机制；特殊的应用层上下文，例如用于web应用中的<code>WebApplicationContext</code></p>
<p>总之，<code>BeanFactory</code>提供了配置框架和基本功能，ApplicationContext 增加了更多企业特征的功能。<code>ApplicationContext</code> 是<code>BeanFactory</code>的一个完全超级，因此在本章关于Spring IOC容器的说明中特意使用它。如果想了解更多的关于使用BeanFactory的信息， 请参考<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-beanfactory" target="_blank" rel="external">Section 3.16, “The BeanFactory”</a></p>
<p>在Spring中，各种对象构成了你的应用的主干，被Spring IOC容器管理的对象通常称为<em>beans</em>。一个bean要么是一个实例化的、组装好的对象，要么是一个被Spring IoC容器管理的对象。另外，在你的应用中，一个bean是众多对象中简单的一个。Beans和在他们中的依赖，被映射到容器使用的一个配置元数据中。</p>
<h3 id="3-2-容器概览"><a href="#3-2-容器概览" class="headerlink" title="3.2 容器概览"></a>3.2 容器概览</h3><p>接口<code>org.springframework.context.ApplicationContext</code>代表Spring IoC容器，它负责实例化、配置和组装前面提到的beans。容器通过读取配置元数据来获取关于实例化、配置和组装对象的说明。配置元数据通过XML文件、Java注解和Java代码来描述。配置元数据允许你表达组成你的应用的对象和这些对象之间的复杂关系。</p>
<p>Spring提供了几种开箱即用的<code>ApplicationContext</code>接口的实现。在一个单一的应用中，通常需要创建一个<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank" rel="external"><code>ClassPathXmlApplicationContext</code></a>或<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_blank" rel="external"><code>FileSystemXmlApplicationContext</code></a>。XML已经成为定义配置元数据的传统格式，你也可以通知容器使用Java注解或Java代码作为元数据的定义格式，这种方式只需要提供一个小的XML配置以说明可支持这中额外的元数据格式。</p>
<p>在许多的应用场景中，明确用户代码不必实例化一个或多个SpringIoC的容器的实例。例如，在一个web应用场景中，应用的web.xml文件中只需要简单八行web XML描述符通常就足够了。 (见 3.15.4节, “方便web应用上下文的实例化”)。如果你当前正在使用 <a href="https://spring.io/tools/sts" target="_blank" rel="external"><code>Spring Tool Suite</code></a>，一个加强版的Eclipse开发环境，这个样板配置文件只需简单地点击几次鼠标或是敲几次键盘就被创建。</p>
<p>下图是一个表示Spring怎样工作的高级视图。你的应用类与配置元数据相结合，因此，创建和初始化<code>ApplicationContext</code>之后，你就拥有了一个完全配置的、可运行的的系统或应用。</p>
<p><center><br><img src="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/images/container-magic.png.pagespeed.ce.-0JjaOG5As.png" alt="" title="Spring IoC容器"></center></p>
<p>图 3.1. Spring IoC容器<br></p>
<h4 id="3-2-1-配置元数据"><a href="#3-2-1-配置元数据" class="headerlink" title="3.2.1 配置元数据"></a>3.2.1 配置元数据</h4><p>正如之前的图所描述的一样，Spring IoC容器需要一个配置元数据。这个配置元数据描绘你作为一个应用开发者应该怎么告诉Spring容器在你的应用中去实例化、配置和组装对象。</p>
<p>传统第提供配置元数据的方式是通过一个简单的，直接明了的XML格式，这也是本章为了传达Spring IoC容器的关键概念和特征而使用得最多的方式。</p>
<p><em>注：基于XML的元数据并不是唯一的配置元数据格式。Spring IoC容器与配置元数据的实际书写格式毫无关系。并且进来，许多开发者为他们的Spring应用选择基于Java的配置</em>。</p>
<p>想要获取更多的关于在Spring容器中使用其他的元数据格式的信息，请查阅：</p>
<ul>
<li><p><a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-annotation-config" target="_blank" rel="external">基于注解的配置</a>：Spring2.5引进了注解对元数据配置的支持。</p>
</li>
<li><p><a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-java" target="_blank" rel="external">基于Java的配置</a>：从Spring3.0开始，Spring提供了许多特性来支持Java配置工程，这些特性还成为了核心Spring框架的一部分。那就是说，你可以使用Java而非XML文件来定义你的应用的类型的beans的外观。为了使用这些新特性，请查看 <code>@Configuration</code>,<code>@Bean</code>, <code>@Import</code> 和<code>@DependsOn</code> 注解.</p>
</li>
</ul>
<p>Spring配置由至少一个，但通常来说不止一个bean的定义组成，容器必须管理他们。基于XML的配置元数据以处于顶级元素<code>&lt;beans&gt;</code>中的<code>&lt;bean/&gt;</code>元素来表示这些bean的配置。Java配置通常使用@Bean注解@Configuration类中的方法。</p>
<p>这些bean定义符合组成应用的实际的对象。通常来说，你需定义服务层对象，数据访问层对象（DAOs）对象,诸如Struts <code>Action</code>实例这样的表示对象，和诸如Hibernate <code>SessionFactories</code>，JMS队列之类的底层对象。一般来说，在容器中，不必配置细粒度的领域对象，因为创建和加载领域对象通常是DAOs和业务逻辑的责任。然而，你可以使用Spring中集成的AspectJ来配置那些脱离IoC容器控制而创建的对象。查看<a href="ocs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#aop-atconfigurable">使用AspectJ和Spring一起依赖注入领域对象</a></p>
<p>如下展示了基于XML的配置元数据的基本结构：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;
</code></pre><p><code>id</code>属性是一个字符串，用来鉴别bean定义的唯一性；<code>class</code>属性定义了bean的类型，且使用的是全限定类名。id属性的值涉及到对象协作。在这个例子中，XML没有展现协作对象之间的引用；获取更多信息，请查看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-dependencies" target="_blank" rel="external">依赖</a></p>
<h4 id="3-2-2-实例化一个容器"><a href="#3-2-2-实例化一个容器" class="headerlink" title="3.2.2 实例化一个容器"></a>3.2.2 实例化一个容器</h4><p>实例化一个Spring IoC容器很简单，提供给ApplicationContext的构造器的位置路径（可以多个）就是实际的资源位置字符串，他们允许容器从一系列的外部资源，如本地文件系统，从Java <code>classpath</code>等加载配置元数据。</p>
<pre><code>ApplicationContext context =
    new ClassPathXmlApplicationContext(new String[] {&quot;services.xml&quot;, &quot;daos.xml&quot;});
</code></pre><p>注：在你了解了Spring IoC容器后，你也许想知道更多的关于Spring的<code>Resource</code>抽象，正如在第四章，资源中描述的一样，资源提供了方便的机制读取来自URI语法定义的位置的输入。尤其Resource路径被用来构建应用 上下文，正如<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources-app-ctx" target="_blank" rel="external">4.7节 应用上下文和资源路径</a>所描述的。</p>
<p>如下展示了服务层对象配置文件<code>（services.xml）</code>:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- services --&gt;

    &lt;bean id=&quot;petStore&quot; class=&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;
        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
        &lt;property name=&quot;itemDao&quot; ref=&quot;itemDao&quot;/&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for services go here --&gt;

&lt;/beans&gt;
</code></pre><p>如下展示了数据访问对象配置文件<code>（daos.xml）</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;accountDao&quot;
        class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;itemDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for data access objects go here --&gt;

&lt;/beans&gt;
</code></pre><p>之前的例子中，服务层由<code>PetStoreServiceImpl</code>类与<code>JpaAccountDao</code> 和<code>JpaItemDao</code>（基于JPA对象/关系映射标准）两个数据访问对象类型组成，<code>property name</code>元素引用Javabean的属性名字，<code>ref</code>元素引用另一个bean定义的名称。id和ref之间的链接了表达了协作对象之间的依赖。想了解一个对象的依赖的详细配置方式，查看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-dependencies" target="_blank" rel="external">依赖</a>。</p>
<h5 id="基于XML的配置元数据的组成"><a href="#基于XML的配置元数据的组成" class="headerlink" title="基于XML的配置元数据的组成"></a>基于XML的配置元数据的组成</h5><p>把bean的定义放到多个XML文件中是有用的。在你的架构中，常常每个独立的XML配置文件代表一个逻辑层或模块。</p>
<p>你可以使用应用上下文构造器来从所有这些XML片段中加载bean的定义。这个构造器提取多<code>Resource</code>位置，如前一节所示。作为一种选择，使用一个或多个<code>&lt;import/&gt;</code>元素来从别的文件加载bean定义，如：</p>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;services.xml&quot;/&gt;
    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;

    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;
    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>在前面的例子中，外部的bean定义加载自三个文件：<code>services.xml</code>, <code>messageSource.xml</code>, 和<code>themeSource.xml</code>。所有的位置路径与导入的定义文件相关，因此<code>services.xml</code>必须在完全一样的目录，或classpath位置中，正如文件中的导入活动。因此，<code>messageSource.xml</code> 和 <code>themeSource.xml</code>必须在一个<code>Resource</code>位置中，这个位置在导入文件的位置下。    如你所见，一个引导斜线被忽视了，但是如果加上了斜线，这些路径就是相对的，不使用斜线是更好的格式。一旦文件的内容被导入，包括最上层的<code>&lt;beans/&gt;</code>元素，都必须根据Spring的模式校验XMLbean的定义。</p>
<p>注：<em>使用相对路径（../）引用在父目录中的文件是可以的，但是不建议这样做。如果这样做了，就会创建一个不再当前应用中的文件的依赖。尤其，这个不建议用于“classpath：”URLs (例如, “classpath:../services.xml”),运行时的解决方法是选择“最近”的classpath的根目录，之后在它的父目录中搜寻。Classpath配置的改变会导致选择一个不同的错误的目录。</em></p>
<p><em>你可以总是资源的全限定位置而不是相对路径：如，”file:C:/config/services.xml” 或”classpath:/config/services.xml”。然而，你应该意识到你正在使你的应用的配置与特殊的绝对位置相耦合了。</em></p>
<p>import指令是beans命名空间本身提供的一个特征。超出了普通的bean定义的，更深层次的配置特征在一个选择的spring提供的XML命名空间中是可用的，如，“context”和“util”命名空间。</p>
<h5 id="Groovy的bean定义——DSL（领域专用语言）"><a href="#Groovy的bean定义——DSL（领域专用语言）" class="headerlink" title="Groovy的bean定义——DSL（领域专用语言）"></a>Groovy的bean定义——DSL（领域专用语言）</h5><p>作为一个具体的配置元数据的高级例子，bean定义也可以通过spring的Groovy的bean定义——DSL来表示，这可以通过Grails框架来了解。通常来说，这样的配置是配置在一个.groovy文件中的，其结构如下：</p>
<p>beans{<br>    dataSource(BasicDataSource) {<br>   driverClassName = “org.hsqldb.jdbcDriver”<br>url = “jdbc:hsqldb:mem:grailsDB”<br>username = “sa”<br>password = “”<br>settings = [mynew:”setting”]<br>}<br>sessionFactory(SessionFactory) {<br>dataSource = dataSource<br>}<br>myService(MyService) {<br>nestedBean = { AnotherBean bean -&gt;<br>dataSource = dataSource<br>}<br>}<br>}</p>
<p>这中配置的格式大部分等价于XMLbean定义，甚至支持spring的XML配置命名空间。通过一个“importBeans”指令，这种配置也允许导入XML bean定义文件。</p>
<h4 id="3-2-3-使用容器"><a href="#3-2-3-使用容器" class="headerlink" title="3.2.3 使用容器"></a>3.2.3 使用容器</h4><p><code>ApplicationContext</code>是一个高级工厂接口，并且有能力维护不同的beans的注册和他们的依赖。使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，可以检索你的bean的实体。</p>
<p><code>ApplicationContext</code>使你能够读取bean定义并使用他们，如下所示：</p>
<pre><code>// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);

// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();
</code></pre><p>使用Groovy的配置，引导程序看起来与上面非常相似，只是一个不同的上下文实现类，体现出Groovy（但也了解XML bean的定义）</p>
<pre><code>ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
</code></pre><p>结合阅读器代理，<code>GenericApplicationContext</code>成为最灵活多变的变体，例如与读取XML文件的<code>XmlBeanDefinitionReader</code>相结合：</p>
<pre><code>GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(ctx).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);
   context.refresh();
</code></pre><p>与读取Groovy文件的<code>GroovyBeanDefinitionReader</code>相结合：</p>
<pre><code>GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(ctx).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
   context.refresh();
</code></pre><p>如果需要，这些阅读器代理可以在同一个<code>ApplicationContext</code>上混合和配合使用，从不同的配置源读取bean定义。</p>
<p>之后你可以使用getBean检索bean的实体。<code>ApplicationContext</code>接口还有几个别的方法可以检索beans，理想的应用编码不应该使用它们。的确，你的应用编码不应该调用<code>getBean()</code>方法，从而你的应用一点都不依赖Spring APIs。例如，Spring与web框架的集成为了不同的web框架组件提供依赖注入，这些组件如controller和JSF管理beans,允许你声明通过元数据在特殊的bean上声明依赖（如，autowiring 注解）</p>
<h3 id="Bean概览"><a href="#Bean概览" class="headerlink" title="Bean概览"></a>Bean概览</h3><p>一个Spring IoC容器管理一个或多个beans。这些beans是通过提供给容器的配置元数据来创建的，如在XML<code>&lt;beans/&gt;</code>标签中定义的格式。</p>
<p>在容器中，这些bean定义被描述为<code>BeanDefinition</code>对象，这些对象包含（以及其他信息）如下的元数据</p>
<ul>
<li>一个包全限定类名：典型地实际实现类型</li>
<li>bean行为的配置元素，声明了bean在容器中应该有的行为（范围，声明周期回调等等）。</li>
<li>引用那些对当前bean工作来说是必要的bean，这些引用通常叫合作者或是依赖者。</li>
<li>别的设置在新创建的对象中的配置，如，使用在一个bean中的连接次数，可以用来管理连接池，或是限制一个连接池的大小。</li>
</ul>
<p>这些元数据翻译为一系列组成每个bean定义的属性。</p>
<p>表3.1. bean定义</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Explained in</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>Section 3.3.2, “Instantiating beans”</td>
</tr>
<tr>
<td>name</td>
<td>Section 3.3.1, “Naming beans”</td>
</tr>
<tr>
<td>scope</td>
<td>Section 3.5, “Bean scopes”</td>
</tr>
<tr>
<td>constructor arguments</td>
<td>Section 3.4.1, “Dependency Injection”</td>
</tr>
<tr>
<td>properties</td>
<td>Section 3.4.1, “Dependency Injection”</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>Section 3.4.5, “Autowiring collaborators”</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>Section 3.4.4, “Lazy-initialized beans”</td>
</tr>
<tr>
<td>initialization method</td>
<td>the section called “Initialization callbacks”</td>
</tr>
<tr>
<td>destruction method</td>
<td>the section called “Destruction callbacks”</td>
</tr>
</tbody>
</table>
<p><code>ApplicationContext</code> 的实现，除了bean定义外还包含关于如何创建一个特殊的bean的信息，也允许注册已存在的，用户在容器外面创建的对象。由返回工厂实现<code>DefaultListableBeanFactory</code>的<code>getBeanFactory()</code>方法访问ApplicationContext的Bean工厂来完成这个功能。凭借方法registerSingleton(..) 和 registerBeanDefinition(..)，<code>DefaultListableBeanFactory</code>支持注册。然而，有经过元数据定义的beans定义，典型的应用能独立工作。</p>
<p><em>注：Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding of existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to factory) is not officially supported and may lead to concurrent access exceptions and/or inconsistent state in the bean container</em>.</p>
<h4 id="命名-beans"><a href="#命名-beans" class="headerlink" title="命名 beans"></a>命名 beans</h4><p>每个bean都有一个或多个标识符。在持有bean的容器中，这些标识符必须是独一无二的。一个bean通常只有一个标识符，但如果需要多个标识符，额外的可以看做别名。</p>
<p>在基于XML的配置元数据中，使用<code>id</code>和/或<code>name</code>属性来指定bean标识符。<code>id</code>属性允许精确指定一个ID。按照惯例，这些名称是字母和数字的组合（’myBean’,’fooService’等），但也可以含有特殊字符。如果你想采用bean的别名，你可以在<code>name</code>属性中指定他们，并通过逗号（,），分号（；）或空格分隔。按历史的标记，在版本Spring3.1前，<code>id</code>属性被定义为<code>xsd:ID</code> 类型，它约束合理的字符。从3.1开始，<code>id</code>属性被定义为<code>xsd:string</code>类型。注意，尽管不再通过XML解析，但容器依然强制bean id独一无二的特性。</p>
<p>不要求你给bean提供一个名称或ID。如果没有明确的提供名称或ID，容器会给bean生成一个独一无二的名称。然而，如果你想通过名称引用bean，或通过使用<code>ref</code>元素或者<a href="">服务定位器</a>来查看bean,都必须提供一个名称。不给bean提供名称的动机是与使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-inner-beans" target="_blank" rel="external">内部bean</a>s和<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-autowire" target="_blank" rel="external">自动包装者</a></p>
<blockquote>
<p><strong>bean命名约定</strong></p>
<p>当命名beans时，约定就是使用标准的Java实例化域名称的约定，也就是bean名称以一个小写字符开始，之后按驼峰形式。这样的名称如<code>&#39;accountManager&#39;</code>, <code>&#39;accountService&#39;</code>, <code>&#39;userDao&#39;</code>, <code>&#39;loginController&#39;</code>等等。</p>
<p>命名beans时，一贯主张配置容易阅读和理解，如果你使用Spring AOP，这命名约定是很有帮助的，当通过名字应用通知到一系列的相关beans上时。</p>
</blockquote>
<p>注：通过组件扫描classpath，Spring会按如下规则为没有命名的组件生成bean名称：基本上是，获取简单的class名称，把第一个字母变为小写。然而在特殊的情况下，有超过一个字符且第一个和第二个字符都是大写，原始的方式就不起作用了。    这些规则与<code>java.beans.Introspector.decapitalize</code>（Spring在这里用到的）定义的规则是相同的。</p>
<h5 id="Aliasing-a-bean-outside-the-bean-definition"><a href="#Aliasing-a-bean-outside-the-bean-definition" class="headerlink" title="Aliasing a bean outside the bean definition"></a>Aliasing a bean outside the bean definition</h5><p>在bean的自定义中，可以提供多个名称给bean，通过使用一个组合决定一个名称，该名称由<code>id</code>属性和在<code>name</code>属性中任何数量的名称指定。这些名称可以等价于同一个bean的别名，且在许多情况下是有用的，比如，通过使用一个特殊的bean名称，允许在同一个应用中的每个组件引用一个共同的依赖。</p>
<p>然而，在bean被实际定义的地方指定所有的别名并不总是适合的，。有时为一个在其他地方定义的bean启用一个别名是值得的。这种情况在大型系统是常见的，这种系统中配置被分配到每个子系统，每个子系统都有它自己的一系列对象定义。在基于XML的配置元数据中，可以使用<alias>元素来完成别名的定义：</alias></p>
<pre><code>&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;
</code></pre><p>在这种情况下，在同一个容器，一个bean被命名为<code>fromName</code>，也许，在使用完这个别名定义后，又被<code>toName</code>引用。</p>
<p>例如，子系统A的配置元数据引用名称为<code>subsystemA-dataSource</code>的DataSource。子系统B的配置元数据引用名称为<code>subsystemB-dataSource</code>的DataSource。当使用这两个子系统来组合成一个主应用，且这个主应用引用名称为<code>myApp-dataSource</code>的DataSource。为了使这三个名称引用相同的对象，需要添加如下的别名定义到MyApp配置元数据：</p>
<pre><code>&lt;alias name=&quot;subsystemA-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;
&lt;alias name=&quot;subsystemA-dataSource&quot; alias=&quot;myApp-dataSource&quot; /&gt;
</code></pre><p>现在，每个组件和主应用都可以通过一个独立的（有效的创建一个命名空间），并且保证不与其他定义冲突的名称来引用dataSource，而且引用的是相同的bean。</p>
<blockquote>
<p><strong>Java 配置</strong></p>
<p>如果使用Java配置，@Bean注解可以用来提供别名，详情见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-java-bean-annotation" target="_blank" rel="external"> 3.12.3, “使用 @Bean 注解”</a>。</p>
</blockquote>
<h4 id="3-3-2-实例化bean"><a href="#3-3-2-实例化bean" class="headerlink" title="3.3.2 实例化bean"></a>3.3.2 实例化bean</h4><p>一个bean的定义本质上来说是一个创建一个或多个对象的食谱。当接收到请求，容器会查询食谱找到一个命名的bean，并使用被bean定义封装的配置元数据来创建一个实际的对象。</p>
<p>如果你使用的是基于XML的配置元数据，指定实例化在<code>&lt;bean/&gt;</code>元素中的<code>class</code>属性中的对象类型。这个class属性，内部是一个在<code>BeanDefinition</code> 实体上的Class属性，通常是强制的。（例子见，“<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method" target="_blank" rel="external">使用一个实例工厂方法实例化</a>”这节和 3.7 “<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-child-bean-definitions" target="_blank" rel="external">Bean定义的继承</a>”）。有一种或两种方法使用<code>Class</code>属性。</p>
<ul>
<li>典型地是为了指定构造bean的类，容器直接通过调用构造函数创建bean的情况，有点像使用Java代码的<code>new</code>操作。</li>
<li>为了指定包含用来创建对象的静态工厂方法的实际类类型，容器回调一个在类中的静态工厂方法来创建对象并不是常见的情况。</li>
</ul>
<blockquote>
<p><strong>内部类名称</strong>。如果你想为一个<code>static</code>的内部类（nested class）配置一个bean定义,你必须使用这个内部类的二元名称。</p>
<p>例如，如果你在<code>com.example</code>包中有一个名叫Foo的类,且在Foo中有一个<code>static</code>内部类叫Bar，那么一个bean定义中的<code>class</code>属性的值会是：</p>
<pre><code>com.example.Foo$Bar
</code></pre><p>注意在类名称中使用<code>$</code>字符来分隔内部类名称和外部类名称。</p>
</blockquote>
<h5 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h5><p>当通过构造方法来创建一个bean时，对所有正常的类都是可以的，并且与Sprin是兼容的。也就是说，开发的类（class）不必实现任何特殊的接口，或者以特殊的方式编码。简单地指定bean类就足够了。但是，根据你用什么类型的IoC来定义特殊bean，你也许需要一个默认的构造函数。</p>
<p>Spring IoC容器实质上能管理任何你想管理的类型；不限制管理真实的JavaBean。在容器中，大部分的Spring使用者更喜欢只有一个默认构造函数的和在内容之后有恰当的setter和getter模式的真实JavaBean。在容器中，你可能有更特殊的非bean风格的类。例如，如果你需要使用一个遗留下来的连接池，它绝对不遵循JavaBean规范，Spring也可以管理它。</p>
<p>通过基于XML的配置元数据，你可以照着下面指定你的bean:</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;

&lt;bean name=&quot;anotherExample&quot; class=&quot;examples.ExampleBeanTwo&quot;/&gt;
</code></pre><p>关于提供参数给构造函数和在对象被创建之后设置对象实体的内容的原理的详细信息，见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-collaborators" target="_blank" rel="external">注入依赖</a></p>
<h5 id="静态工厂方法实例化"><a href="#静态工厂方法实例化" class="headerlink" title="静态工厂方法实例化"></a>静态工厂方法实例化</h5><p>当定义一个用静态工厂方法来创建的bean时，使用<code>class</code>属性来指定包含<code>static</code>工厂方法的的类，使用<code>factory-method</code>属性来指定工厂方法本身的名称。你应该可以调用这个方法，返回一个存活的对象，随后被认为是否已经通过构造函数被创建。这样的bean定义的一个用法是在遗留代码中调用静态工厂。</p>
<p>如下的bean定义表明bean将通过调用一个工厂方法来创建。这个定义没有指定返回对象的类型（class）,只指定了含有工厂的类。在这个例子中，<code>createInstance()</code>方法必定是一个静态方法。</p>
<pre><code>&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
</code></pre><p>关于提供参数给工厂方法和对象在工厂返回后设置对象实体内容的原理的详细信息，见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-properties-detailed" target="_blank" rel="external">依赖和配置详情</a></p>
<h5 id="使用一个实例工厂方法实例化"><a href="#使用一个实例工厂方法实例化" class="headerlink" title="使用一个实例工厂方法实例化"></a>使用一个实例工厂方法实例化</h5><p>与静态工厂方法实例化类似，通过一个实例工厂方法实例化，会回调一个已经存在容器中的bean的非静态的方法来创建一个新的bean。    为了使用该原理，保留<code>class</code>属性为空，并在<code>factory-bean</code>属性中，为在当前（或父/祖先）容器中的bean指定名称，该bean包含用来创建对象的实例方法。通过<code>factory-method</code>属性为工厂方法本身设置名称。</p>
<pre><code>&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre><p>.</p>
<pre><code>public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();
    private DefaultServiceLocator() {}

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
</code></pre><p>如下，一个工厂类可以拥有多余一个的工厂方法：</p>
<pre><code>&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

&lt;bean id=&quot;accountService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createAccountServiceInstance&quot;/&gt;
</code></pre><p>.</p>
<pre><code>public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();
    private static AccountService accountService = new AccountServiceImpl();

    private DefaultServiceLocator() {}

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }

}
</code></pre><p>这种方式表明工厂bean(factory bean )本身可以通过依赖注入（DI）来管理和配置，见见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-properties-detailed" target="_blank" rel="external">依赖和配置详情</a></p>
<p>注意：在Spring文档中，工厂bean(factory bean)指的是这样一种bean，就是被配置在Spring容器中，可以通过<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method" target="_blank" rel="external">实例</a>或<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-class-static-factory-method" target="_blank" rel="external">静态</a>工厂方法来创建对象的bean。通过对比，<code>FactoryBean</code>（注意大写）是指一个特殊的Spring <a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-extension-factorybean" target="_blank" rel="external"><code>FactoryBean</code></a></p>
<h3 id="3-4-依赖"><a href="#3-4-依赖" class="headerlink" title="3.4 依赖"></a>3.4 依赖</h3><p>一个典型的企业应用不是由单个对象（Spring称为bean）组成。甚至最简单的应用都有几个对象协同工作，呈现给终端用户所见的是一个紧凑的应用。下一节说明你怎么从定义若干的独一无二的bean定义迈向一个完全实际的应用，该应用中对象之间为了完成一个目标而协作。</p>
<h4 id="3-4-1-依赖注入"><a href="#3-4-1-依赖注入" class="headerlink" title="3.4.1 依赖注入"></a>3.4.1 依赖注入</h4><p><em>依赖注入</em>（DI）是一个方法，该方法通过对象定义他们的依赖，也就是与他们一起运作的别的对象，只有通过构造参数，工厂方法参数，或者是在它被构造或者从一个工厂方法返回后设置在对象实体上的内容。当容器创建bean的时候会注入那些依赖。这种方法是基础的反转，因此称<em>控制反转</em>（IoC），通过使用直接的类构造方法或者服务定位模式，bean自己控制实例化或者它自己的依赖的位置。</p>
<p>使用DI原理，代码更清晰，当通过对象的依赖提供对象，能更有效的解耦。对象不查询它自己的依赖，也不知道依赖的位置或类。照此，你的类变得更容易测试，尤其是当依赖是接口或抽象的基类时，它们允许打桩或模仿实现被用到单元测试中。</p>
<p>DI存在两大变体，基于构造器的依赖注入和基于Setter的依赖注入。</p>
<h5 id="基于构造器的注入"><a href="#基于构造器的注入" class="headerlink" title="基于构造器的注入"></a>基于构造器的注入</h5><p>容器回调一个有若干参数的构造器，其中的每个参数代表一个依赖，完成基于构造器的依赖注入，。与调用一个有特殊参数的<code>static</code>工厂方法来构造bean是几乎等价的，本文论点是处理构造器的参数和类似地处理<code>static</code>工厂方法的参数。下面的例子展示的是一个只能通过构造器注入的依赖注入的的类。注意这个类没有任何特殊性，它只是一个POJO，没有依赖容器的特殊接口，基类和注解。     </p>
<pre><code>public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...

}
</code></pre><h5 id="构造参数解析"><a href="#构造参数解析" class="headerlink" title="构造参数解析"></a>构造参数解析</h5><p>使用参数类型来解决构造参数匹配的问题。如果没有潜在的不确定性存在bean定义的构造器参数中，构造器参数的顺序被定义在一个bean定义中，当bean被实例化时，正是那些参数的顺序被提供给恰当的构造器。请仔细想想下面的类：</p>
<pre><code>package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }

}
</code></pre><p>假设<code>Bar</code>和<code>Baz</code>类与继承不相关，那么就没有潜在的不确定性存在。如此，下面的配置就工作正常，你也不必在<code>&lt;constructor-arg/&gt;</code>元素中明确地指定构造参数索引和/或类型。</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;constructor-arg ref=&quot;bar&quot;/&gt;
        &lt;constructor-arg ref=&quot;baz&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot;/&gt;

    &lt;bean id=&quot;baz&quot; class=&quot;x.y.Baz&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>当另一个bean被引用，且类型是已知的，那么匹配就可能发生（正如前面的例子）。当一个简单的类型被使用，如<code>&lt;value&gt;true&lt;/value&gt;</code>，Spring不能决定这个值的类型，因此在没有帮助的情况下不能匹配，请仔细想想下面的类：</p>
<pre><code>package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }

}
</code></pre><p>在前面的场景中，如果使用<code>type</code>属性明确指定构造器参数的类型的话，容器就可以使用类型来匹配简单的类型，如：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>使用<code>index</code>属性来精确指定构造器参数的索引，如：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>除了解决多个简单值的不确定性外，指定索引还可以解决一个构造器有两个相同类型的参数的不确定性。注意索引值是从0起步的。</p>
<p>你也可以使用构造器参数名消除值的歧异：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>记住，为使这种配置在你的代码之外起作用，必须在调试标记可用可用的情况下编译，那样的话，Spring可以从构造器中浏览参数的名称。如果不能再调试标记下编译你的代码（或者是不想），你可以使用JDK注解 <a href="http://docs.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" target="_blank" rel="external">@ConstructorProperties</a>明确你的构造器参数的名称。样例类必须看起来如下：</p>
<pre><code>package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({&quot;years&quot;, &quot;ultimateAnswer&quot;})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }

}
</code></pre><h5 id="基于setter的依赖注入"><a href="#基于setter的依赖注入" class="headerlink" title="基于setter的依赖注入"></a>基于setter的依赖注入</h5><p>容器回调一个无参的构造器或无参的static工厂方法来构造你的bean后，接着调用bean上的setter方法完成依赖注入。</p>
<p>如下例子展示一个使用纯setter注入来进行依赖注入的类，这个类是符合Java的习惯的，它只是一个POJO，没有依赖容器的特殊接口，基类和注解。</p>
<pre><code>public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...

}
</code></pre><p><code>ApplicationContext</code> 支持基于构造器和基于setter的DI注入它所管理的bean。在一些依赖已经通过构造器方法注入胡，容器也还支持基于setter的依赖注入。你以一个<code>BeanDefinition</code>的格式配置依赖，你把<code>BeanDefinition</code>与<code>PropertyEditor</code>的实例结合用来转换属性的格式到另一种格式，然而，大部分的Spring使用者不直接使用这些类（i.e.,以编程的方式），而是使用XML的bean定义，注解组件（以<code>@Component</code>, <code>@Controller</code>等注解类），或者是基于Java的<code>@Configuration</code>的类中的<code>@Bean</code> 方法。在内部，这些类被转化为<code>BeanDefinition</code>实例，并被用来加载一个完整的Spring IoC容器实例。</p>
<blockquote>
<p><strong>是基于构造器函数，还是基于setter依赖注入？</strong></p>
<p>因为你可以混用基于构造函数和及与setter的依赖注入，为强制的依赖使用构造函数，为可选的依赖使用setter方法或配置方式，是一个好的经验法则。注意，在一个setter方法上使用@Required注解，可以用来使使属性成为必须的依赖。</p>
<p>Spring团队通常提倡构造函数注入，因为这种方式能使一个不可变对象来实现应用程序组件，并确保必须的依赖不为<code>null</code>。更重要的是构造函数注入的组件总是以一个完全初始化的状态返回给客户端代码。附注一点，大量的构造函数参数是一种不好的代码风格，这意味着这个类可能有许多的职责，这样的代码需要重构以更好的解决本身独立的关注点。</p>
<p>根本上来讲，setter注入只能被用来注入，可选的依赖，在类的内部可以给这种依赖分配合适的默认值。否则，在代码使用依赖的每个地方都必须进行非空检查。setter注入的一个好处是setter方法使得类依赖的对象能重新配置或者重新注入。因此通过JMX MBeans管理，是一个使用setter注入的很好的使用案例。</p>
<p>使用DI的风格最适合一个特定的类。有时，当处理没有源码的第三方类时，你就可以选择依赖注入。例如，如果一个第三方类没有暴露任何setter方法，那么构造函数注入也许是唯一的可获得DI形式。</p>
</blockquote>
<h5 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h5><p>容器按如下步骤完成bean依赖的解析：</p>
<ul>
<li>通过描述所有bean的配置元数据来创建和初始化<code>ApplicationContext</code>。配置元数据可以由XML、Java代码和注解指定。</li>
<li>对于每个bean，以属性、构造参数，或者一个静态工厂方法的参数的形式来表示它们的依赖，如果你使用的不是一个正常的构造函数而是静态工厂方法。当bean被创建时，这些依赖被提供给bean。</li>
<li>每一个属性或者构造函数参数都是要设置的值，或是容器中的另一个bean的引用的实际定义。</li>
<li>每个属性或者构造函数的参数是一个值，被从指定格式转变为属性或构造函数参数的实际类型。默认情况下，Spring可以把字符串格式的值转化为一个内置的类型，如int,long,String,boolean等等。</li>
</ul>
<p>当Spring容器被创建时，会校验每个bean的配置。然而，bean属性的值不会被设置，除非bean被实际创建。Beans是单例，被设置为在容器创建时创建的实例——预置实例（默认）。相关知识点被定义在<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="external">3.5 “Bean知识点”</a>。不然的话，bean只有在被请求时才被创建了。创建一个bean会潜在地创建一个beans的图表，作为bean的依赖，并创建和分配它的依赖的依赖（以此类推）。注意，在第一次创建bean时，解析依赖中的不匹配将会在下面介绍。</p>
<blockquote>
<p>循环依赖</p>
<p>如果你主要使用构造函数注入，导致一个难以解决的循环依赖情形是可能的。</p>
<p>如，类A需要一个通过构造函数注入的类B的实例，类B需要一个通过构造函数注入的类A的实例。如果你为类A和类B配置beans,且相互注入，Spring IoC容器在运行时发现这个循环引用，就会抛出一个<code>BeanCurrentlyInCreationException</code>异常。</p>
<p>一个解决的办法是编辑一些类的源码，这些类通过sette函数r而不是构造函数配置。另外一种办法是，避免构造函数注入而只用setter注入。换句话，虽然不建议setter注入，但你可以使用它来配置循环依赖。</p>
<p>与标准的情况（没有循环依赖）不同，bean A和bean B之间的循环依赖强制其中的一个bean以完全初始化本身的方式注入另一个bean（一个典型的蛋鸡问题）</p>
</blockquote>
<p>通常来说，你可以相信Spring会做正确的事。在容器加载的时候，它会检查配置问题，如引用一个不存在的bean和循环依赖。Spring尽可能晚地设置属性和解决依赖，直到bean被实际创建。这也就意味着Spring容器正确地加载后可能生成一个异常，当你请求一个对象，在创建这个对象或它的依赖时出现了一个问题。如，当找不结果或属性非法时bean会抛出一个异常。这可能会推迟一些配置问题的可见性，这也是为什么<code>ApplicationContext</code>实现默认的预实例化单例bean的原因。在实际需要这些bean之前，花费一些预付的时间和空间来创建他们，你会在创建<code>ApplicationContext</code>的时候发现配置问题，而不是在这之后。你可以推翻这些默认行为以使单例bean被懒初始化，而不被预实例化。</p>
<p>当一个或多个协作的bean被注入到一个依赖的bean中，如果不存在循环依赖，每个协同工作的bean完全地优先配置以便注入依赖bean中。这也就意味着，如果bean A有一个在 bean B上的依赖，Spring IoC容器彻底地优先配置bean B 通过调用bean A上的setter方法。换句话，bean被实例化（如果没有单独预实例化），它的依赖被设置，生命周期相关的方法被调用（如<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-initializingbean" target="_blank" rel="external">配置初始化方法</a>或 <a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-initializingbean" target="_blank" rel="external">InitializingBean回调方法</a>）。</p>
<h5 id="依赖注入例子"><a href="#依赖注入例子" class="headerlink" title="依赖注入例子"></a>依赖注入例子</h5><p>下面的例子使用基于XML配置元数据的setter DI。Spring 以XML配置文件的以小部分列举了一些bean定义：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- setter injection using the nested ref element --&gt;
    &lt;property name=&quot;beanOne&quot;&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/property&gt;

    &lt;!-- setter injection using the neater ref attribute --&gt;
    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }

}
</code></pre><p>在前面的例子中，setter方法声明匹配在XML文件中指定的属性，下面的例子使用构造函数 DI：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- constructor injection using the nested ref element --&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/constructor-arg&gt;

    &lt;!-- constructor injection using the neater ref attribute --&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;

    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;  

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }

}
</code></pre><p>构造函数参数在bean定义中指定，将被用作<code>ExampleBean</code>的构造函数的参数。</p>
<p>现在思考下这个例子的一个变体，要求Spring通过调用一个static工厂方法来返回该对象的一个实例，而不是使用构造方法来创建该对象的一个实例。</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; factory-method=&quot;createInstance&quot;&gt;
    &lt;constructor-arg ref=&quot;anotherExampleBean&quot;/&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;constructor-arg value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }

}
</code></pre><p><code>static</code>工厂方法的参数由<code>&lt;constructor-arg/&gt;</code> 元素提供，与实际使用构造函数一模一样。虽然在本例子中是相同，但是工厂方法返回的类的类型不必与包含该static工厂方法的类的类型相同。可以以本质上相同的方式（除了使用<code>factory-bean</code>属性替代<code>class</code>属性）使用一个工厂方法（非静态的），这里不做详细讨论。</p>
<h4 id="3-4-2-依赖和详细配置"><a href="#3-4-2-依赖和详细配置" class="headerlink" title="3.4.2 依赖和详细配置"></a>3.4.2 依赖和详细配置</h4><p>正如前面章节提及的，您可以定义bean属性和构造函数参数作为对其他托管bean（协作者）的引用，或作为值的内部定义。Spring的基于XML的配置元数据支持子元素类型，其中的<code>&lt;property/&gt;</code>和 <code>&lt;constructor-arg/&gt;</code>元素就是为了该目的。</p>
<h5 id="连续值（原语，字符串等等）"><a href="#连续值（原语，字符串等等）" class="headerlink" title="连续值（原语，字符串等等）"></a>连续值（原语，字符串等等）</h5><p><code>&lt;property/&gt;</code>元素的<code>value</code>属性指明了一个属性或者构造函数参数，并用人类能识别的字符串来表示。Spring的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#core-convert-ConversionService-API" target="_blank" rel="external">文件扫描服务</a>用来把这些值从<code>字符串</code>转换为实际的属性或参数类型。</p>
<pre><code>&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName(String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>为了更加简洁的XML配置，下面的例子使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-p-namespace" target="_blank" rel="external"> p-namespace</a></p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;
        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;
        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;
        p:username=&quot;root&quot;
        p:password=&quot;masterkaoli&quot;/&gt;

&lt;/beans&gt;
</code></pre><p>上面这个XML配置更加简洁，然而，打字错误只能在运行时期而不是设计时期被发现，除非你使用的是一个IDE，如 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>或 <a href="https://spring.io/tools/sts" target="_blank" rel="external">Spring Tool Suite</a>（STS），当你创建bean定义时，它们都支持自动补全属性。强烈建议这样的ID帮助。</p>
<p>你也可以配置一个<code>java.util.Properties</code>实例，如下：</p>
<pre><code>&lt;bean id=&quot;mappings&quot;
    class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>Spring容器通过使用JavaBeans <code>PropertyEditor</code>原理来把<code>&lt;value/&gt;</code>元素之间的文本转化为一个<code>java.util.Properties</code>实例。这是一个很好的精简，也是Spring团队倾向于使用内嵌<code>&lt;value/&gt;</code>元素替换value属性样式的几个为数不多的地方之一（This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <value> element over the value attribute style.）。</value></p>
<h5 id="idref-元素"><a href="#idref-元素" class="headerlink" title="idref 元素"></a>idref 元素</h5><p><code>idref</code> 元素值是一个error-proof方式，该方式是用来把容器中的另一个bean的<code>id</code>(字符串值-不是一个引用)传递到<code>&lt;constructor-arg/&gt;</code> 或 <code>&lt;property/&gt;</code>元素中。</p>
<pre><code>&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;

&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot;&gt;
        &lt;idref bean=&quot;theTargetBean&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>上面的bean定义片段完全等价于下面的定义片段：</p>
<pre><code>&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;

&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>比起第二中，第一种形式更可取，因为使用<code>idref</code>元素允许容器在部署的时候校验引用和该名称的bean的真实存在。第二种变体，在值上没有校验行为，这些值被传递给<code>client</code> bean的<code>targetName</code>属性。只有当<code>client</code> bean真正被实例化的时候，其中的错别字才会被发现。如果<code>client</code> bean是一个<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="external">原型</a>（prototype）bean。那么这些拼写错误和异常结果只能被发现得更晚，直到容器被部署时。</p>
<p>在4.0 beans xsd中，不再支持<code>idref</code>上的<code>local</code>属性，因为它不再提供任何超过常规bean引用的值。当升级到4.0模式的时候，只需要简单的改变存在的<code>idref local</code>引用为<code>idref bean</code>引用。与用<code>&lt;idref/&gt;``元素携带值相同的一个地方是在一个AOP拦截器的配置中配置一个ProxyFactoryBean</code> bean定义的地方。当你指定拦截器的名字时，使用<code>&lt;idref/&gt;</code>元素可以避免一个拦截器id的拼写错误。</p>
<h5 id="引用其他bean（协作者）"><a href="#引用其他bean（协作者）" class="headerlink" title="引用其他bean（协作者）"></a>引用其他bean（协作者）</h5><p><code>ref</code>元素是在<code>&lt;constructor-arg/&gt;</code>或 <code>property/&gt;</code>定义元素中的最后一个元素。这里设置指定的bean的属性的值，该值是容器管理的另一bean（一个协作者）的引用。该引用bean是被设置属性的bean的依赖，一旦需要就会在属性设置前初始化。（如果合作者是一个单例bean，可能已经被容器初始化）。所有的引用最终都是另一个对象的引用。审视和校验依赖于你是否通过<code>bean</code>, <code>local</code>,或<code>parent</code>属性指定别的对象的id/name。</p>
<p>通过<code>&lt;ref/&gt;</code>标签的bean属性指定目标bean是最通用的形式，在同一个容器或父容器中允许任何bean引用的创建，且不管是否在同一个XML文件中。<code>bean</code>属性的值也许会与目标bean的<code>id</code>属性相同，或是作为目标bean的name属性中值之一。</p>
<pre><code>&lt;ref bean=&quot;someBean&quot;/&gt;
</code></pre><p>通过<code>parent</code>属性创建一个在父容器或当前容器中的bean的引用来指定目标bean。<code>parent</code>属性的值要不与目标bean的id属性值相同，要不是目标bean的<code>name</code>属性中的值之一，且目标bean必须在当前容器的一个父容器中。当你有一个分层的容器，且想通过一个名称可能与父bean相同的代理来封装一个存在父容器中bean时，主要使用这种bean引用的变体。</p>
<pre><code>&lt;!-- in the parent context --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.SimpleAccountService&quot;&gt;
    &lt;!-- insert dependencies as required as here --&gt;
&lt;/bean&gt;
</code></pre><p>-</p>
<pre><code>&lt;!-- in the child (descendant) context --&gt;
&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>在 4.0 beans xsd中，ref元素不再支持local属性，因为它不再提供任何超过常规bean引用的值。当升级到4.0模式时，只需要简单的改变存在的<code>ref local</code> 引用为<code>ref bean</code>引用。</p>
</blockquote>
<h5 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h5><p>在<code>&lt;property/&gt;</code> 或 <code>&lt;constructor-arg/&gt;</code>元素中的一个<bean>元素定义了一个所谓的<em>内部bean</em>。</bean></p>
<pre><code>&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>一个内部bean的定义不需要id或name的定义；即便指定，容器也不会使用这个值作为一个标识。容器还忽略了创建物（bean）上的<code>scope</code>标记：内部bean总是匿名的，且他们总是用外部bean来创建。把内部bean注入到协作的bean中是不可能的，除非进入封装的bean中，或是能独立地访问它们。作为一个少见的问题，不可能收到来自用户的销毁方法的回调，一个请求中，内部bean被包含在一个单例bean中：内部bean实例的创建会被绑定到包含它的bean上，但在请求范围的生命周期中销毁方法的回调允许它参与。这是一个不常见的情况；内部bean只是简单的享有包含它们的bean的作用域。</p>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>在<code>&lt;list/&gt;</code>,<code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;props/&gt;</code> 元素中，你可以分别设置Java集合类型List、Set、Map和Properties的属性和参数。</p>
<pre><code>&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>一个map的key或value，或者是一个集合的value的值,也可以再次成为如下的任何元素的值：</p>
<pre><code>bean | ref | idref | list | set | map | props | value | null
</code></pre><h5 id="集合归并"><a href="#集合归并" class="headerlink" title="集合归并"></a>集合归并</h5><p>Spring容器也支持集合的归并。一个应用的开发者可以定义一个父样式<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，并且有一个子样式<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code>元素继承和复写来自父集合的值。也就是说，子集合的值是归并父和子集合元素的结果，孩子的集合元素覆盖在父集合中指定的值。</p>
<p>本部分合并讨论父子bean的原理。读者如果不熟悉父和子的bean定义，在继续之前可以先阅读下<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-child-bean-definitions" target="_blank" rel="external">相关的章节</a></p>
<p>下面例子示范了集合的归并：</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;administrator&quot;&gt;administrator@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge=&quot;true&quot;&gt;
                &lt;prop key=&quot;sales&quot;&gt;sales@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.co.uk&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;
</code></pre><p>注意使用在<code>child bean</code>定义的<code>adminEmails</code>属性的<props>元素上的<code>merge=true</code>属性。当<code>child</code> bean被容器解析和实例化，由此产生的实例有一个<code>adminEmails Properties</code>集合，该集合包含归并孩子的<code>adminEmails</code>集合和父亲的<code>adminEmails</code> 集合的结果。</props></p>
<p>administrator=administrator@example.com</p>
<p>sales=sales@example.com</p>
<p>support=support@example.co.uk</p>
<p>孩子<code>Properties</code> 集合的值被设置为从父元素<code>&lt;props/&gt;</code>继承所有的属性元素，孩子的值，也就是<code>support</code>值覆盖父集合中的值。</p>
<p>这种合并行为同样适用于<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;set/&gt;</code>集合类型。在<list>元素的特殊情况下，器语言与<code>List</code>集合类型相关。也就是说，一个<code>ordered</code>集合的值的概念是被保持的，父集合的值在所有孩子链表的值的前面。在Map，Set和Properties集合的类型的情形下，是没有顺序可说的。因此没有顺序语义影响集合类型，这些类型成为相关的Map，Set和Properties的容器内部使用的实现类型的基础</list></p>
<h5 id="集合合并的限制"><a href="#集合合并的限制" class="headerlink" title="集合合并的限制"></a>集合合并的限制</h5><p>不能和并不同的集合类型（如Map和List），如果你尝试这样做，就会抛出一个恰当的异常。<code>merge</code>属性必须在下级的，继承的孩子定义上指定。在一个父集合定义上指定<code>merge</code>属性是多余的，且可能不会产生希望的合并结果。</p>
<h5 id="强类型集合"><a href="#强类型集合" class="headerlink" title="强类型集合"></a>强类型集合</h5><p>随着Java5中泛型的引入，你可以使用强类型的集合了。也就是说，可以申明一个<code>Collection</code>类型，因此，这个集合中只可以包含<code>String</code>元素（例如）。如果你使用Spring依赖注入一个强类型<code>Collection</code>到一个Bean中，你可以利用Spring的类型转换支持强类型<code>Collection</code>的实例的元素转变为合适的类型，这个类型是先被加入<code>Collection</code>中的。</p>
<pre><code>public class Foo {

    private Map&lt;String, Float&gt; accounts;

    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}
</code></pre><p>-</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;property name=&quot;accounts&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;
                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;
                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>当<code>foo</code> bean的<code>accounts</code>属性准备好注入时，通过反射，关于强类型<code>Map&lt;String, Float&gt;</code>的元素类型的通用信息是可以获得的。</p>
<h5 id="Null-和空字符串值"><a href="#Null-和空字符串值" class="headerlink" title="Null 和空字符串值"></a>Null 和空字符串值</h5><p>Spring处理属性的空参数如同处理空<code>Strings</code>.如下的基于XML的配置元数据的片段，设置<code>email</code>属性为空<code>String</code>值（””）</p>
<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>上面的例子等价于如下的Java代码：</p>
<pre><code>exampleBean.setEmail(&quot;&quot;)
</code></pre><p><code>&lt;null/&gt;</code>元素处理<code>null</code>值，如：</p>
<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>上面的配置等价于如下的Java代码：</p>
<pre><code>exampleBean.setEmail(null)
</code></pre><h5 id="通过p-namespace精简XML配置"><a href="#通过p-namespace精简XML配置" class="headerlink" title="通过p-namespace精简XML配置"></a>通过p-namespace精简XML配置</h5><p>p 命名空间使你可以使用<code>bean</code>元素的属性替代嵌套的<code>&lt;property/&gt;</code>元素来描述你的属性值和/或协作bean。</p>
<p>通过命名空间，Spring支持可扩展的配置格式，这是基于一个XML Schema 定义。本章讨论的配置格式被定义在一个 XML Schema文档中。然而 p-namespace并没有定义在XSD文件中，值存在Spring的核心中。</p>
<p>下面的例子中包含两个XML片段，都是用来解决相同的问题：第一个使用标准的XML格式，第二个使用p-namespace。</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;foo@bar.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;foo@bar.com&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>上面的例子演示了在p-namespace bean的定义中一个叫做email的属性。告诉Spring包含一个属性声明。正如前面提及的，p-namespace没有schema定义，因此你可以设置这个属性名到属性（property）名。</p>
<p>下列含有超过两个bean的定义，都引用另一个bean：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;
        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;john-modern&quot;
        class=&quot;com.example.Person&quot;
        p:name=&quot;John Doe&quot;
        p:spouse-ref=&quot;jane&quot;/&gt;

    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>如你所见，本例包含了不止一个使用p-namespace的属性值，但都使用了一个特殊的格式 来声明属性的引用。第一个bean的定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>创建了一个<code>John</code>到<code>Jane</code>的引用，第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为一个属性来完成完全相同的事。在本例中<code>spouse</code> 是属性名，鉴于<code>-ref</code>部分，表明这个不是直接的值，而是相当于对另一个bean的引用。</p>
<blockquote>
<p>p-namespace并不比标准的XML格式灵活，例如，这种格式声明的属性引用会与以<code>ref</code>结尾的属性冲突，然而标准的XML格式就不会有这个问题。为避免在同一时间使用所有的三种方式来生成XML文档，我们建议仔细选择你的方式，并把这个信息传达给你的团队成员。</p>
</blockquote>
<h5 id="通过c-namespace精简XML配置"><a href="#通过c-namespace精简XML配置" class="headerlink" title="通过c-namespace精简XML配置"></a>通过c-namespace精简XML配置</h5><p>与“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-p-namespace" target="_blank" rel="external">通过p-namespace精简XML配置</a>”节相似，c-namespace在Spring3.1开始引入，允许使用内部属性来配置构造函数的参数代替内嵌的<code>constructor-arg</code>元素。</p>
<p>回顾“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-constructor-injection" target="_blank" rel="external">基于构造函数依赖注入</a>”章节关于<code>c:</code>命名空间的例子：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot;/&gt;
    &lt;bean id=&quot;baz&quot; class=&quot;x.y.Baz&quot;/&gt;

    &lt;!-- traditional declaration --&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;constructor-arg ref=&quot;bar&quot;/&gt;
        &lt;constructor-arg ref=&quot;baz&quot;/&gt;
        &lt;constructor-arg value=&quot;foo@bar.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration --&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot; c:bar-ref=&quot;bar&quot; c:baz-ref=&quot;baz&quot; c:email=&quot;foo@bar.com&quot;/&gt;

&lt;/beans&gt;
</code></pre><p>关于通过名称设置构造函数参数，c:命名空间使用与p:命名空间相同的约定（bean的引用以-ref结尾）。即便你没有在XSD模式中定义它，这也无妨，你只需要声明就行。</p>
<p>对于构造参数不可用（通常如果编译的字节码没有debuggig信息的话）的稀有情景，你可以使用给参数加上索引的备用方法：</p>
<pre><code>&lt;!-- c-namespace index declaration --&gt;
&lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot; c:_0-ref=&quot;bar&quot; c:_1-ref=&quot;baz&quot;/&gt;
</code></pre><blockquote>
<p>由于XML的语法的原因，索引符号需要以<code>_</code>开头，就像XML的属性名称一样，不能以数字开头（即便有些IDE是允许这样的）。</p>
</blockquote>
<p>实际上，在匹配参数上构造函数解决<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-ctor-arguments-resolution" target="_blank" rel="external">机制</a>是十分有效的。所以除非真的需要，否建议使用name符号贯穿整个配置。</p>
<h5 id="混合属性名称"><a href="#混合属性名称" class="headerlink" title="混合属性名称"></a>混合属性名称</h5><p>当设置bean属性时，可以使用混合的或者嵌套的属性名称，只要所有的path组件出最终属性属性名外都不是<code>null</code>。思考如下的bean定义：</p>
<pre><code>&lt;bean id=&quot;foo&quot; class=&quot;foo.Bar&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre><p><code>foo</code> bean有一个<code>fred</code>属性，<code>fred</code>属性有一个<code>bob</code>属性，<code>bob</code>属性有一个<code>sammy</code>属性，最终的<code>sammy</code>属性被设置为<code>123</code>。为了使其能起作用，<code>bean</code>构造后，<code>foo</code>的<code>fred</code>属性，<code>fred</code>的<code>bob</code>属性必须不是<code>null</code>，或者不能抛出<code>NullPointerException</code>异常。 </p>
<h4 id="3-4-3-使用依赖"><a href="#3-4-3-使用依赖" class="headerlink" title="3.4.3 使用依赖"></a>3.4.3 使用依赖</h4><p>如果一个bean另一个bean的依赖，那通常就表示这个bean被设置为了另一个bean的属性（内容）。典型的是，通过基于XML的配置元数据中的<ref>元素来完成这项功能。然而，有时候bean之间的依赖并不是直接的；如，在一个class中的一个静态初始化方法需要被触发，比如数据库驱动注册（database driver registration）。在bean使用的元素被初始化之前，<code>depends-on</code>属性可以明确地强制一个或多个bean初始化。如下，使用<code>depends-on</code>属性来传递了一个单bean上的依赖。</ref></p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;
&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
</code></pre><p>为了表示在多个bean上的依赖，提供一个bean的名称列表作为<code>depends-on</code>属性的值，其中的逗号，空格和分号作为校验分隔符：</p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;
    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;
</code></pre><p>在bean的定义中的<code>depends-on</code>属性既可以指定初始化时的依赖，如果只是一个单例bean的话，也可以指定对应的销毁时的依赖，从属的bean定义了一个<code>depends-on</code>与一个给定bean关系，且会被首先销毁，优先销毁给定的bean自身，也就是说<code>depends-on</code>也可以控制关闭顺序。</p>
<h4 id="3-4-4-bean的Lazy初始化"><a href="#3-4-4-bean的Lazy初始化" class="headerlink" title="3.4.4 bean的Lazy初始化"></a>3.4.4 bean的Lazy初始化</h4><p>默认情况下，ApplicationContext 实现希望创建和配置所有的单例beans，以作为初始化程序的一部分。一般情况下，这种预先实例化的方式是很有必要的，因为在配置中或者与环境相关的错误会及时被发现，不然的话很可能是几个小时，甚至几天之后才会被发现。当不满意这样的行为时，你可以通过标记bean定义为lazy-initialized来阻止一个单例bean的预实例化。一个lazy-initialied bean告知IoC容器，只有当一个bean第一次被请求时才创建其实例化，而不是在启动的时候就创建。</p>
<p>在XML文件中，通过,<bean>元素的lazy-init属性来控制lazy初始化行为。例如：</bean></p>
<pre><code>&lt;bean id=&quot;lazy&quot; class=&quot;com.foo.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.foo.AnotherBean&quot;/&gt;
</code></pre><p>当上面的配置被一个<code>ApplicationContext</code>消费时，在<code>ApplicationContext</code> 启动时，命名为<code>lazy</code>的bean需希望被预实例化，而命名为<code>not.lazy</code>的可以预实例化。</p>
<p>然而，当一个lazy初始化bean是一个非lazy初始化的单例bean的依赖时，<code>ApplicationContext</code> 就会在启动时创建lazy初始化bean，这是为了满足单例的依赖。lazy初始化的bean被注入到一个单例bean中，那么在别的地方就不再是lazy bean。</p>
<p>通过使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init属</code>性，可以在容器级别控制懒初始化。例如：</p>
<pre><code>&lt;beans default-lazy-init=&quot;true&quot;&gt;
    &lt;!-- no beans will be pre-instantiated... --&gt;
&lt;/beans&gt;
</code></pre><h4 id="3-4-5-自动装配协作对象"><a href="#3-4-5-自动装配协作对象" class="headerlink" title="3.4.5 自动装配协作对象"></a>3.4.5 自动装配协作对象</h4><p>Spring容器可以在协作bean之间进行自动关联，你可以允许Spring通过检查ApplicationContext中的内容，以自动地解决你的bean的协作者（其他的bean）。自动封装有一下一些优势：</p>
<ul>
<li>自动封装明显地减少需要指定的属性或者构造参数（就这点而言，别的机制，如在本章其他地方讨论的bean模板也是有价值的）。</li>
<li>当你的对象演变时，自动封装可以更新配置。例如，如果你需要为一个class增加依赖，它可以自动满足需求而不需要修改配置。也就是说自动装配在开发的时候是特别有用的，不可否认，当代码基础变得稳定后可以切换到精确配置这个选项上来。</li>
</ul>
<p>在使用基于XML的配置元数据时，你可以为一个通过<bean>元素的autowire属性定义的bean指定自动装配的模式。自动装配功能有四种模式，你可以为每个bean指定自动装配机制，也就是说你可以选择为哪一个bean进行自动装配。</bean></p>
<p>表3.2 自动装配模式</p>
<p><table><br>    <tr><br>        <th>模式</th><th><br>        </th><th>解释</th><th><br>    </th></tr><tr><br>    </tr><tr><br>        <td>no</td><td><br>        </td><td>（默认）没有自动包装，bean的引用必须通过<code>ref</code>元素定义，对于比较大的部署，不建议改变默认设置，因为精确地描述一个协作者，需要提供更多的控制和透明度，一定程度上来说，这种方式记录了系统的结构</td><td><br>    </td></tr><tr><br>    </tr><tr><br>        <td>byName</td><td><br>        </td><td>通过属性名称自动封装，Spring查询有相同属性名的，需要自动封装的bean。例如，如果一个bean的定义被设置为通过名称自动封装，并且包含一个master属性（就是 有一个setMaster(..)方法），Spring寻找一个名称为<code>master</code>的bean定义，并使用它来设置属性</td><td><br>    </td></tr><tr><br>    </tr><tr><br>        <td>byType</td><td><br>        </td><td>如果恰好一个bean的属性类型存在一个容器中，那么可以自动封装该属性。如果存在超过一个，就会抛出一个毁灭性的异常，这就表明你可能没使用<em>byType</em>自动包装这个bean，如果没有匹配的bean，就什么都不会发生，属性就不会被设置</td><td><br>    </td></tr><tr><br>    </tr><tr><br>        <td>constructor</td><td><br>        </td><td>类似<em>byType</em>，但是使用了构造参数，如果在容器中恰好不存在一个构造器的参数类型的bean，那么就会产生一个严重错误</td><td><br>    </td></tr><tr></tr></table></p>
<table>




<p>通过<em>byType</em>和<em>constructor</em>的自动封装模式，你可以包装数组和有类型集合，在这种情形下，容器中的所有的匹配所需类型的自动包装候选者用于满足依赖。如果key的类型是<code>String</code>，你可以自动包装强类型的Map。一个自动包装的Map的值将由满足预期类型bean实例组成，Map的键会包含相应的bean名称。</p>
<p>你可以把自动包装行为和依赖检查结合起来，依赖检查是在自动包装后执行的。</p>
<h5 id="自动包装的劣势和限制"><a href="#自动包装的劣势和限制" class="headerlink" title="自动包装的劣势和限制"></a>自动包装的劣势和限制</h5><p>在整个项目中一直使用自动包装机制，使得自动包装能更好的起作用。如果自动包装不被普遍使用，而只被使用来包装一两个bean定义会令开发者感到迷惑。</p>
<p>考虑自动包装的限制和缺点：</p>
<ul>
<li>在<code>property</code>和<code>constructor-arg</code>中设置的明确依赖总是会覆盖自动包装。你不能封装所谓的简单属性，比如基本类型，<code>Strings</code>，和<code>Classes</code>（和这些简单类型的数组），这个限制是设计时就有的。</li>
<li>自动封装没有精确封装准确。尽管如上表所诉，但Spring还是很小心的避免在模拟两可的情况下进行猜测，这种情况也许会导致难以预料的结果，Spring所管理的对象之间关系不再被精确的记录。</li>
<li>包装信息对于从Spring容器生成一个文档的工具来说可能是没有用的。</li>
<li>容器中的多个bean定义可以匹配setter方法和构造函数参数指定的类型，从而达到自动包装。对于数组，集合或Maps，这都不是问题。然而对于单值的依赖，这种含糊是难以解决的。如果非独立的bean定义是可用的，就会抛出一个异常。</li>
</ul>
<p>在最新的方案中，你有以下几种选择：</p>
<ul>
<li>放弃自动包装而改用精确的封装</li>
<li>如下一节描述的一样，为避免对一个<code>bean</code>定义进行自动包装，可以通过设置它的<code>autowire-candidate</code>属性为<code>false</code>。</li>
<li>通过设置bean元素的<code>primary</code>属性为<code>true</code>,指派一个单例bean定义作为最初的候选者。</li>
<li>通过基于注解的配置可以实施更细粒度的控制，如<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-annotation-config" target="_blank" rel="external">3.9 “基于注解的容器配置”</a>中所述。</li>
</ul>
<h5 id="排除bean自动包装"><a href="#排除bean自动包装" class="headerlink" title="排除bean自动包装"></a>排除bean自动包装</h5><p>在每个bean的基础上，可以排除一个bean的自动包装，在spring的XML格式中，设置<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性为<code>false</code>;容器使得特殊的bean定义不能包装基础构件（包括注解方式的配置，如<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-autowired-annotation" target="_blank" rel="external"><code>@Autowired</code></a>）</p>
<blockquote>
<p>autowire-candidate属性被设计成只影响基于类型的自动包装。它不影响通过名称的精确引用，该引用将会转变，即便指定的bean没有被标记为一个自动包装的候选对象。因此，通过名字的自动包装将不会注入，除非名称匹配。</p>
</blockquote>
<p>通过基于bean名称相关的模式匹配，你可以限制自动包装的候选者。顶级的<beans>元素，在它的default-autowire-candidates属性中，可以接受一个或多个模式。例如，为了限制任何名称以Repository结尾的bean的自动包装候选者的状态，以*Repository作为值。为了提供多个模式，把它们定义在以逗号分隔的list中。一个bean定义的autowire-candidate属性的精确值，true或者false,总是被优先考虑，对于这样的bean，模式匹配规则不起作用。</beans></p>
<p>这种技术对那些你从来不想通过自动包装注入到其他bean中的bean来说是有用的。这也并不意味着被排除的bean不能通过自动包装配置。也就是说，bean本身不能成为包装其他bean的候选者。</p>
<h4 id="3-4-6-方法注入"><a href="#3-4-6-方法注入" class="headerlink" title="3.4.6 方法注入"></a>3.4.6 方法注入</h4><p>在大部分的应用场景中，容器中的大部分bean是单例。当一个单例bean需要与另一个单例bean协作，或者是一个非单例bean需要与另一个非单例bean协作，你典型的处理依赖的方式是定义一个bean成为另一个bean的依赖。当bean的生命周期不同的时候，就会导致一个问题。假设单例bean A需要使用非单例bean B，或许在A的每个方法调用上。容器只会创建单例bean一次，也就是说只有一次机会设置属性，容器不能给bean A 提供一个bean B的实例在每次需要一个bean B的时候。</p>
<p>一个解决办法是放弃一些依赖倒置。你可以通过实现ApplicationContextAware接口使得bean A能意识到容器的存在，每当bean A需要bean B的时候，可以通过创建一个getBean(“B”)来调用容器获取bean B实例。如下是该方法的一个例子：</p>
<pre><code>// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre><p>前面的方法难以令人满意，因为业务代码与Spring Framework耦合在一起了。方法注入，有点Spring IoC容器的优秀特点，允许以一个清晰的方式处理这个用例。</p>
<pre><code>你可以[这篇博客条目](https://spring.io/blog/2004/08/06/method-injection/)中阅读更多的关于方法注入的的优势。
</code></pre><h5 id="Lookup方法注入"><a href="#Lookup方法注入" class="headerlink" title="Lookup方法注入"></a>Lookup方法注入</h5><p>Lookup方法注入是容器覆盖在容器管理的bean上的方法的能力，为容器中的另一个bean返回查询结果。lookup涉及到的特殊情况是一个原型bean，正如在前面的章节的场景中所描述的一样。Spring Framework实现这种方法注入是通过字节码生成器，该生成器是使用CGLIB 库动态地生成一个复写该方法的子类。</p>
<blockquote>
<ul>
<li>为了使这个动态的子类生效，Spring bean容器将要收集的这个类不能是final的，将要被覆盖的方法也不能是final的。</li>
<li>单元测试一个有abstract方法的类，要求你自己子类化该类，并为该abstract方法提供一个桩(stub)实现。</li>
<li>对于要求具体类来完成的组件组件扫描，具体的方法也是必须的。 </li>
<li>一个最关键的限制是lookup方法不能与工厂方法一起工作，尤其是不能与配置类中的使用@Bean注解的方法一起工作，因为在这种情况下容器不负责创建实例，因此不能在运行时快速生成子类。</li>
</ul>
</blockquote>
<p>看看在前面的代码片段中的CommandManager 类，你会发现Spring容器会动态的覆盖createCommand()方法的实现。你的CommandManager 类将会没有的任何的Spring依赖，正如下面重写的例子所示;</p>
<pre><code>package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
</code></pre><p>在客户端类中包含将要注入的方法（如这种情形下的CommandManager 类），需要被注入的类要求有一个如下的格式的签名：</p>
<pre><code>&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);
</code></pre><p>如果该方法是abstract的，需要动态生成的子类实现该方法。否则的话，动态生成的子类需要覆盖在原始类中定义的具体的方法。如：</p>
<pre><code>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>无论什么时候，标识为commandManager 的bean需要一个myCommand bean的新实例，它都会调用它自己的createCommand()方法。如果真的需要把myCommand bean部署为一个原型，你必须小心谨慎的。如果它是一个单例，每次都返回myCommand bean的同一个实例。</p>
<p>或者在一个基于注解的组件模型中，你可能会通过@Lookup注解声明一个lookup方法：</p>
<pre><code>public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup(&quot;myCommand&quot;)
    protected abstract Command createCommand();
}
</code></pre><p>或者，更常用的是，你可以依赖目标bean获取解决方法，依靠lookup方法声明的返回类型：</p>
<pre><code>public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
</code></pre><p>注意，为了使这些方法与Spring的组件扫在描默认情况下忽略抽象类的规则兼容，你可以有代表性地声明这样的带有注解的lookup方法，使得其有一个具体的桩(stub)实现。</p>
<blockquote>
<p>另一种访问不同作用域的目标bean的方法是一个ObjectFactory/ Provider注入点。查看章节“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-scopes-other-injection" target="_blank" rel="external">Scoped beans as dependencies</a>”。</p>
<p>感兴趣的读者也可以查看ServiceLocatorFactoryBean（在org.springframework.beans.factory.config包中） 的使用。</p>
</blockquote>
<h5 id="任意的方法替换"><a href="#任意的方法替换" class="headerlink" title="任意的方法替换"></a>任意的方法替换</h5><p>一个比lookup方法注入更少使用的方法注入形式是替所换管理的通过另一个方法实现的bean中的任何方法的能力。</p>
<p>根据基于XML配置的元数据，为了部署bean，你可以使用replaced-method元素替换一个存在的，通过另一个bean实现的方法。考虑如下的类，它有一个computeValue方法，这个方法是我们想覆盖的：</p>
<pre><code>public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...

}
</code></pre><p>一个实现了org.springframework.beans.factory.support.MethodReplacer接口的类提供了一个新的方法定义：</p>
<pre><code>/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
</code></pre><p>部署原始类并指定覆盖的方法的bean定义，就像下面这样：</p>
<pre><code>&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;
</code></pre><p>你可以使用一个或多个包在<replaced-method>元素中的<arg-type>元素来指定将要被覆盖的方法的签名。在类中，只有方法被重载和存在多个变体的情况，参数才需要签名。为方便起见，输入的参数字符串可以是全限定类名的字符串的子串。例如，如下的都匹配java.lang.String：</arg-type></replaced-method></p>
<pre><code>java.lang.String
String
Str
</code></pre><p>因为参数的数量通常足够区分每个可能的选择，这个简写可以节约键入次数，允许你只键入最短的字符串就可以匹配一个参数类型。</p>
<h3 id="3-5-Bean作用域"><a href="#3-5-Bean作用域" class="headerlink" title="3.5 Bean作用域"></a>3.5 Bean作用域</h3><p>当你创建一个bean定义的时候，实际上是为通过bean定义定义的类的创建真实的实例建立了一个菜谱。把一个bean的定义看做菜谱的观点是很重要的，因为这意味着，就一个类来说，你可以从一个单一的菜谱创建许多对象实例。</p>
<p>你能控制的不只有各种各样的依赖和塞入一个由一个特殊的bean定义创建的对象中的配置值，而且还包括由特殊bean定义创建的对象的作用域。在你能选择的对象的作用域中，这种方法是强大和灵活的，所选折的对象是通过配置而不是必须在Java类级别的对象作用域中创建的。可以把Bean定义为部署到多个作用域中的一个：创造性地，Spring Framework 支持留个作用域，其中的五个只有在你使用web方面的<code>ApplicationContext</code>时才起效。</p>
<p>如下的作用域支持开箱即用，你也可以创建传统的作用域：</p>
<p><table><br>    <tr><br>        <th>Scope</th><br>        <th>描述</th><br>    </tr><br>    <tr><br>        <th>singleton</th><br>        <th>(默认)每个Spring IoC容器都会把单一的bean定义映射为一个单一的对象实例</th><br>    </tr><br>    <tr><br>        <th>prototype</th><br>        <th>把一个单一的bean定义映射到任何数量的对象实例</th><br>    </tr><br>    <tr><br>        <th>request</th><br>        <th>把一个单一的bean定义映射到单个HTTP请求的生命周期中，也就会说每个HTPP请求有一个它自身的一个bean实例，该bean反复被一个单一的bean定义创建，只有在web感知的Spring ApplicationContext的上下文中才有效</th><br>    </tr><br>    <tr><br>        <th>session</th><br>        <th>Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.</th><br>    </tr><br>    <tr><br>        <th>application</th><br>        <th>Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.</th><br>    </tr><br>    <tr><br>        <th>application</th><br>        <th>Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.</th><br>    </tr><br></table></p>
<blockquote>
<p>Spring3.0之后，一个线程级的作用域是可用的，但没有默认注册。更多的信息见<a href="http://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/SimpleThreadScope.html" target="_blank" rel="external"><code>SimpleThreadScope</code></a>相关的文档。关于怎样注册这个作用或者其他的惯用的作用域，查看“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom-using" target="_blank" rel="external">使用一个常用作用域</a>”这节。</p>
</blockquote>
<h4 id="3-5-1-单例作用域"><a href="#3-5-1-单例作用域" class="headerlink" title="3.5.1 单例作用域"></a>3.5.1 单例作用域</h4><p>一个被管理的单例bean只有一个共享的实例，所有通过ID或IDS匹配bean定义的bean请求导致一个特殊的bean实例被Spring容器返回。</p>
<p>换句话说，当你定义一个bean定义，它被定义为一个单例，Spring IoC容器精确地创建一个通过bean定义定义的对象实例。这个单实例被存储在一个类似单例bean的缓存中，所有后面的关于这个bean的请求和引用，返回的都是这个对象。</p>
<p><img src="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/singleton.png.pagespeed.ce.U0lSEQUK39.png" alt=""><br>Spring单例bean的概念不同于在 Gang of Four (GoF)中定义的单例模式。GoF单例硬编码一个对象的作用域，对于每个类加载器一个特殊的类只被创建一次，Spring单例的作用域最好描述为一个容器一个bean。这意味着在一个单一的容器中如果你为一个特殊的类定义了一个bean，那么Spring容器创建一个，且只创建一个通过bean定义定义的类实例。Spring中的单例作用域就是默认的作用域。为了在XML文件中把一个bean定义为单例，你会像下面一样编写这个XML文件：</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot;/&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre><h3 id="3-5-2-原型作用域"><a href="#3-5-2-原型作用域" class="headerlink" title="3.5.2 原型作用域"></a>3.5.2 原型作用域</h3><p>非单例，bean的原型作用域的部署导致一个新的bean实例创建，每次对这个特殊bean的请求都会创建这个bean。也就是说，这个bean被注入到另一个bean中，或者你可以通过getBean()方法在容器上回调来请求这个bean。作为一个规则，为所有有状态的bean使用原型作用域，为所有的无状态的bean使用单例。</p>
<p>下图阐明了Spring的原型作用域，一个数据访问对象（DAO）通常不配置为一个原型，因为一个典型的DAO没有持有任何的会话状态。这里作者只是简单的复用单例图的核心：</p>
<p><img src="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/prototype.png.pagespeed.ce._EP1ydjN29.png" alt=""><br>如下例子，在XML文件中定义了一个原型bean：</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;
</code></pre><p>与其他的作用域进行对比，Spring并没有管理一个原型bean的完整生命周期：容器实例化、配置，另外还集合一个原型对象，并把它推送给用户，除此之外并没有更多的关于原型实例的记录。    那就是，尽管初始化生命周期的回调方法在所有不分作用域的对象上被调用，但是在原型作用域的情况下，销毁生命周期回调函数的配置不被调用。客户端代码必须清理原型作用域对象，并且释放原型bean占有的宝贵的资源。为了获得Spring容器释放的被原型作用域bean占有的资源，试着使用一个常用的 bean 提交处理器，该处理器拥有需要被清理的bean的引用。</p>
<p>某些情况下，Spring容器关于原型作用域bean的角色是Java new操作符的代替者。全生命周期管理越过那个点，就必须被客户端处理。（关于Spring容器中的bean的生命周期的详细信息，可以参考3.6.1节，“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-lifecycle" target="_blank" rel="external">生命周期回调</a>”）</p>
</table></dependencies>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Spring-依赖和依赖于Spring&quot;&gt;&lt;a href=&quot;#Spring-依赖和依赖于Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring 依赖和依赖于Spring&quot;&gt;&lt;/a&gt;Spring 依赖和依赖于Spring&lt;/h4&gt;&lt;p&gt;尽管
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GVim的编码设置</title>
    <link href="http://yoursite.com/2017/04/04/GVim%E7%9A%84%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/04/04/GVim的编码设置/</id>
    <published>2017-04-04T10:48:09.000Z</published>
    <updated>2017-04-04T10:53:17.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gvim的基本设置"><a href="#gvim的基本设置" class="headerlink" title="gvim的基本设置"></a>gvim的基本设置</h1><hr>
<h2 id="编码设置"><a href="#编码设置" class="headerlink" title="编码设置"></a>编码设置</h2><p><code>set fileencodings=utf-8,chinese,latin-1</code></p>
<p><code>set termencoding=utf-8</code></p>
<p><code>set encoding=utf-</code></p>
]]></content>
    
    <summary type="html">
    
      在使用vim过程中的一些总结
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="工具类学习" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>我的阅读清单</title>
    <link href="http://yoursite.com/2017/03/19/%E6%88%91%E7%9A%84%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2017/03/19/我的阅读清单/</id>
    <published>2017-03-19T09:47:00.000Z</published>
    <updated>2017-12-07T11:36:10.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《未来简史》"><a href="#《未来简史》" class="headerlink" title="《未来简史》"></a>《未来简史》</h1><hr>
<h2 id="作品简介"><a href="#作品简介" class="headerlink" title="作品简介"></a>作品简介</h2><p>本书的作者是以色列的尤瓦尔.赫拉利，他本人是一个研究历史的历史学家，但他却在很多方面都有自己独到的见解，因此，从他的作品中，我们会发现他在讲述历史并不单单是只从历史范畴来阐明他的观点。他一般会旁征博引，如他的《人类简史》，讲述的是人类发展的变迁史。但其中涉及极其广泛，包括生物学、物理学、社会学等。所以读他的作品，并不会是我们的思维受到限制，相反，通过它睿智的文笔和独特视角我们会看到一个不一样的世界。他的作品都是各个学科交叉的，所以不管你是什么专业的人，你都能从他的作品中得到一些启示。你会认为他的作品不够专业，但是你有没有想过，当今的任何学科都不可能孤立存在，就像历史，难道我们只能去抛开一堆土，告诉你这大概是哪个时代的泥土吗？不，那绝对枯燥而没有说服力，一个优秀的历史学家除了侃侃而谈的告诉你他的历史见解外，一般会用上其他学科的研究成果来佐证他的推断，比如生物学。</p>
<p>本书立意新奇，站在未来的角度审视过去——二十一世纪。在二十一世纪，人类几乎战胜了所有人类过去所面临的难题，包括战争、瘟疫、疾病、饥饿等。在这之前的历史中是很难想象的，到底人类为什么发展得如此惊人，在书中也有所阐明，是在于人类这种生物具有强大的生物算法。过去的历史我们认为是因为人类具有心智、抽象思维等。而在本书中，作者推陈出新，他跳出了宗教的范畴，站在一个更高的高度来审视人类本身。人类并不是神造，相反我们人类正在逐渐成为我们心中所想的神。随着人类的进步，宗教也总是在不断自我的修正，但他们都逃不开神学的范畴，宗教还想用一个高度抽象的实体来约束人类，但随着科技、哲学的发展，人类发现自己进入一些以前只有神能前往的地方，于是神学，上帝就显得不那么高高在上，神神秘秘了。二十世纪，人文主义高度发展，分化出了许多人文观点：自由人文主义、民族人文主义和社会人文主义。这三个主义虽有所不同，但都强调人是一个独立的个体，有自我意识，人这个独立的个体最了解自己。但进入二十一世纪之后，尤其是生物学，计算机科学的蓬勃发展，尤其是人工智能的发展，我们发现我们并不是最了解自己的，我们做出的任何决定似乎并不是自由意识的表现，好像是许多生化反应产生的，也可以叫做某种算法，也就是说我们的任何行为都是由已经存在我们身体中的生物算法导致的。</p>
<p>作者把有机世界的行为都归结于算法，是算法推动了这个世界不停的运转。直到有一天，人类掌握了隐藏在我们DNA中的生物算法，我们就可能超神了。其实到目前为止，我们已经研究出来一些纯只能的算法，他们的运算能力已经超越了人类。在未来这个万物链接的时代，人类不是升级就是被淘汰。</p>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>暂且不论作者书中所说的会不会发生，面对飞速发展的今天，我们必须时刻保持学习，少一点时间不学习就会被这个时代所抛弃。我们要时刻准备迎接作者书中所描述的那个伟大的时代，不要在那个时代被置于最低等的位置，甚至成为下一代智人的宠物。不要感叹时光的飞逝，因为这个时代没有让你感叹的功夫，有那功夫还不如学习。</p>
<h1 id="《浪潮之巅》"><a href="#《浪潮之巅》" class="headerlink" title="《浪潮之巅》"></a>《浪潮之巅》</h1><hr>
<h2 id="作品简介-1"><a href="#作品简介-1" class="headerlink" title="作品简介"></a>作品简介</h2><p>作者吴军，吴军博士写过许多了不起的书，如《数学之美》、《文明之光》等。他的书既体现吴军博士的专业素养，又显现了吴军博士的广播知识，他的书易于阅读，不管你是什么专业的，阅读他的书都不会被其中的专业词语所困惑，他通常能用简介的语句介绍这些专业术语。</p>
<p>书中主要介绍硅谷的一些大的科技公司，这些科技公司曾经都引领过一个时代，是那个时代的弄潮儿，这些公司多半都曾经站到过科技巨浪的浪头。很多公司经过了短暂的辉煌后，或从此消失，或一蹶不振。而有的公司难逢敌手，屹立不倒，经久不衰。其中的原因是什么，其中又包含有什么规律。关于这些问题，作者在书中都给我们一一解答，或是企业基因决定，或是没有把握在浪潮之巅的绝佳机会，或是商业策略上的失误，或是没有随时代不断革新。</p>
<p>最怕的是有一个愚蠢的领导，书中介绍的很多巨无霸公司的没落，很多原因是领导的失误，也有的是历史的必然。通过叙述这些曾经的弄潮儿，作者深入分析他们长盛不衰的秘密和昙花一现的命运。总之我们从书中能一窥那些曾经或现在依然不可一世的企业，我们也要环顾我们的四周，分析自己所处的环境，以期有所作为，前面的浪潮我们没有赶上，希望我们不要错过接下来的新的浪潮。我们或许应该感谢这个时代，我们中国人没有那一次离浪潮之巅这么近，只要我们把握了硅谷成功的诀窍，我想我们也是大有可为的。接下来的人工智能、万物互联僵尸新的一波浪潮，不知道我们有没有准备好。</p>
<h2 id="个人感悟-1"><a href="#个人感悟-1" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>过去的二十世纪，科技的浪潮不是很多，但如今这个时代，科技浪潮是一波接着一波，一不小心，我们这些澎湃向前的浪潮头所抛下，唯有学习，静待下一波浪潮，争取成为新一波浪潮的弄潮儿，不负青春，不负自己。</p>
<h1 id="《人性的弱点》"><a href="#《人性的弱点》" class="headerlink" title="《人性的弱点》"></a>《人性的弱点》</h1><hr>
<h2 id="作品简介-2"><a href="#作品简介-2" class="headerlink" title="作品简介"></a>作品简介</h2><p>作者戴尔.卡耐基,美国。本书所涉及的是中国所谓的处世哲学，比如怎么与人沟通，怎么让自己受欢迎，怎么能说服别人等。本书并不单纯的像中国的许多厚黑之学，或是官场秘籍。作者所述或是基于科学实验，或是基于自己的人生经验，也有的是历史人物的启示，但也不缺少作者本人的一些教学实践。可以说如果按照作者所说的来处理人际关系，保管无往不胜。</p>
<p>本书的立意并不是什么鸿篇巨制，喝多都是一些个人经历，名人经历，并没有上升到经世济民的高度，但正因为如此，这本书才值得我们这些普通人阅读，不仅仅是简单的阅读，而是要像宗教圣书一样，反复专研，多多实践，不断领悟，对就是领悟，不要以为书中所说实在简单不过，那只是因为作者把握语言的能力太强了，使得本书从型上看确实简单，但深入思考，你会发现作者所说确实在理。</p>
<p>为了尽量说得通俗，书中，作者举例颇多，看到这些例子，读者会有一种正在实践他所说的处事方法的感觉，这样一来书中所讲的道理就会深刻的印在我们头脑中。但只是简单的装入我们的头脑还是不够的，这只达到了作者目的一小部分，作用要的是我们要用这些方法论不断实践，使得书中的那些理论真实的为我所用。</p>
<p>书中涉及到的主要是做一个怎样的人才能收欢迎，但我们不能单纯的做自己，还要从所面对的对象出发，做一个他人喜欢的人，书中的很多人性弱点，不止我们有，别人也不缺，我们应该学会推己及人，争取做一个自己喜欢，别人也喜欢的自我。</p>
<h2 id="个人感悟-2"><a href="#个人感悟-2" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>很多时候，你希望别人有的，也是别人希望你有的；有时候，你拥有的，并且你也喜欢的并不是别人喜欢的。在于朋友、家人、陌生人的交往中，我们尽量要做让别人喜欢的字节，隐藏那些别人不喜欢的特点，这些特点对你本人来说，很可能不是什么坏事，但凡是我们要从所面对的对象的心里、眼里出发。懂得了人性的弱点也就懂得了尊重别人、理解别人，也能宽恕自己。</p>
<h1 id="《我敢在你怀里孤独》"><a href="#《我敢在你怀里孤独》" class="headerlink" title="《我敢在你怀里孤独》"></a>《我敢在你怀里孤独》</h1><hr>
<h2 id="作品简介-3"><a href="#作品简介-3" class="headerlink" title="作品简介"></a>作品简介</h2><p>作者刘若英，台湾，演员。作为一个演员，别人看到的知识作者本人的光鲜的一面，以为他们到哪里都是众星捧于，而我们却没怎没想过，他们也是凡人，他们也害怕凡人所怕的事。你我都害怕孤独，更别说演员了，对于这个职业，我想他们更害怕孤独，更害怕在大众的视野中消失。单本书的作者，作为一个演员却爱上了孤独（或许这是一种独处，安静的方式），爱上了独处，总是想方设法的制造独处的环境。通过作者本人的自述，我们看到了作者另辟蹊径，安然生活。面对孤独，我们需要一种态度，一种对生活，对生命的冷静思考方式。</p>
<p>书中作者除了介绍自己喜欢孤独的原因，创造孤独的方法外，还介绍了另外几名一人对孤独生活的理解。通过作者的叙述，我们看到了光鲜一人的常人的一面，但也不寻常的一面，他们居然喜欢孤独和独处的感觉。作者本人不仅喜欢独处，还创造了许多独处的方法，即便在人来人往的城市生活中，需要多方顾忌考虑的家庭琐事中，作者都能寻觅出以方安静，独自一人的天地，比如独自旅游，独自KTV等。</p>
<h2 id="个人感悟-3"><a href="#个人感悟-3" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>在生活中我们都是社群人员，都必须参与到社交生活中，好比社交是人类不可或缺的本性。但我们害怕什么，什么就总是形影不离，许多人害怕在这个喧嚣的社群中被冷落，被遗弃，被遗忘。以至于都认为孤独感是一种很不好的情绪。</p>
<p>然而作者本人却显现出了与这个时代大相径庭，格格不入的一个面，喜欢孤独，希望独处，甚至在家里面也是如此，面对家人也是如此。在独处的思考中，作者发现了独处的妙处。当然，当发现独处的好的时候，我们更倾向于与独处的生活，这并不是为了彰显自己的独一无二，抑或是表达自己清高的形象，而是，独处确确实实妙不可言，只是很多人还不知道而已。</p>
<p>很多人害怕孤独，害怕孑然一身，总是寻求热闹，但是出于喧嚣的闹市的时候，他们却倍感孤独，那是一种恐惧感。如果我们不能抵抗孤独，还不如顺手接受它。内心的孤独，无论到哪里，你都是寂寞的砧上肉，盘中餐，只有内在的丰富，让你无论到哪里都能与许多伟大的灵魂为伍。</p>
<p>在这纷繁复杂的尘世，更需要能在别人怀里孤独的勇气。</p>
<h1 id="一问一世界"><a href="#一问一世界" class="headerlink" title="一问一世界"></a>一问一世界</h1><hr>
<h2 id="作品简介-4"><a href="#作品简介-4" class="headerlink" title="作品简介"></a>作品简介</h2><p>作者杨澜，新闻媒体人。作者作为一个采访过500多为当今世界上的名人，问了许多问题。如果要有一个人告诉我们，我们应该怎样提问，尤其是面对我们自己的时候，那我想本书的作者确实是一个可以给你这方面指导的人。作者是一个在中国的新闻行业有着举足轻重的地位的女主持人，她温柔，美丽。勇于最求自己心中的梦想，她以自己的坚持缔造了一个时代。</p>
<p>作者成为风云人物并不是偶然，而是她个人充分的准备和持之以恒的努力。她的坚持不仅体现在个人的事业上，还体现在了他个人的生活中。</p>
<h2 id="个人感悟-4"><a href="#个人感悟-4" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>提问是一门艺术，并不是简简单单的在句子的末尾提高声调那么简单，我们需要知道我们提问的真正目的，问题的好坏并不在于你问句中所使用的华丽辞藻，而是你能得到的回答的好坏和意义。社交生活中我们说的话多数不是陈述句，大多是问句，所以要多学学怎样提问。提问并不简单，需要提问者做充足准备，比如要了解你所问人的生活背景，专业，性格，职业等等。还要明白你提问的目的，如果回答这偏题了，提问者需要怎么引导，总之就是一种社交的技能。</p>
<h1 id="《编码》"><a href="#《编码》" class="headerlink" title="《编码》"></a>《编码》</h1><hr>
<h2 id="作品简介-5"><a href="#作品简介-5" class="headerlink" title="作品简介"></a>作品简介</h2><p>作者Charles Petzold，Window编程的开创者之一。书中，作者从生活中的普通故事，孩童时代的普通想法开始写起，通过生活中很常见的事物，把我们认为高深莫测的编码技术讲解得通俗易懂。在今天看来我们的计算机是一件极其复杂的工具，只能是天才才能设计出这样精密而又复杂的工具，但通过作者对计算机的发展历史的描述，我们发现计算机组成与设计其实都是基于一些很是简单的原理和技术，这恰巧就是人类的创造力所在，通过简单的积木搭建，加上人类自己的奇思妙想，看似复杂的计算机其实其基础是一些极其基础的技术和原理。</p>
<p>我们平时要表达情感，或者是要传送的信息，其实都是经过了某种形式的编码的，只是我们不知道而已。所以说编码无处不在。人类的一个梦想就是能创造一个能明白人类情感，或是能传送人类想表达的信息的工具，这个工具就是电脑。其实想要电脑了解我们人类的意图，原理是很简单的，只需要在电脑和人类之间约定一中电脑和人类都能理解的编码规则即可。曾经人类为了电脑（机器）能理解我们的意图，创造了很多编码，可是或多或少都存在一些问题，如果某套编码要人类理解起来容易，那么设计的电脑（机器）就越是复杂。如果要机器设计起来容易，那么人类理解该套编码就越难。当今的点脑能认识的编码是简单得不能再简单的二进制编码，这套编码让人类理解起来确实困难不少，但聪明的人类想到了一个解决这个困难的办法，就是发明一个译码器在机器和人类之间充当翻译，把机器能识别的二进制串转化为人类能理解的编码——文字、图片和视频等，或是把文字、图片和视频等转化为二进制串。</p>
<p>既然说到了二进制，也要强调下。在书中作者冲十进制说起，分析数据这种编码在人类社会生活中出现的原因和必然性，然后逐步扩展到二进制，而二进制能在现代计算机中使用，也并非偶然，为了说明二进制最终成为机器（电脑）的编码，作者回顾了人类历史上的许多通信方式，一开始人类的通信方式受到距离和时间的限制，要想远距离通信，就要抛弃实时性，要想实时通信，就要限制通信的距离。人类一直在寻找一种即能进行远距离通信，又能保证实时的通信方式。在这思想（梦想）的指导下，人类的通信有了烽火、电报等方式。而电报的通信原理和方式为现代计算机的发展奠定了不可磨灭的基础和部分理论。电报系统中的局电器为信息传输提供了理论支撑，电磁继电器的开闭，为我们传输一些简单的信息奠定了基础，而这些看似简单的信息，通过组合可以表达很大的信息量，这就是现代电脑理解的信息（编码）是二进制的由来。</p>
<h2 id="个人感悟-5"><a href="#个人感悟-5" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>一切信息都能进行某种编码方式表达，不然就不是信息。看似复杂的东西，其基础都是一些简单的原理，所以遇到问题不能复杂化，只有通过简单创造出来的东西才是伟大的。很多事物的产生或者出现并不是一蹴而就的，是需要不断演进，不断合并而创造出来的。</p>
<p>   ——————————————————————2017年04月21日</p>
<h1 id="《很杂很杂的杂学知识》"><a href="#《很杂很杂的杂学知识》" class="headerlink" title="《很杂很杂的杂学知识》"></a>《很杂很杂的杂学知识》</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作者张立辉。本书是一本介绍日常生活中的被人误解或是比较有意思的知识的书。通常来说介绍知识的书可能是枯燥乏味的，但本书读来妙趣横生，你在不知不觉中就会了解许多日常生活的知识，甚至被人们误解的常识。读这样的书不仅能增加知识，开阔眼界，同时也让一个人养成独立思考的习惯，给本就不咋丰富的生活增添色彩，了解多一点知识，会显得我们博学，多一点饭后谈资。本书有十万个为什么的特点，但不限于十万个为什么纯粹讲科学知识，它其中还涉及历史、生活等诸多方面，是开阔眼界的好书。如果你是一个人云亦云的人，我建议你看看本书，它还真有可能颠覆你的三观，打破你已有的一些知识和常识。</p>
<p>读这样的书教给我们一个浅显但很多人又做不到的道理，那就是，凡事多问为什么，多思考其中的缘由，即便你的理解只是一家之谈，但对于养成独立思考的性感极其重要。很多事物不能只从表面去理解，有许多深层的东西需要我们去抽丝剥茧。对于正在接受系统学习的在校生来说，更应该多看看这样的书，要有打破砂锅问到底的勇气和执着。很多事物，表象一个样，但本质去是和表象有天壤之别的。</p>
<p>对于没有女盆友的我，我觉得读本书绝对可以装一波，在妹子面前如果对某一事物有一个标新立异的看法，一定能吸引不少目光。话又说回来，标新立异总是被大众看为一类，如果想用这一招吸引妹子，最好还是三思。但对于本书中的另一个优秀的地方，如果你用它来撩妹，那我保证你绝对不用死锁再三，直接用手，我保证你绝对能吸引很多女孩。那就是书中的幽默表达，和条理清晰的陈述方式。毕竟大部分人都是喜欢幽默风趣的人的，尤其那些懂得欣赏才华的女孩子。</p>
<h2 id="个人感悟-6"><a href="#个人感悟-6" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>这个世界很大，知识你永远学不完，但我们要保证我们知道的知识都是正确，是经过我们自己抽丝剥茧思考分析过的。世界很大，你所知寥寥，希望永远在学习中，在思考中。特别要提示一事无成的我自己，你想努力，那就别躺在床上；你想成功，那就要坚持；你想了解这个世界，那就要不停的学习。</p>
<h1 id="《那些古怪又让人忧心的问题》"><a href="#《那些古怪又让人忧心的问题》" class="headerlink" title="《那些古怪又让人忧心的问题》"></a>《那些古怪又让人忧心的问题》</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>作者兰道尔.门罗[美]。是一个从NASA转型的漫画家，当他在网上看到许多网友提的问题后，萌生了一个回答这些奇怪的问题的想法，他不仅去回答了他，还是根据已经证明的理论知识去回答和推理的，并附上他擅长的火柴漫画。你是否有那么一瞬间，脑袋里突然冒出一个奇哉怪也的问题？反正我是有，特别是小时候。我以前常想一个问题，都说这个地球的资源是有限的，土地也不是很多，能养活的人是有限。但是如果我们把全世界的人都聚集到一个地方，然后剩下的地方用来耕种，那不就能养活更多的人了吗?虽然这个问题看起来很天真，也不可能实现，但在本书中作者对于类似这样的千奇百怪的问题给以了许多合理的解释，虽然也不乏许多不够严谨的漏洞，但本书的目录不是在介绍知识，而是在教我们这样去思考心中所想，且不是天马行空的想，而是要在现有的已证明是正确的知识的基础上思考。</p>
<p>该书有个特点，对于一些古怪的问题的回答都是有板有眼的，通过阅读本书，我们可以轻松愉快的学到许多的物理知识，这些都是经过验证了的知识，只是作者换了一种方式告诉你，使得这些理论知识不显得过于晦涩、枯燥和教条。</p>
<p>并不像人们普遍认为的那样不是每个问题都有答案，在本书中，作者就教给我们这样一个道理，每个问题都有答案，但要我们发挥想象，用我们已有的知识都能解答大部分了。</p>
<h2 id="个人感悟-7"><a href="#个人感悟-7" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>并不是理论知识很难，以至于在考试中很多学生都是惨不忍睹，而是我们的教科书的表达方式有问题。如果都像本书一样，用一种有板有眼幽默方式来解释这些知识，我想一定会收到奇效。幽默并不是人的天赋，但是幽默是一个人的财富。需要学会幽默的的面对一切，包括古怪的问题和无常的人生。</p>
<h1 id="《万物简史》"><a href="#《万物简史》" class="headerlink" title="《万物简史》"></a>《万物简史》</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>作者 比尔.布莱森【美】。本书描述的是衣服宏大的场景，讲述了从宇宙大爆炸到人类的产生的历史进程。很难想象这样宏大的背景，竟能通过一本书来描述和进行科学的解释，并且在描述万物的历史中顺带梳理现代各个学科的发展历史和对各个科学学科做出伟大贡献的科学家简单传记。<br>本书中我最感兴趣的是作者对当今各个学科历史发展的介绍和对那些伟大的推动人类进步的科学家的介绍，既幽默，又有科学的严肃感。科学并不一定是出自那些天才，也由那些坚守在一件事业上的添砖加瓦，转考天才，显然这个世界并没有足够多的天才，但却有足够多孜孜不倦的平凡人，他们中的一些人一生都在做同一件事，比如有些科学家，一生只收集贝类的化石，从而给给其他的古生物学家提供推断地球、声明的历史的依据。<br>作为普通人，我很难能做出改变某个学科的科学历史，但如果我能在一件事上坚持不懈，矢志不渝，奇迹还是有可能发生的。</p>
<h2 id="个人感悟-8"><a href="#个人感悟-8" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>不要认为自己渺小，其实你所知道的许多伟大的科学发现竟是那些和你养平凡的人所探索出来的。坚持你选择的事业，不因为任何外力停止它，你有可能会变得伟大，请相信，平凡并伟大不在于你的智商，而在于你坚持的情商本身。</p>
<h1 id="《我的简史》"><a href="#《我的简史》" class="headerlink" title="《我的简史》"></a>《我的简史》</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>作者斯蒂芬.霍金【英】，不错他就是当今最伟大的物理学家之一，他本身就是一个传奇，但他却塑造了物理学、宇宙学的传奇。书中他自认为自己并不像别人认为的那样事一个天才，甚至他说他是在说话的年龄偏大，看上去有点笨笨，在学校考试也不是很好，他最终能进入大学还是在于一点运气，差点就没有考上。他的传奇始于目前我们所知道的他所患的疾病，在它坐上轮椅后，他的很多科学观点都渐渐清晰。</p>
<h2 id="个人感悟-9"><a href="#个人感悟-9" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>有时候并不是老天没有给你开上另一扇窗，而是你永远盯着那扇给你关上的们，或在那里怨天尤人，或是在那里祈求上天。</p>
<h1 id="《社会工程：安全体系中的人性漏洞》"><a href="#《社会工程：安全体系中的人性漏洞》" class="headerlink" title="《社会工程：安全体系中的人性漏洞》"></a>《社会工程：安全体系中的人性漏洞》</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>作者 海德纳吉【美】。本书涉及到的学科众多，有密码学、社会工程学、心里学、计算机学、软件工程和审计学等多个学科。知识量很大，看起来有点费劲，特别是不是计算机专业出身的读者可能阅读起来有点吃力。但我个人觉得这本书是你使出吃奶的劲也要认真看完的书。首先是为了防止被恶意的黑客所利用，被骗了还帮他人数钱，我是接受不了，最近社会上传过很多老太太、大妈被骗，心甘情愿的给片子赚钱，谁阻止还跟谁急，另一反面也能增加自己的知识面，何乐不为！<br>人性都是有弱点的（讲到这里，大家可以看看《人性的弱点》这本书），黑客都是东心理学的，他们通常通过利用人性脆弱的地方给被害者造成更大的伤害。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>了解人性，避免掉入人性的某个弱点坑；了解人性，也能提高我们的情商，以免找不到女朋友的苦恼；了解人性，使我们变得左右逢源；了解人性，你就了解了社会。</p>
<h1 id="《程序员修炼之道——从小工到专家》"><a href="#《程序员修炼之道——从小工到专家》" class="headerlink" title="《程序员修炼之道——从小工到专家》"></a>《程序员修炼之道——从小工到专家》</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>作者 Andrew Hunt&amp;David Thomas[美]。本书并不是一本介绍编程技术或者是与计算机相关的技术的书，而是一本站在更高层次来剖析技术的书籍。它道出在使用技术的过程中会引发的问题，还细心的提供了很多对应的解决办法，它既适合初入职场的人看，也适合那些已入行多年的人看，它不拖泥带水，也不矫揉造作，是的，在这个繁忙的时代我们都没有时间静下来看一本书，但我觉得我应该介绍你看看这本书，它的每一句话都是成功者的总结。该书中方法论包括了平时的编码，也包含项目的管理。其实依我看来每次编码，每个函数的编写，都是和项目管理息息相关的。都应该明白，一颗螺丝沉没了一首轮船，一段代码的隐藏问题（bug）有时候也会要了一个项目的性命。<br>另外，书中基本上都是围绕时效性来写的，就是效率，数据提供的方法都基本上是为了提升开发的效率，或是项目的效率。做为一个开发者，特别是一个初级开发者，应该必须知道，什么样的代码，什么样的工具，什么样的项目管理可以提升开发，或项目的效率。书中不老生常谈的说是要去按什么方式做，而是告诉你什么样的方式有效，适不适用完全看你个人，不过我觉得，我们应该实践其中的方法，那可都是大牛们总结的经验，应该错不了。实践不要总想着一蹴而就，毕竟我们不都是天才。<br>更难得的是，本书并不显得教条，显得那样了无生趣，其中的用于或是比喻极其幽默，也和生活有很强的相关性，所以这本书是一本虽然涉及到了技术，但并不无聊的难得的好书。</p>
<h2 id="感悟-1"><a href="#感悟-1" class="headerlink" title="感悟"></a>感悟</h2><p>感觉自己虽然工作了两年，可惜还是一个小工，看了本书，发现自己达到专家级别的路途遥远啊！书中说到的许多 要避免的东西，我发现我都还在使用，比如不要靠巧合编程，我发现了，我的代码很多地方编写得很随意，发现有想当然的情绪在作怪。看了书后我也打算重构下我的代码，可惜，在领导的那里就没能通过。现在我所在的项目组在使用敏捷开发方式管理项目，但我发现，一点都不“敏捷”。在本书中提到了曳光弹开发模式，我觉得我很喜欢这种方式，我们要有试错的勇气嘛！</p>
<h1 id="《以幽默的方式过一生》"><a href="#《以幽默的方式过一生》" class="headerlink" title="《以幽默的方式过一生》"></a>《以幽默的方式过一生》</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p>作者琢磨先生，原名郭城。从书名看，作者应该是在讲述在生活中我们要怎样幽默，像有点戏谑一生的感觉。但细细读了，你发现他并不是教你在生活中怎么变得更幽默，是生活更有滋味，而是告诉我们，生活不就那样，一年四季，往返不变，循环一生。作者是一个知识渊博的人，在书中很多的地方都是使用哲学或是心理学的方式来陈述问题，说得是有理有据，也很生动幽默，书中也提到作者本人在不同地方与不同的人发生的事，对发生在自己身上的故事，作者不只是戏谑它一番，还通过自己的思考，转化成了作者本人的人生哲理。作者在书中提到的主要是个人的生活态度，家庭中扮演的角色，阅读，爱情等。读完他的书，感觉我的人生足足浪费了26年，好可惜啊！</p>
<h2 id="感悟-2"><a href="#感悟-2" class="headerlink" title="感悟"></a>感悟</h2><p>你包不抱怨，生活都在那里，而且成了你所抱怨的那样子，既然都这样了，何不潇洒的接受它，抓住机会改变它呢？我对爱情的渴望，就像将来我的另一半对我的渴望一样，把生活的绿洲直接熬成了生命中的沙漠。我对阅读，也是不能持之以恒，虽然我不挑剔所读的书，但我骨子里的拖延症，把我从一个正常人变成了一个堕落的人。我多么希望这本书能给我一些启示：阅读贵在坚持。<br>以戏谑的方式过一生，但绝不妥协！</p>
<h1 id="《硅谷之谜》"><a href="#《硅谷之谜》" class="headerlink" title="《硅谷之谜》"></a>《硅谷之谜》</h1><h2 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h2><p>作者是鼎鼎大名的吴军博士，吴军博士还有几部其他优秀的著作，其中基本上或多或少都有涉及到硅谷这个世界的科技之都，或者干脆直接把书的大背景放于硅谷。硅谷这个地方，它太不寻常了，太成功了，一致有很多介绍硅谷的书，真可谓是多如牛毛，汗牛充栋。这些书中的其中部分一些剖析硅谷成功的书，暂且不议各书的观点是否正确，因为我们谁都不能把硅谷的成功写成一个公式，使之放之四海而皆准这正是硅谷神秘所在。《硅谷之谜》一书也是剖析硅谷的成功之谜的，但其不落窠臼，不从那些高深的原因入手，而是根据这个世界的一些社会规律，循序渐进的剖析其成功的原因。首先是硅谷“叛徒”精神，这或许听上去有点理想主义的情怀，但就我个人而言，理想这个东西有着极其强大的原生内力，时下国内“情怀”这个词用得实在过于泛滥，但我认为其中有许多是伪情怀，伪理想。其次是硅谷的包容精神，硅谷这个地方是一个国际化很高的地方，吸引了来自世界各地的最有秀的人才。再次对失败的宽容精神，只有能宽容失败，才会有跟多人去冒险，去尝鲜，创新才会有进步，我觉得这是当下的中国应该学习的。最后就是天时，硅谷直接跳过了后工业时代，也就是机械时代，直接进入信息时代，以致硅谷的处事风格完全没有机械式的思维。书中提到的一个重点就是“三论”成就了硅谷的企业、科技、技术和企业文化。我还要强调的一点是，当今中国有一个地方与硅谷所处的时代背景极其相似，就是深圳，可以说深圳市中国的创新意愿最强的城市。</p>
<h2 id="感悟-3"><a href="#感悟-3" class="headerlink" title="感悟"></a>感悟</h2><p>作为从事IT行业的我，应该要学习硅谷的那种理想主义和改变世界的情怀，而不只要把眼睛脂肪于国内那一亩三分地。理想还是要有的，万一实现了呢！</p>
<h1 id="《历史的温度》"><a href="#《历史的温度》" class="headerlink" title="《历史的温度》"></a>《历史的温度》</h1><h2 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h2><p>作者张玮。作者从别样的视角审视历史人物和历史事件，给人一种如进入当时的历史事件中，或是就是历史事件中的那个人，有些事情或人物也会触动我们。中国的历史太长了，以致于那些本可以大书特书的历史人物，在我学校的课本中，很多都是一笔带过，或只道明其过错，或只道明其为事的结果，留下的很多空白需要学生娃娃们自己去补白。但以历史书中给明的结果为导向，我们发现在历史课本中泾渭分明地分出了两派，一派买过求荣，践踏人民的坏人；另一派誓死报国，为民谋利的先哲圣贤。其实我们有没有自己思考过，如果处在历史人物所处的时代背景下，我们选择又会是什么呢？历史不容假设，我们也姑且把历史当做历史看吧。<br>今天看到这本书，爱不释手，一天就看完了。主要是该书补白了我所知道的历史，站在历史事件的大背景下去分析历史人物和历史事件，让我有种如临其境的感觉，读到某些地方会潸然流泪，读到另一些地方会佩服历史人物的英明决断和大无畏的精神。讲到历史人物并不是一味说起好，或是道其错，作者只是讲故事，是非成败自有后人说。</p>
<h2 id="感悟-4"><a href="#感悟-4" class="headerlink" title="感悟"></a>感悟</h2><p>历史是成功者所写，其中的真实性，我们不用去怀疑，就算怀疑，也无所证，但我们要有自己的历史观和人生观，不能人云亦云，人为亦为。历史人物并不是你书中的那几个冷冰冰的文字，在这文字的背后是人性，要学会透过文字看人性，透过时代看人物。</p>
<h1 id="《曾国藩家书》"><a href="#《曾国藩家书》" class="headerlink" title="《曾国藩家书》"></a>《曾国藩家书》</h1><h2 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h2><p>本书是根据历史资料整理所得，我本人看的是电子书。从中不难一窥历史上中国文人的家国情怀及处世为人之道。期上对父母长辈孝顺，下对妻儿严厉；对待兄弟部下也是颇为严厉；对待同事也是过多的谦虚谨慎。有种徐怀若谷的情怀。不过个人觉得其过于愚忠，也过于谨慎。从其近百封家书中可以看出他的每一步都在为下一步打算，体现出其谨小慎微的性格。但个人觉得是大丈夫就应该气魄一点，这种想法也估计是我本人的一大缺点，易怒！</p>
<h2 id="感悟-5"><a href="#感悟-5" class="headerlink" title="感悟"></a>感悟</h2><p>人无完人，但必须做的事情能上对天地，做个顶天立地的人，对父母，做个孝顺的晚辈。对待妻儿，要宽严并用，自己要起到榜样的作用。对于自己要坚持做正确的事，任何一件事，只要你坚持了，应该都有其回报</p>
]]></content>
    
    <summary type="html">
    
      2017年打算阅读100本书，不分类别，是书就行。为此，在这里简略的记录下自己的阅读感慨
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Winodws 下搭建wiki知识库</title>
    <link href="http://yoursite.com/2016/12/31/Winodws-%E4%B8%8B%E6%90%AD%E5%BB%BAwiki%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <id>http://yoursite.com/2016/12/31/Winodws-下搭建wiki知识库/</id>
    <published>2016-12-31T11:54:54.000Z</published>
    <updated>2016-12-31T15:59:05.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写本文的起因"><a href="#写本文的起因" class="headerlink" title="写本文的起因"></a>写本文的起因</h1><hr>
<p>在平时的工作和学习的过程中积累了许多的知识和经验总结，苦于难以管理，时间长了，找到一些之前的总结就比较困难。为此需要一款能够管理成体系的管理知识的工具，我就选定了dokuwiki。</p>
<h1 id="dokuwiki简介"><a href="#dokuwiki简介" class="headerlink" title="dokuwiki简介"></a>dokuwiki简介</h1><hr>
<ol>
<li>一款开源的wiki引擎程序，运行与PHP环境下。</li>
<li>小巧而功能强大，灵活，适合中小团队和个人网站知识库的管理。</li>
<li>可以多种CMS程序进行整合，例如<a href="http://baike.baidu.com/subview/23618/23618.htm" target="_blank" rel="external">WordPress</a>、<a href="http://baike.baidu.com/subview/685204/685204.htm" target="_blank" rel="external">XOOPS</a>、PostNuke等。</li>
<li>不需要数据库，采用文本文件直接存储<h1 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h1></li>
</ol>
<hr>
<ol>
<li>下载<a href="https://download.dokuwiki.org/" target="_blank" rel="external">dokuwiki</a>.</li>
<li>下载PHP运行环境：<a href="https://www.apachefriends.org/zh_cn/index.html" target="_blank" rel="external">XAMPP</a><h1 id="安装PHP开发环境-XAMPP"><a href="#安装PHP开发环境-XAMPP" class="headerlink" title="安装PHP开发环境:XAMPP"></a>安装PHP开发环境:XAMPP</h1></li>
</ol>
<hr>
<p>和安装普通的Windows软件并没有区别</p>
<h1 id="部署dokuwiki"><a href="#部署dokuwiki" class="headerlink" title="部署dokuwiki"></a>部署dokuwiki</h1><hr>
<p>解压下载的dokuwiki，把整个dokuwiki目录放到XAMPP的安装目录下的htdocs目录下。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><hr>
<p>在XAMPP的安装目录下打开XAMPP的控制面板，启动Apache（因为dokuwiki运行需要Apache服务器）。<br>在浏览器中输入：<a href="http://localhost/dokuwiki" target="_blank" rel="external">http://localhost/dokuwiki</a> 。就可以访问你部署的dokuwiki了。</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><hr>
<p>在浏览器中输入：<a href="http://localhost/dokuwiki/install.php，就可以看到wiki的安装配置项了，在右上角还可以选择语言。" target="_blank" rel="external">http://localhost/dokuwiki/install.php，就可以看到wiki的安装配置项了，在右上角还可以选择语言。</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.dabu.info/dokuwiki-installation-and-configuration.html" target="_blank" rel="external">http://www.dabu.info/dokuwiki-installation-and-configuration.html</a></p>
]]></content>
    
    <summary type="html">
    
      作为一个程序员，在工作或学习的过程中难免遇到许多需要记下的知识点，如果只是很少的知识，我们直接用操作系统自带的文档管理系统，建一些目录就能轻松搞定自己平时的知识的积累，但是当我们的积累的东西过多了之后就会发现我们的积累很难管理。我们这时通常想的是希望有一个能对知识进行结构化管理的工具，wiki就是其中以中工具，具有强大的知识库管理功能。下面我将介绍一下怎么在Windows系统下安装部署wiki。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的2016</title>
    <link href="http://yoursite.com/2016/12/31/%E6%88%91%E7%9A%842016/"/>
    <id>http://yoursite.com/2016/12/31/我的2016/</id>
    <published>2016-12-31T10:14:14.000Z</published>
    <updated>2017-01-01T09:14:27.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="满怀希望的起航-怅然无措的结束"><a href="#满怀希望的起航-怅然无措的结束" class="headerlink" title="满怀希望的起航 怅然无措的结束"></a>满怀希望的起航 怅然无措的结束</h1><p>过完2016年的春节，没几天，我又踏上了离乡的路途。带着自己的梦想和亲人的寄托，我独自一人又一个去了远方。这一次看似和以前并没有什么不同，但却也有些许变化，这一次春节后离家并不是去另一个温馨的家——校园，而是有一点悲壮之感——去闯荡江湖了。梦想着在这个纷乱复杂的江湖中打下自己的一片天地，成就一番事业。真是一入江湖岁月催，眨眼功夫，还在做着白日梦，还在天真的以为这个江湖就是我大展拳脚的地方，在江湖这片天地中，我定当能成就一番功名。却不成想，也就在今天我快要关上了2016的大门了，我已经不能再次拜访者无所收获的2016了。唯有把这一年的点滴记录下来，以慰即将逝去的2016。2016年一过我又长大一岁了，不！不是长大一岁，而是成熟一岁了，唉！突然发现成长这个词语已经不适用在我的身上了。心中满是仿徨与失望。</p>
<h1 id="泯然一个市井之徒"><a href="#泯然一个市井之徒" class="headerlink" title="泯然一个市井之徒"></a>泯然一个市井之徒</h1><p>记得2016年的元旦前夕，公司部门采访了个人的新年愿望，我当时无知的把我的新年愿望写为：成为一个技术牛人。眨眼间，我来到了2017年的元旦的前夕。回想当时的新年愿望，觉着我自个真是很傻很天真的标杆人物啊！<br>经过2016一整年，虽然自己在工作中也是一如既往的一丝不苟，但却没有觉着自己的技术有些许进步，相反，我却觉着自己比以前知道的更少、更无知。即便在这平凡的一年中，个人的梦想仍没被时间抹杀分毫，但也不得不面对现实，我确实进步甚少。参加工作一年以来，自己并没有多大进步，却泯然众人矣。<br>我不得承认，我已经从一个意气风发的学生时代的少年变成了一个市井之徒。是环境的原因？是个人的原因？我不得而知，但我觉着我应该寻求改变。</p>
<h1 id="忙睡觉的月下老人，贪玩的丘比特"><a href="#忙睡觉的月下老人，贪玩的丘比特" class="headerlink" title="忙睡觉的月下老人，贪玩的丘比特"></a>忙睡觉的月下老人，贪玩的丘比特</h1><p>那时我想，我还小，还年轻，不着急恋爱，不着急找一个能懂我的人，况且，找一个懂我的人，那就如同在这浩瀚的宇宙中寻找地外生命一样的难。如今真的觉着自己已经到时间来一场恋爱的洗礼的时候，却发现我周围的资源是少得异乎寻常。<br>我虽然条件不好，但在人海中找不到一个人能看上我？我觉着没有可能。我估摸着是那个老糊涂的，为别人搭线的月下老人在月亮下睡着了。这个老人不靠谱，本指望那个可爱的小孩能拿我的一支箭射中某一个忧郁的怀着丁香般惆怅的姑娘，可惜他好像正在玩耍，也不见得会里一下我。<br>这两位神和我开了一个玩笑。我也觉着两个高高在上的神怎会拿我这样一个小人物来开玩笑呢，但也许我真的不是一个小人物。<br>估计今年回家又不安心了，我老妈，不知从什么时候开始就希望能抱孙子了，反正今年又要对不起妈她老人家了。</p>
<h1 id="失信于自己"><a href="#失信于自己" class="headerlink" title="失信于自己"></a>失信于自己</h1><p>在2016年的到来的时候，我决定每周看一本书，沉淀自己的知识与提高自己的智商。但在后来2016的旅途中，我找各种理由来阻碍了这个伟大的梦想。我一直坚持做一个不失信与人的人，但我发现对别人承若，我基本都能信守承若，却没有把我自己当一个人来看，我居然失信于我自己了。<br>在2016年的年初，我计划，花几个月的时间来做一个开源的网站，但后来我没有坚持下来，我再次失信于我自己。<br>在2016刚开始的时候，当我遇见我心怡的女孩我一定下手，但当我真的遇到后，我又不忍心了。<br>计划来次牛逼点，规格高点的旅行，但由于死宅，计划没有成行。</p>
<h1 id="匆忙的2016，慢条斯理的我"><a href="#匆忙的2016，慢条斯理的我" class="headerlink" title="匆忙的2016，慢条斯理的我"></a>匆忙的2016，慢条斯理的我</h1><p>曾经的岁月，自己白长了，直到今天我才发现，这个时间过得太他妈快了，小息一会就要到2017了。我他妈一直以年轻为资本，很多反驳的理由都是还早，但马上翻过2016的时候，我才发现他妈的一点都不早了，他妈的我一点都不小了，相反我发现我有点老了，老得都不知道时间了，老得任性都不知道了。背对2016离开时，我喊了一声，时间，你慢点吧，可回音只在2017的天空徘徊，2016失去了一切响应。</p>
<h1 id="面对2017"><a href="#面对2017" class="headerlink" title="面对2017"></a>面对2017</h1><p>面对2017我觉着我成熟了不少，我决定不再随便许诺，尤其是对我自己；不再随便敷衍，尤其是对我自己；不再懦弱，尤其是在面对月下老人和丘比特时。我要相信这个世界的规律，人总会老去，很多事不要等着，拖到将来，其实现在就是过去的将来。</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>曾经我们希望成长，而今我们不能成长了，只能成熟了！</p>
]]></content>
    
    <summary type="html">
    
      即将跨入2017年，我想想的2016年是不是应该留下些什么，我不想在将来的某一天提到2016，在我的思绪深处却没有什么印象，空白一片，就像2016曾经在我的生命中与我插肩而过一样，没有丝丝留恋；没有分毫经历；故此，在这里记下一笔，即便我的2016年并不想你或者我想的那样精彩，但她毕竟路过了我的生命，我也需要给她一点生气，一点空间。
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 学习</title>
    <link href="http://yoursite.com/2016/10/23/NodeJs-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/10/23/NodeJs-学习/</id>
    <published>2016-10-23T08:26:26.000Z</published>
    <updated>2016-10-23T09:48:33.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NodeJs的回调"><a href="#NodeJs的回调" class="headerlink" title="NodeJs的回调"></a>NodeJs的回调</h1><hr>
<ul>
<li><p>Node.js 异步编程的直接体现就是回调。</p>
</li>
<li><p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>
</li>
<li><p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
</li>
</ul>
<p><strong><em>注意：异步代表代码是非阻塞的，阻塞按是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</em></strong></p>
<h1 id="NodeJs的事件驱动模型"><a href="#NodeJs的事件驱动模型" class="headerlink" title="NodeJs的事件驱动模型"></a>NodeJs的事件驱动模型</h1><hr>
<ul>
<li><p>Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</p>
</li>
<li><p>Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</p>
</li>
<li><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>
</li>
<li><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>
<h2 id="一个简单的事件驱动模型例子"><a href="#一个简单的事件驱动模型例子" class="headerlink" title="一个简单的事件驱动模型例子"></a>一个简单的事件驱动模型例子</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>
</li>
</ul>
<p><strong><em>注意：这里的观察者模式的观察者（Observer）是事件处理函数，主题（Subject）是事件</em></strong></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>// 引入 events 模块 
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
// 创建事件处理程序
var connectHandler = function connected() {
console.log(&apos;连接成功。&apos;);
// 触发 data_received 事件 
eventEmitter.emit(&apos;data_received&apos;);
}
// 绑定 connection 事件处理程序
eventEmitter.on(&apos;connection&apos;, connectHandler);
// 使用匿名函数绑定 data_received 事件
eventEmitter.on(&apos;data_received&apos;, function(){
console.log(&apos;数据接收成功。&apos;);
});
// 触发 connection 事件 
eventEmitter.emit(&apos;connection&apos;);
console.log(&quot;程序执行完毕。&quot;);
</code></pre>]]></content>
    
    <summary type="html">
    
      NodeJs的基础知识的学习，学习NodeJs的基础是需要了解一些JavaScript的知识。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>npm使用介绍</title>
    <link href="http://yoursite.com/2016/10/20/npm%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/10/20/npm使用介绍/</id>
    <published>2016-10-20T14:42:16.000Z</published>
    <updated>2016-10-20T14:44:22.136Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.runoob.com/nodejs/nodejs-npm.html" title="npm使用介绍" target="_blank" rel="external">http://www.runoob.com/nodejs/nodejs-npm.html</a></p>
]]></content>
    
    <summary type="html">
    
      npm使用介绍的相关网站
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="前端编程" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署问题</title>
    <link href="http://yoursite.com/2016/10/20/hexo%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/10/20/hexo部署问题/</id>
    <published>2016-10-20T14:33:23.000Z</published>
    <updated>2016-10-20T14:39:20.738Z</updated>
    
    <content type="html"><![CDATA[<p>hexo发布项目到github上时出了问题，其原因是没有配置git相关的环境变量，而hexo deploy命令需要调用git命令。<br>解决方法：</p>
<ul>
<li><p>配置git的环境变量</p>
</li>
<li><p>直接使用git的命令窗口运行hexo相关的命令，尤其是hexo deploy命令</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo发布项目到github上时出了问题，其原因是没有配置git相关的环境变量，而hexo deploy命令需要调用git命令。&lt;br&gt;解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置git的环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接使用git的命令窗口运行hexo
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue开发大型单页应用的步骤</title>
    <link href="http://yoursite.com/2016/10/20/%E4%BD%BF%E7%94%A8Vue%E5%BC%80%E5%8F%91%E5%A4%A7%E5%9E%8B%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2016/10/20/使用Vue开发大型单页应用的步骤/</id>
    <published>2016-10-20T13:24:13.000Z</published>
    <updated>2016-10-20T14:06:20.584Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>首先开发机器上要安装nodejs服务（怎么安装网上有一堆教程）。</li>
<li><p>安装js包管理器npm。如果你安装的是比较新的nodejs,则npm包管理器已经随之安装，如果使用的是比较旧版的nodejs可能需要自己安装npm包安装管理器。也有可能你觉得随nodejs一起安装的npm比较旧，我们可以通过如下命令安装npm。   </p>
<blockquote>
<p>sudo npm install npm -g（Linux系统）</p>
<p>npm install npm -g （windows系统）</p>
</blockquote>
</li>
<li><p>npm是所谓的包管理器，所以可以通过npm命令安装nodejs模块</p>
<blockquote>
<p>npm install &lt; Module Name &gt;</p>
</blockquote>
</li>
<li><p>使用npm安装Vue</p>
<blockquote>
<p>npm install vue （本地安装）</p>
<p>npm install vue -g (全局安装)</p>
</blockquote>
</li>
<li><p>使用npm安装Vuejs官方提供的一个可以快速搭建大型单页应用的命令行工具 vue-cli,该工具其实是一个脚手架</p>
<blockquote>
<p>npm install -g vue-cli</p>
</blockquote>
</li>
<li><p>创建一个基于“Webpack”模板的项目</p>
<blockquote>
<p>vue init webpack &lt; my-project &gt;</p>
</blockquote>
</li>
<li><p>安装依赖</p>
<blockquote>
<p>cd &lt; my-project &gt;</p>
<p>npm install</p>
<p>npm run dev(启动应用)</p>
</blockquote>
</li>
<li><p>编译单页应用</p>
<blockquote>
<p>npm run build</p>
</blockquote>
</li>
</ul>
<p><strong>注意：手动编译Vue最新的代码</strong></p>
<blockquote>
<p>git clone <a href="https://github.com/vuejs/vue.git" target="_blank" rel="external">https://github.com/vuejs/vue.git</a> node_modules/vue</p>
<p>cd node_modules/vue</p>
<p>npm install</p>
<p>npm run build</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      本文主要讲解怎么快速构建一个基于Vue的大型的单页应用。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编码学习" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编码过程中的注意事项</title>
    <link href="http://yoursite.com/2016/09/14/%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yoursite.com/2016/09/14/编码过程中的注意事项/</id>
    <published>2016-09-14T15:20:54.000Z</published>
    <updated>2016-09-15T03:48:38.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中发现最令我苦恼的居然是怎么给一个变量、方法或函数命名，有时候会纠结我一个上午，甚至一天之后还会耿耿于怀。所以一直希望总结一下怎么给变量、方法或函数命名。</p>
<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>言归正传，目前比较流行的命名规则有：帕斯卡命名法和驼峰命名法。帕斯卡命名的规则是从名称的第一个字单词开始，每一个单词的首字母大写；驼峰命名的规则是名称的第一个单词全部字母小写，之后的每个单词的首字母大写。一般来说类名称采用帕斯卡命名法，变量名和方法或函数名采用驼峰法命名规则。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>见名知意：通常来说，一个变量的名称应该能表现它的使用场景、范围、性质等，一个方法或函数的名称应该尽可能描述其功用和动作。</li>
<li>对于方法或函数的命名通常要用动词，因为方法或函数表现得就应该是一个动作（这里的一个动作很重要，不要一个方法包含过多的动作，方法的职责应该单一）。</li>
<li>命名是不要用一些太泛泛的单词，而应该具体点，最好根据使用场景命名。例如对于获取数据，很多人都是用getSomething,这有点泛泛。为了命名的精准，应该多积累词汇。对于获取数据：如果只是简单的返回数据，使用getSomething；如果是从远程获取数据，使用fetchSomething；如果只是从本地加载数据，使用loadSomething；如果是从缓存中获取数据，使用findSomething；如果是通过某些数据衍生而来，可以使用createSomething(data)，buildSomething(data)，parseSomething(data)。</li>
<li>不同的项目，因为使用场景的、使用技术不同，很可能命名规则也不同。在项目进行前，应该先规范整个团队的命名规则。</li>
<li>函数使用者在调用函数时，参数名称应该跟函数定义者给的形参的名称一致。</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><ul>
<li>不要用boolean变量作为函数的参数，如果出现这种情况，需要考虑重写函数。</li>
<li>不要修改传入函数中的参数。</li>
<li>返回不能是传入的参数，否则意味着一个函数中实现了不止一个功能，要进来达到单一职责原则。</li>
</ul>
<h2 id="函数体编写"><a href="#函数体编写" class="headerlink" title="函数体编写"></a>函数体编写</h2><ul>
<li>必须是相关的操作放在一起构成一个函数，而不是一个函数只求功能齐全，而不注重复用，函数就是复用的最小单元。</li>
<li><p>尽量减少代码嵌套</p>
<blockquote>
<ol>
<li>函数最容易终止的判断分支放在判断的最前面。</li>
<li>如果使用判断语句，发现判断分支太多，就不应该使用判断，换一种方法实现同样的功能，例如使用表驱动法。</li>
</ol>
</blockquote>
<p>  if(condition == “case1”){ </p>
<pre><code>return 1; 
</code></pre><p>  } elseif(condition == “case2”){</p>
<pre><code>return 2; 
</code></pre><p>  } elseif(condition == “case3”){</p>
<pre><code>return 3;
</code></pre><p>  } elseif(condition == “case4”){</p>
<pre><code>return 4; 
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>表驱动方法</p>
</blockquote>
<pre><code>var map = { 
    &quot;case1&quot;:1,
    &quot;case2&quot;:2, 
    &quot;case3&quot;:3, 
    &quot;case4&quot;:4 
} 
return map[condition];
</code></pre><blockquote>
<p>3.多层嵌套时，可以提取内层嵌套为一个函数或方法进行调用。</p>
<p>4.for循环的嵌套层数应该尽可能的少</p>
</blockquote>
<ul>
<li>提取复杂逻辑，语义化</li>
</ul>
]]></content>
    
    <summary type="html">
    
      工作中关于变量、方法或函数命名规范的总结。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一些疑问</title>
    <link href="http://yoursite.com/2016/09/04/%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE/"/>
    <id>http://yoursite.com/2016/09/04/一些疑问/</id>
    <published>2016-09-04T11:18:20.000Z</published>
    <updated>2016-09-11T12:42:02.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是回调函数？"><a href="#1-什么是回调函数？" class="headerlink" title="1.什么是回调函数？"></a>1.什么是回调函数？</h1><blockquote>
<p>回调函数就是你写好一个函数，让预先写好的系统来调用。你去调用系统的函数，是直调。让系统调用你的函数，就是回调。回调函数可以看成，让别人做事，传进去的额外信息。</p>
<p>简单一点说：回调函数是调用者传递给被调用者的函数。做什么事只有调用者知道，但调用者不能直接去“做”，因为调用者可能不具备执行这个动作的全部条件；但是被调用者具有执行这个动作的所有条件，只是他不知道该怎么去做。调用者调用被调用者时传递回调函数给被调用者，就告诉被调用者用其所具备的条件去执行这个动作。其中：做什么样的事就是回调函数。</p>
<p>在动态语言中表现为直接传递一个方法（或函数）；在静态语言中可能是通过函数指针来传递的（例如C），也可能是通过interface实现的（例如Java）</p>
<p>实现这种机制的原理：函数接受的参数，我们通常叫做“数据”，其实这是不完全正确的，其实我们传递给函数的参数实质都是二进制代码。基本类型的数据可以看成是二进制，函数类型的数据也是可以看做二进制的。总之代码和数据都是一个性质，共性都是信息。</p>
</blockquote>
<h1 id="2-CSS中的绝对定位和相对定位"><a href="#2-CSS中的绝对定位和相对定位" class="headerlink" title="2.CSS中的绝对定位和相对定位"></a>2.CSS中的绝对定位和相对定位</h1><p><strong>相对定位</strong>：就是一个元素本身自己位置的变化，如一个元素开始时设置其position的值为relative，那么它就会在文档流中占据一个自己本身的位置，当设置了其top和left值后就会相对于它本身的位置偏移。在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。那么我们就会想了怎么让框三把框二覆盖呢，很自然的想到把框3的z-index设为一个优先级高的值如100，但是这样并不能得到我们想要的结果，必须把框2的z-index设为优先级低的如-1。相对定位就是文旦流的默认定位方式。</p>
<p><strong>绝对定位</strong>：使用的绝对定位（position:absolute）的元素不存在文档流中，普通流中其它元素的布局就像绝对定位的元素不存在一样，所以在文档流中不占据空间。因此如果一个元素的position设置为absolute，会影响它的兄弟元素的相对定位（默认定位）从而改变它的兄弟节点在文档流中的位置。绝对定位的元素的位置相对于最近的已定位（拥有position属性）祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。</p>
<p>总之，相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p>
<p>扩展，还可以使用margin属性来进行绝对定位，这时元素也脱离了文档流，不管它的祖先元素有没有定位，都是以文档流中原来所在的位置上偏移参照物。  </p>
]]></content>
    
    <summary type="html">
    
      解答编码中遇到的一些疑难、重点知识。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编码学习" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>个人博客——基于hexo的Github.page</title>
    <link href="http://yoursite.com/2016/09/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84Github%20Page/"/>
    <id>http://yoursite.com/2016/09/03/个人博客——基于hexo的Github Page/</id>
    <published>2016-09-03T11:45:37.000Z</published>
    <updated>2016-09-04T08:58:32.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客——基于hexo的Github-page"><a href="#个人博客——基于hexo的Github-page" class="headerlink" title="个人博客——基于hexo的Github.page"></a>个人博客——基于hexo的Github.page</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>安装NodeJs</li>
<li>安装Git</li>
</ul>
<h2 id="在github上创建仓库"><a href="#在github上创建仓库" class="headerlink" title="在github上创建仓库"></a>在github上创建仓库</h2><p>建立与你用户名对应的仓库，仓库名必须为【yourusername.github.io】</p>
<center><br><img src="http://i2.buimg.com/567571/b5aabb76dc5a87c2.png" alt="Alt loading" title="新建仓库"><br></center>

<center><br><img src="http://i4.buimg.com/567571/3b507106c15b47a5.png" alt="Alt loading" title="填写新建仓库的信息"><br></center>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code>//全局安装hexo,安装完成后可以在nodejs/node_gloabal/node_modules下看到
$ npm install hexo-cli -g
</code></pre><h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><pre><code>$ hexo init &lt;floder&gt; #初始化blog所在的文件夹
$ cd blog #进入你所设置的blog文件夹
$ npm install
$ hexo server #启动hexo
$ hexo new &quot;Hello Hexo&quot; #新建一个名叫 Hello Hexo的博文
$ hexo generate #生成通用的静态文件
</code></pre><p>进入blog目录：</p>
<center><br><img src="http://i2.buimg.com/567571/1cf76e414967c4d6.png" alt="Alt loading" title="运行hexo init &lt;floder&gt;生成的blog的目录结构"><br></center>

<p>启动hexo生成的blog：</p>
<center><br><img src="http://i2.buimg.com/567571/6eb68cc3c7a76fd9.png" alt="Alt loading" title="成功启动hexo"><br></center>

<p>访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>:</p>
<center><br><img src="http://i2.buimg.com/567571/7de0d6da7ae949a8.png" alt="ALt loading" title="浏览器中成功访问生成的blog"><br></center>

<h2 id="Hexo常用的命令"><a href="#Hexo常用的命令" class="headerlink" title="Hexo常用的命令"></a>Hexo常用的命令</h2><pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
hexo clean #清空public目录下生成的内容
</code></pre><h2 id="修改配置文件-config-yml"><a href="#修改配置文件-config-yml" class="headerlink" title="修改配置文件 _config.yml"></a>修改配置文件 _config.yml</h2><p>该文件中多数选项都有说明，按照说明配置即可。这里主要介绍如何把Hexo构建的blog部署到github page上。</p>
<p>部署方式配置前：</p>
<center><br><img src="http://i2.buimg.com/567571/cb0cd68f7c7bed4e.png" alt="ALt loading" title="部署方式配置前"><br></center>

<p>部署方式配置后,（仓库地址获取于github上新建的名称为yourusename.github.io的库）</p>
<center><br><img src="http://i2.buimg.com/567571/bd2ca1fcf811e9cf.png" alt="Alt loading" title="部署方式配置后"><br></center>

<center><br><img src="http://i2.buimg.com/567571/113d87f21a6a3502.png" alt="Alt loading" title="获取仓库地址"><br></center>

<h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>这里主要讲解设置主题：Tinnypp</p>
<p>1.安装Tinnypp</p>
<pre><code>cd themes
git clone git@github.com:levonlin/Tinnypp.git
</code></pre><center><br><img src="http://i2.buimg.com/567571/e86eb329acd6f195.png" alt="Alt loading" title="安装Tinnypp主题"><br></center>

<p>2.修改_config.yml配置文件中的主题设置为：Tinnypp</p>
<center><br><img src="http://i4.buimg.com/567571/4a28326b980d9290.png" alt="Alt loading" title="修改主题"><br></center>

<p>3.更新主题</p>
<pre><code>cd themes/Tinnypp
git pull
</code></pre><p>4.设置主题配置信息</p>
<p>（1）设置blog首页的按钮，如果直接使用默认配置，点击按钮会出现404错误，原因是blog部署后按钮所指向目录就是根目录。</p>
<center><br><img src="http://i2.buimg.com/567571/98bc8d9a49063abe.png" alt="Alt loading" title="按钮的URL设置前"><br></center>

<center><br><img src="http://i4.buimg.com/567571/2b36fd9a01bfe314.png" alt="Alt loading" title="按钮的URL设置后"><br></center>

<p>（2）已经设置/atom.xml为rss源。要使用rss,先安装hexo的rss插件：</p>
<pre><code>$npm install hexo-generator-feed --save
</code></pre><p> 修改Tinnypp配置文件_config.yml中的RSS设置，因为安装rss源是在根目录下/atom.xml，但是默认的配置文件中的RSS 地址是: /Tinnypp/atom.xml</p>
<center><br><img src="http://i2.buimg.com/567571/69b0a373a5c0a75f.png" alt="Alt loading" title="修改前"><br></center>

<center><br><img src="http://i2.buimg.com/567571/97bb747d68ce2823.png" alt="Alt loading" title="修改后"><br></center>

<p>5.主题切换后 blog的首页</p>
<center><br><img src="http://i2.buimg.com/567571/7c1868648614812c.png" alt="Alt loading" title="切换主题后的首页"><br></center>

<p>6.设置tags和categories</p>
<p>(1).tags设置</p>
<p>在themes/Tinnypp/source/下新建文件夹tags，在文件夹中新建文件index.md，在index.md文件中新增内容：</p>
<center><br><img src="http://i4.buimg.com/567571/22b36d60fb766cc9.png" alt="Alt loading" title="index.md中的内容"><br></center>

<p>(2).categories设置<br>在themes/Tinnypp/source/下新建文件夹categories，在文件夹中新建文件index.md，在index.md文件中新增内容：</p>
<center><br><img src="http://i4.buimg.com/567571/22b36d60fb766cc9.png" alt="Alt loading" title="index.md中的内容"><br></center>

<p>设置后的目录结构：</p>
<center><br><img src="http://i1.piimg.com/567571/ba893bb91a362072.png" alt="Alt loading" title="tags和categories设置"><br></center>

<p>7.新建blog文章</p>
<pre><code>hexo new &quot;Test&quot;
</code></pre><p>打开blog目录下的../source/_posts/Test.md文件</p>
<center><br><img src="http://i1.piimg.com/567571/caa7baa5aab508de.png" alt="Alt loading" title="默认内容"><br></center>

<p>修改默认内容后</p>
<center><br><img src="http://i2.buimg.com/567571/f204735ba668d05e.png" alt="Alt loading" title="修改后的默认内容"><br></center>

<p>8.重新启动hexo查看设置情况</p>
<pre><code>hexo clean
hexo generator
hexo server
</code></pre><center><br><img src="http://i1.piimg.com/567571/5aadbc05c5aca7fa.png" alt="Alt loading" title="tags和categories设置后的blog首页"><br></center>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo安装配置</a></li>
<li><a href="http://www.isetsuna.com/hexo/introduction/" target="_blank" rel="external">hexo安装配置1</a></li>
<li><a href="http://www.isetsuna.com/hexo/install-config/" target="_blank" rel="external">hexo安装配置2</a></li>
<li><a href="http://www.isetsuna.com/hexo/theme-plugin/" target="_blank" rel="external">hexo安装配置3</a></li>
<li><a href="http://www.isetsuna.com/hexo/writing-image/" target="_blank" rel="external">hexo安装配置4</a></li>
<li><a href="http://www.isetsuna.com/hexo/deploy-github-gitcafe/" target="_blank" rel="external">hexo安装配置5</a></li>
<li><a href="http://www.isetsuna.com/hexo/deploy-qiniu/" target="_blank" rel="external">hexo安装配置6</a></li>
<li><a href="http://www.isetsuna.com/hexo/domain-dns/" target="_blank" rel="external">hexo安装配置7</a></li>
<li><a href="https://github.com/levonlin/Tinnypp" target="_blank" rel="external">博客主题切换</a></li>
<li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/" target="_blank" rel="external"> hexo部署个人博客全</a></li>
<li><a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html" target="_blank" rel="external">利用swiftype为hexo添加站内搜索v2.0</a></li>
<li><a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">个人blog搭建全</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      通过Hexo生成、部署个人博客到Github Page上，本文涉及到Hexo的安装、个人博客网站的生成并对生成的网站代码进行重新配置、主题的切换及部署。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="安装学习" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
