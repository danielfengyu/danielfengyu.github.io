<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山间听雨者主页</title>
  <subtitle>个人学习总结</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-11T05:57:14.260Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Daniel</name>
    <email>fengyu153610@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java面试宝典</title>
    <link href="http://yoursite.com/2018/03/10/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    <id>http://yoursite.com/2018/03/10/Java面试宝典/</id>
    <published>2018-03-10T03:02:34.000Z</published>
    <updated>2018-03-11T05:57:14.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="JDK目录结构"><a href="#JDK目录结构" class="headerlink" title="JDK目录结构"></a>JDK目录结构</h2><ul>
<li>bin JDK开发工具的可执行文件，配置java的环境变量的时候Path需要指向该目录</li>
<li>lib 开发工具使用的归档包路径</li>
<li>jre java运行时环境的根目录，包含java虚拟机，运行时的类包，java应用的启动器,java应用程序要运行起来依赖的最小目录</li>
<li>include 包含C语言头文件,支持Java本地接口与Java虚拟机调试程序接口。</li>
<li><p>jre/lib 代码库、树形设置以及JRE使用的源文件。rt.jar是java运行时类库，是用得最多的基础类库，包含java.lang,java.io,java.net,java.util等。</p>
<ol>
<li>java.lang：其下的类不需要显示import，包括object类，数据类型相关类（Integer等），Class类，线程相关类Thread，异常类Throable。</li>
<li>java.io：I/O操作相关的类，包括文件File，FileReader，FileWriter，输入输出流InputStream/OutputStream等。</li>
<li>java.net：网络相关类，HTTP链接类HttpURLConnecion,socket类等。</li>
<li>java.util：数据结构相关的类ArrayList、Hashmap，日期类Date，随机数类Random类等。</li>
</ol>
</li>
<li>/jre/lib/ext Java平台的扩展程序(插件等)的默认安装目录。</li>
<li>/jre/lib/security 包含用于安全管理的文件。这些措施包括安全策略（java.policy）和安全性（java.security）文件。</li>
<li>db Java实现的数据库</li>
</ul>
<p>JDK包含了java程序的运行环境和开发工具。借助java开发工具中的编译器javac.exe，我们可以把.java文件编译为在任何平台上都一样的.class文件。jre（包含jvm，java运行时类库和动态链接库（.dll）等信息）为java的执行提供了运行环境，可以加载javac.exe编译后的.class文件，并把其转化为对应平台上的机器码，由此可见在不同的平台上jvm的实现是不一样的。</p>
<h2 id="I-O体系架构"><a href="#I-O体系架构" class="headerlink" title="I/O体系架构"></a>I/O体系架构</h2><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul>
<li><strong>按方向：输入流（Reader和InputStream）和输出流（Writer和OutputStream）</strong>。输入输出是对程序运行的内存来说的，程序运行的部分始终处于内存中。</li>
<li><strong>按操作单元：字符流(Writer和Reader)和字节流（OutputStream和InputStream）</strong>。字符流操作的单元是两个字节（16bit）,字节流操作的单位是一个字节（8bit）。由此可知java的字符的长度为两个字节。</li>
<li><strong>按角色划分：节点流和处理流。</strong>可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流。节点流也被称为低级流。当使用节点流进行输入输出的时候，程序直接连接到实际的数据源，和实际的输入/输出节点进行连接。处理流则用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能。处理流也被称为高级流。当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入和输出节点连接。使用处理流的一个明显的好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装的节点流的变化，程序实际所访问的数据源也相应的发生变化。处理流最终必须“套接”在节点流上才能完成输入输出。<br><img src="http://img.blog.csdn.net/20160505135650158" alt=""><h2 id="流的原理"><a href="#流的原理" class="headerlink" title="流的原理"></a>流的原理</h2>所有的输入流都是基于InputStream和Reader的；所有的输出流都是基于OutputStream和Writer的。</li>
</ul>
<p>输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或者Reader里面取出一个或者多个“水滴”后，记录指针自定向后移动；除此之外，InputStream和Reader里面都提供了一些方法来控制记录指针的移动。</p>
<p>同样，当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐示指针来标识当前水滴即将放入的位置，每当程序向OutputStream或者Writer里面输出一个或者多个水滴后，记录指针自动向后移动。</p>
<p><strong><em>注意的一点是字符流与字节流的指针的移动步长不一致。</em></strong></p>
<p>处理流可以“嫁接”在任何已存在的流（可以节点流，也可以是处理流）的基础之上，这就允许Java应用程序采用相同的代码，透明的方式来访问不同的输入和输出设备的数据流。</p>
<p><strong><em>处理流使用了装饰模式进行设计。</em></strong></p>
<h2 id="流的使用总结"><a href="#流的使用总结" class="headerlink" title="流的使用总结"></a>流的使用总结</h2><ul>
<li>如果是操作二进制文件那我们就使用字节流，如果操作的是文本文件那我们就使用字符流。</li>
<li>尽可能的多使用处理流，这会使我们的代码更加灵活，复用性更好。</li>
</ul>
<h2 id="NIO体系架构"><a href="#NIO体系架构" class="headerlink" title="NIO体系架构"></a>NIO体系架构</h2><p>三个核心模块：</p>
<ul>
<li>Selector</li>
<li>Channel</li>
<li>Buffer</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector帮助开发者突破IO的瓶颈，它提供了单线程处理多个 Channel的机制。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。<br>要使用Selector，得先向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等.</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel是一个对象，可以通过它读取和写入数据，所有的IO在NIO中都从一个Channel 开始。Channel中的数据要么写入Buffer，要么从Buffer读取。通道与流的不同之处在于通道是双向的，而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道可以用于读、写或者同时用于读写。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。Buffer其实就是一块缓存区，内部使用字节数组存储数据，并维护几个特殊变量，实现数据的反复利用。一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。尽管缓冲区作用于它们存储的原始数据类型,但缓冲区十分倾向于处理字节。非字节缓冲区可以在后台执行从字节或到字节的转换,这取决于缓冲区是如何创建的。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ed571e5b8793cae275479b761393a6f0" alt=""></p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0fc724bf520f4db008a73c597e7eadef" alt=""></p>
<h2 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h2><ol>
<li>Java IO的各种流是阻塞的；ava NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞的写也是如此。</li>
<li>流失单向的；通道（Channel）是双向的。</li>
<li>IO是面向流；NIO面向缓冲；</li>
<li>IO无选择器；NIO有选择器；</li>
<li>如果一个连接的数据量比较大使用基于IO的服务器，如果连接很多，且每个连接需要传输的数据量不大，可以使用基于NIO的服务器。</li>
</ol>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h3><ul>
<li>Collection Collection体系中的集合存储的是元素本身，只是每个实现的存储方式不一样。</li>
<li>Map Map体系中存储的是键值对。</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/916361/201603/916361-20160322135512683-168468369.jpg" alt=""></p>
<ol>
<li>List、Set和Queue等属于Collection接口，其中定义了List、Set和Queue的基本方法增删改查。</li>
<li>ArrayList是List的一个实现，底层是有数组实现的，其中元素可以重复。</li>
<li>HashSet是Set的一个实现，元素无序，并且不能重复。</li>
<li>Map提供一种映射关系，元素以键值对的形式存在，能根据键快速查询到值。Map中的键值对以Entry类型的对象实例存在。key值不能重复，value可以重复，即键值的关系是多对一。</li>
<li>HashMap是Map的一个实现，是基于hash表实现的，HashMap中的Entry对象是无序的，key和value都可以是null,但是key只能有一个是null（因为键不能重复）。</li>
</ol>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>特点：</p>
<ol>
<li>元素是有序的，可以使用索引访问指定的元素。</li>
<li>其中的元素不能重复。</li>
<li>除了iterator()方法外，List还提供了一个专有的方法listIterator(),用于返回一个ListIterator接口，和Iterator接口相比，能向前或向后遍历。</li>
</ol>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol>
<li>实现了List和queue接口。</li>
<li>允许有null值</li>
<li>扩充了一些方法，可以用来模拟堆栈（stack）,队列（queue），双向队列（deque）。</li>
<li>LinkedList没有同步方法，所有<strong>不是线程安全</strong>的。如果多个线程同时访问这个List，需要自己进行同步控制。一种解决办法：Listlist=Collections.synchronizedList(newLinkedList(…));这个时候的List就是同步的了。</li>
</ol>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li>底层实现是数组，大小可动态扩展</li>
<li>操作的方法没有进行同步控制，所以<strong>不是线程安全</strong>，并发操作时需要手动确保同步。</li>
<li>CopyOnWriteArrayList提供了线程安全的ArrayList。不过其add方法的同步是通过创建数组副本来实现的，效率较低。</li>
</ol>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol>
<li>Vector非常类似ArrayList，但是Vector<strong>是线程安全的</strong>。</li>
<li>效率较低，很少使用了。</li>
<li>java.util 包中的集合类都返回 fail-fast迭代器，这意味着它们假设线程在集合内容中进行迭代时，集合不会更改它的内容。如果 fail-fast迭代器检测到在迭代过程中进行了更改操作，那么它会抛出 ConcurrentModificationException</li>
</ol>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ol>
<li>父类是Vector。</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li>具有与Collection完全一样的接口。</li>
<li>Set不保存重复元素。</li>
<li>加入Set的元素都必须定义equals()方法以确保对象的唯一性。</li>
<li>其中的元素无序。</li>
</ol>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ol>
<li>元素不重复</li>
<li>元素无序</li>
<li>允许至多一个null元素</li>
<li><strong>不是线程安全的</strong></li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ol>
<li>可以实现排序，元素添加到集合中的时候会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素组成按照“升序”排列。</li>
<li>检索效率比ArrayList高，ArrayList是O(n),TreeSet是log(n)</li>
<li>TreeSet要维护父子节点之间的关系，所以其占有的资源相对较多。</li>
<li>数据插入的速度也较ArrayList块。</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ol>
<li>具有Link和HashSet的特点。查询按HashSet来，速度快；还能保证数据插入的顺序，这个是因为数据使用Link链表进行存储的。</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li>四个实现类：HashMap Hashtable LinkedHashMap 和TreeMap。</li>
<li>存储键值对，键不可以重复，值可以重复。</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol>
<li>根据键的hashcode存储数据。</li>
<li>根据键可以和快查询到其值。</li>
<li>HashMap<strong>不是线程安全的，</strong>其中的操作方法并没有并发控制。</li>
<li>如果需要其同步可以使用Collections的synchronizedMap方法。</li>
<li>键和值可以是null，但只允许一个键是null</li>
<li>每一个键值对存在在一个Entry对象中，而Entry对象又是存储在一个Set中，Set中不能有重复元素，即是要Entry对象不重复，而Entry对中的键就可以保证Entry对象不重复。</li>
</ol>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ol>
<li>根据键的hashcode存储数据</li>
<li>根据键可以快速查询到其值</li>
<li><strong>是线程安全的，</strong>因此写入效率较低。</li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ol>
<li>保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历 的时候会比HashMap慢。</li>
<li><strong>不是线程安全的。</strong></li>
</ol>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol>
<li>保存的记录根据键进行排序，默认按升序，可以指定排序的比较器。</li>
<li>当用Iterator 遍历TreeMap时，得到的记录是排过序的。</li>
<li><strong>不是线程安全的</strong>。</li>
</ol>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections是针对集合类的一个帮助类。提供了一系列静态方法实现对各种集合的搜索、排序、线程完全化等操作。<br>相当于对Array进行类似操作的类——Arrays。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>容器类只是持有对象的一份引用，所以一旦将对象放入容器中，就失去了对象的类型信息。</li>
<li>在所有的Set中，TreeSet的效率是最低，但是其中的元素是排序的。</li>
<li>LinkedList可以用来模拟stack、queue等。</li>
<li>Set和Collection有一模一样的接口。</li>
<li>哈希码就是将对象的信息经过一些转变形成一个独一无二的int值，这个值存储在一个array中。我们都知道所有存储结构中，array查找速度是最快的。所以，可以加速查找。</li>
<li>线程安全的集合：Vector 、HashTable，线程安全了也导致其效率变低了。</li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>创建线程的三种方式：</p>
<ol>
<li>继承Thread</li>
<li>实现Runable</li>
<li>实现Callable，使用Future对象接收Callable的call方法返回的值或抛出的异常，并把Future对象给Thread对象启动线程。</li>
</ol>
<p>启动线程的两种方式：</p>
<ol>
<li>使用线程池启动线程。</li>
<li>使用Thread对象的start()方法</li>
</ol>
<p>注意：run或call方法不能直接调用，而是线程内部自己处理的，调用了OS的线程启动方法。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Executors工具可以创建普通的线程池以及schedule调度任务的调度池，其实两者实现上还是有一些区别，但是理解了ThreadPoolExecutor，在看ScheduledThreadPoolExecutor就非常轻松了，后面的文章中也会专门介绍这块，但是需要先看这篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;JDK目录结构&quot;&gt;&lt;a href=&quot;#JDK目录结构&quot; class=&quot;headerlink&quot; title=&quot;JDK目录结构&quot;&gt;&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://yoursite.com/2018/02/09/MySQL/"/>
    <id>http://yoursite.com/2018/02/09/MySQL/</id>
    <published>2018-02-09T11:11:00.000Z</published>
    <updated>2018-03-11T08:45:11.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><pre><code>-- ALTER 增加索引
ALTER table user_t add index first_index(id);

ALTER table user_t add UNIQUE second_index(id)

ALTER TABLE user_t ADD PRIMARY KEY(id);

-- create方式增加索引
CREATE INDEX create_first_index on user_t (user_name);

create UNIQUE INDEX create_second_index on user_t (password,user_name,id);
</code></pre><p>在主键上创建索引不用给定名称，因为主键对于一张表来说是唯一的。</p>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><pre><code>-- 删除索引
DROP INDEX first_index on user_t;
ALTER TABLE user_t DROP INDEX first_index;
ALTER TABLE user_t drop PRIMARY KEY;
</code></pre><p>删除 primary key不用指定名称，因为一张表上只可能有一个 primary key索引。执行第三条语句的时候，如果表上没有创建primary key索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除了某列，会对索引有影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ol>
<li>索引不包含重复值，则索引应该创建为 primary Key或Unique。对于单列唯一性约束来说，保证单列不包含重复值，对于多列唯一性索引，多列的值的组合不重复。PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引</li>
</ol>
<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><pre><code>show index from user_t;
</code></pre><p>结果：</p>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foaffzkkpfj21aa09b0u8.jpg" alt=""></center>


<ul>
<li>Table 表的名称。</li>
<li>Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。</li>
<li>Key_name 索引的名称。</li>
<li>Seq_in_index 索引中的列序列号，从1开始。</li>
<li>Column_name 列名称。</li>
<li>Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。</li>
<li>Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。</li>
<li>Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</li>
<li>Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。</li>
<li>Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。</li>
<li>Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</li>
<li>Comment</li>
</ul>
<h2 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h2><ol>
<li>BTREE, </li>
<li>FULLTEXT, </li>
<li>HASH, </li>
<li>RTREE</li>
</ol>
<h2 id="MySQL的索引的原理"><a href="#MySQL的索引的原理" class="headerlink" title="MySQL的索引的原理"></a>MySQL的索引的原理</h2><h3 id="索引数据结构B-Tree-和-B-Tree"><a href="#索引数据结构B-Tree-和-B-Tree" class="headerlink" title="索引数据结构B-Tree 和 B+Tree"></a>索引数据结构B-Tree 和 B+Tree</h3><p>MySQL使用的是B+Tree作为索引的数据结构。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。应该尽量减少磁盘I/O次数。</p>
<ol>
<li><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
</li>
<li><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
</li>
</ol>
<p>B+Tree:</p>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foah7rvrxmj20f6089gli.jpg" alt="B+Tree"></center>

<p>B-Tree:</p>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foahaxvy5oj20m406kjrc.jpg" alt="B-Tree"></center>

<p>比较B-Tree和B+Tree,B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<pre><code>dmax=floor(pagesize/(keysize+datasize+pointsize))
</code></pre><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<h2 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。</p>
<h3 id="MyISAM-索引"><a href="#MyISAM-索引" class="headerlink" title="MyISAM 索引"></a>MyISAM 索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/8.png" alt="主索引"></center>

<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/9.png" alt="辅助索引"></center>

<p>主索引与辅助索引在结构上没有什么区别。主索引要求key是唯一的，而辅助索引的key可以重复。</p>
<h3 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<ol>
<li>第一个重大区别是InnoDB的数据文件本身就是索引文件。 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</li>
</ol>
<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/10.png" alt="主索引"></center>

<p>可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。<strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键</strong>（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<ol>
<li>第二个与MyISAM索引的不同是InnoDB的辅助索引<strong>data域存储相应记录主键的值</strong>而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</li>
</ol>
<center><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/11.png" alt="辅助索引"></center>

<p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。所以一般来说INNODB的索引都是创建在主键上。</p>
<p>根据INNODB的特征，不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</p>
<h2 id="索引的使用策略"><a href="#索引的使用策略" class="headerlink" title="索引的使用策略"></a>索引的使用策略</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<ol>
<li>表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引。</li>
<li>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值： Index Selectivity = Cardinality / #T。显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。</li>
</ol>
<p>查询中只有用到条件，索引才会起作用。而且索引列要起作用还必须是查询的条件之一。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。</p>
<p>在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的索引 O(log(N)) 运算来更新表的索引。</p>
<h2 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h2><p>MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1, a2,="" …,="" an="">，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为1的特例。如果在进行精确匹配的时候，使用的是隔断精确匹配，则只有最前面的连续的几个字段的索引会陪用到。</a1,></p>
<p>什么时候索引会被用到？</p>
<ol>
<li>当按照索引中所有列进行精确匹配时，索引可以被用到。这里的所谓精确匹配是指使用‘=’和‘IN’进行匹配。</li>
<li>当查询条件精确匹配索引的左边连续一个或几个列时,索引可以被用到,但是只能用到一部分，即条件所组成的最左前缀。如果使用索引中的列不连续，只会用到最左边连续的几个。后面的索引因为隔断将不会被使用。</li>
<li>如果查询条件没有指定索引第一列，这样的查询就会用不到索引。</li>
<li>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。这里的范围就是’&lt;’,’&gt;’等条件。索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</li>
<li>如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引。</li>
</ol>
<p><strong>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</strong></p>
<h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><ol>
<li><p>为什么数据库的索引使用的B+树的数据结构，而不使用hash表？尽管hash的搜索的最好情况是O(1)。</p>
<p> 答：</p>
<ul>
<li>Hash不能使用范围查询，只能用于“=”，“in”，“&lt;=&gt;”(等价)等查询</li>
<li>联合索引中，Hash索引不能利用部分索引键查询。并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。 </li>
<li>Hash索引无法避免数据的排序操作。由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。</li>
<li>Hash索引任何时候都不能避免表扫描。Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。 </li>
<li>Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高 </li>
</ul>
</li>
<li><p>怎么知道mysql使用的索引的数据结构是是B+Tree 而不是Hash Table？</p>
<p> 答：如果一个数据库中使用的索引过多会导致数据库的insert和delete操作速度比较慢，因为B+Tree是一棵自平衡树，在插入和删除记录的时候会不断的在调整树的结构，导致操作比较慢。</p>
</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>不是所有的数据库引擎都支持事务，MySQL支持事务的引擎有InnoDB,但MyISAM不支持事务。</p>
<h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><ol>
<li>事务不支持嵌套功能，当用户在未结束第一个事务又重新打开一个事务，则前一个事务会自动提交。</li>
<li>事务的性质：“ACID”原则即原子性（A）、稳定性（C）、隔离性（I）和持久性（D）。<ul>
<li>原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。 </li>
<li>稳定性：数据库在事务执行前后状态都必须是稳定的。 </li>
<li>隔离性：事务之间不会相互影响。 </li>
<li>持久性：事务执行成功后必须全部写入磁盘。</li>
</ul>
</li>
</ol>
<h2 id="事务的问题"><a href="#事务的问题" class="headerlink" title="事务的问题"></a>事务的问题</h2><p>数据库事务会导致脏读、不可重复读和幻影读等问题。</p>
<ol>
<li>脏读：事务还没提交，他的修改已经被其他事务看到。 </li>
<li>不可重复读：同一事务中两个相同SQL读取的内容可能不同。两次读取之间其他事务提交了修改可能会造成读取数据不一致。 </li>
<li>幻读：同一个事务突然发现他以前没发现的数据，两次读取数据之间其他事务提交了新的数据。</li>
</ol>
<p>为了解决以上问题，INNODB引入了四种不同的机制保证数据的隔离性。事务的四种隔离级别：</p>
<ol>
<li>READ UNCOMMIT（读未提交），允许某个事务看到其他事务并没有提交的数据。可能会导致脏读、不可重复读、幻影数据。这种隔离级别不会采用任何锁。</li>
<li>READ COMMIT（读已提交），允许某个事务看到其他事务已经提交的数据。可能会导致不可重复读和幻读。这种隔离级别，数据的读是不加锁的，但是数据的写入、修改、删除加锁，避免了脏读。</li>
<li>REPEATABLE READ（可重复读），同一个事务的两次相同读取肯定是一样的（对行来说），其他事务的提交的insert和delete可能会对本次事务有影响。这种级别的隔离，数据的读、写都会加锁（行级锁），当前事务如果占据了锁，其他事务必须等待本次事务提交完成释放锁后才能对相同的<strong>数据行</strong>进行操作。这种级别的隔离会导致幻读。</li>
<li>SERIALIZABLE（序列化），这种级别的隔离是在表上加锁，锁粒度比较到，可以完美的避免脏读、不可重复读和幻读，但是由于锁级别是在表上，影响数据库的效率。</li>
</ol>
<p><strong><em>注意：幻读出现的情况应该是针对插入（insert）和删除(delete)。可重复读对应的是更新（update）。</em></strong></p>
<h2 id="原子性、稳定性和持久性实现原理"><a href="#原子性、稳定性和持久性实现原理" class="headerlink" title="原子性、稳定性和持久性实现原理"></a>原子性、稳定性和持久性实现原理</h2><p>原子性、稳定性和持久性是通过redo 和 undo 日志文件实现的，不管是redo还是undo文件都会有一个缓存我们称之为redo_buf和undo_buf。同样，数据库文件也会有缓存称之为data_buf。</p>
<h3 id="undo-日志文件"><a href="#undo-日志文件" class="headerlink" title="undo 日志文件"></a>undo 日志文件</h3><p><center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fob9zgu8xij208w0i3glj.jpg" alt="undo日志文件保证原子性、稳定性和持久性的原理图"></center><br>说明：</p>
<ol>
<li>如果事务在F之前崩溃由于数据还没写入磁盘，所以数据不会被破坏。 </li>
<li>如果事务在G之前崩溃或者回滚则可以根据undo恢复到初始状态。</li>
<li>数据在任务提交之前写到磁盘保证了持久性。但是单纯使用undo保证原子性和持久性需要在事务提交之前将数据写到磁盘，浪费大量I/O。</li>
</ol>
<h3 id="redo-undo-日志文件"><a href="#redo-undo-日志文件" class="headerlink" title="redo/undo 日志文件"></a>redo/undo 日志文件</h3><p><center><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobaafvyt4j20ag0m93yj.jpg" alt="undo/redo日志文件保证原子性、稳定性和持久性的原理图"></center><br>说明：</p>
<ol>
<li>通过undo保证事务的原子性，redo保证持久性。</li>
<li>F之前崩溃由于所有数据都在内存，恢复后重新冲磁盘载入之前的数据，数据没有被破坏。 </li>
<li>FG之间的崩溃可以使用redo来恢复。 </li>
<li>G之前的回滚都可以使用undo来完成。</li>
</ol>
<h2 id="模拟不同的事务级别对数据安全的影响"><a href="#模拟不同的事务级别对数据安全的影响" class="headerlink" title="模拟不同的事务级别对数据安全的影响"></a>模拟不同的事务级别对数据安全的影响</h2><p>实验准备：</p>
<ol>
<li>安装mysql数据库</li>
<li>打开两个mysql命令行客户端，模拟多用户多事务场景。</li>
<li>导入官方推荐的数据库 employees。<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="测试read-uncommitted-级别"><a href="#测试read-uncommitted-级别" class="headerlink" title="测试read uncommitted 级别"></a>测试read uncommitted 级别</h3></li>
<li><p>查看当前的数据库隔离级别</p>
<pre><code>mysql&gt; select @@tx_isolation;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcqcxqidj20a3051dfo.jpg" alt="查看数据库的当前的隔离级别"></p>
</li>
<li><p>在A客户端（打开的mysql命令行客户端），设置当前会话的事务隔离级别为 read uncommitted</p>
<pre><code>set session transaction isolation level read uncommitted；
start transaction;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcr48xktj20hy0d2jrn.jpg" alt=""></p>
</li>
<li><p>在B客户端（打开的另一个mysql命令行客户端），设置当前会话的事务隔离级别为 read uncommitted，并更新数据。</p>
<pre><code>set session transaction isolation level read uncommitted;
start transaction;
update salaries set salary=salary+100 where emp_no = 100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcrinkm2j20ix06raa2.jpg" alt=""></p>
</li>
<li><p>在A中再次执行相同的查询数据</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobcrsldjtj20eo09c0sq.jpg" alt=""></p>
</li>
</ol>
<p>结论：一个事务没有提交，但是在另外的事务中却可以查看到这个事务没有提交的数据。这是所有隔离级别中最低级的一种。<br>导致的问题：可以读取到事务未提交的数据，俗称<strong>脏读</strong></p>
<h3 id="read-committed-级别"><a href="#read-committed-级别" class="headerlink" title="read committed 级别"></a>read committed 级别</h3><ol>
<li><p>查询B客户端的当前会话的事务的级别</p>
<pre><code>select @@tx_isolation;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdrdhmn2j20b704jdfo.jpg" alt=""></p>
</li>
<li><p>将B客户端的当前会话的事务级别设置为read committed，查询当前的数据。</p>
<pre><code>set session transaction isolation level read committed;
start transaction;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdu7zrmvj20f00baaa4.jpg" alt=""></p>
</li>
<li><p>在A客户端的会话中启动事务，对数据进行修改</p>
<pre><code>start transaction;
select * from salaries where emp_no=100000;
update salaries set salary=salary-200 where emp_no=100000;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdulbvghj20k50qadgo.jpg" alt=""></p>
</li>
<li><p>在B客户端的会话中查询</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobduz0fusj20fn09wwel.jpg" alt=""></p>
</li>
<li><p>提交A客户端中会话的事务</p>
<pre><code>commit
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdyqktp6j20fr0cvmxc.jpg" alt=""></p>
</li>
<li><p>在B客户端会话中查看数据</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobdyqktp6j20fr0cvmxc.jpg" alt=""></p>
</li>
</ol>
<p>结论：可见在A中修改的数据，在A中的事务被提交前，在B中是看不见的。一旦A提交，B中再次查询就可以看见了。如果当前会话的隔离级别是 read committed的，当前会话只能读取到其他事务提交的数据，未提交的数据是读不到的。<br>导致的问题：两次读取的结果不同，导致了<strong>不可重复读</strong>。</p>
<h3 id="Repeatable-read级别"><a href="#Repeatable-read级别" class="headerlink" title="Repeatable read级别"></a>Repeatable read级别</h3><p>这个是MySQL的默认事务级别。</p>
<ol>
<li><p>查询B客户端的当前会话的事务的级别</p>
<pre><code>select @@tx_isolation;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobep7am6xj20az05qjr8.jpg" alt=""></p>
</li>
<li><p>设置B客户端中的会话的隔离级别为repeatable read(可重复读，保证了两次读取的数据一致)。</p>
<pre><code>set session transaction isolation level repeatable read;
start transaction;
select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobepmfqibj20i00dx3ys.jpg" alt=""></p>
</li>
<li><p>在客户端A中的会话中启动一个事务,在事务里执行添加一条记录,并提交该事务。</p>
<pre><code>start transaction;
insert into salaries (emp_no,salary,from_date,to_date) value(100000,21232323,&apos;2017-06-29&apos;,&apos;2018-07-01&apos;);
select * from salaries where emp_no=100000;
commit;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobfphq7lxj20vc0efaah.jpg" alt=""></p>
</li>
<li><p>在客户端B的会话中查询数据，</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobfq8jd5mj20i50azdfz.jpg" alt=""></p>
</li>
<li><p>在客户端B的会话中插入一条与第三步插入的记录的<code>emp_no</code>和<code>from_date</code>都相同的数据</p>
<pre><code>insert into salaries (emp_no,salary,from_date,to_date) value(100000,1000000,&apos;2017-06-29&apos;,&apos;2020-07-01&apos;);
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobfqkg9znj20vg02iwed.jpg" alt=""></p>
</li>
<li><p>在客户端B的会话中查询数据，</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1foberfvn12j20f209imx6.jpg" alt=""></p>
</li>
</ol>
<p>结论：会话使用事务的级别为repeatable read，保证了在事务提交前的每次查询数据都是一样的，避免了不可重复读的问题，<br>导致的问题：从上述的实验中不难看出问题，就是在第五步出现的该问题，明明在当前会话中查询的数据没有与要提交的的数据冲突，可是在插入的时候却提示已经有该主键的数据记录了。看不见记录，却提示已存在该记录，这种情况称为<strong>幻读</strong>。</p>
<h3 id="serializable级别"><a href="#serializable级别" class="headerlink" title="serializable级别"></a>serializable级别</h3><p>serializable级别是隔离级别最高的，是最安全的，但也是最耗资源的。</p>
<ol>
<li><p>查询B客户端的当前会话的事务的级别</p>
<pre><code>select @@tx_isolation;
</code></pre></li>
<li><p>设置B客户端会话的事务级别为 serializable</p>
<pre><code>set session transaction isolation level serializable;
-- 启动事务
start transaction;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgq6qmduj20i903hjr9.jpg" alt=""></p>
</li>
<li><p>在B客户端的会话中查询数据</p>
<pre><code>select * from salaries where emp_no=100000;
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgqunr43j20f00b8q2z.jpg" alt=""></p>
</li>
<li><p>在A客户端会话中启动事务，查询数据，并插入一条数据。</p>
<pre><code>start transaction
select * from salaries where emp_no=100000;
insert into salaries (emp_no,salary,from_date,to_date) value(100000,2000000,&apos;2015-06-29&apos;,&apos;2020-07-01&apos;);
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgqunr43j20f00b8q2z.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgrek0cnj20uz031wed.jpg" alt=""></p>
<p> 可以看到插入数据并没有成功，尽管库中并没有相同主键的记录。</p>
</li>
<li><p>在A客户端插入数据的时候，同时在B客户端提交事务。</p>
<pre><code>-- 客户端A
insert into salaries (emp_no,salary,from_date,to_date) value(100000,2000000,&apos;2015-06-29&apos;,&apos;2020-07-01&apos;);

-- 客户端B
commit
</code></pre><p><img src="https://ws1.sinaimg.cn/large/af2f0e07gy1fobgx2jlpbj20v508e74c.jpg" alt=""></p>
</li>
</ol>
<p>由上面的结果看，A中的insert语句在等待执行期间，如果B客户端的事务执行了commit，那么A中的insert就会执成功，否则就会超时。</p>
<h1 id="自问自答-1"><a href="#自问自答-1" class="headerlink" title="自问自答"></a>自问自答</h1><ol>
<li><p>什么时候更能体现出索引查询的优势？</p>
<pre><code>答：因为索引是基于B+tree的，因此查询到一条记录的时间复杂度是O(logN),所以查询的记录越多，更能体现出索引的优势，在数据量不大的情况下，通过索引查询与不通过索引查询的时间相差不多。
</code></pre></li>
<li><p>数据库索引的工作原理是？</p>
<pre><code>答：把添加索引的列在内存中创建一棵以索引列的值为key的B+tree。
</code></pre></li>
<li><p>为什么说索引不是越多越好？</p>
<pre><code>答：数据维护索引需要消耗资源，因为索引的数据结构是B+树，在插入/删除数据的时候都需要调整树的平衡，调整树的平衡是需要耗时的，还有可能涉及到磁盘等的操作。这就减慢了插入/删除操作的速度。
</code></pre></li>
<li><p>阵列与hash表的区别</p>
<pre><code>答：搜索的复杂度不同，阵列是O(n),hash表是O(1)。阵列需要一次性加载到内存中，有时候这显得有点不现实。hash可以分不同的&quot;桶&quot;加载到内存中。
</code></pre></li>
<li></li>
</ol>
<h1 id="数据设计原则"><a href="#数据设计原则" class="headerlink" title="数据设计原则"></a>数据设计原则</h1><p>三范式：</p>
<ol>
<li>第一范式（1NF）：属性必须是原子性的约束，要求属性具有原子性，即属性不能再分解。</li>
<li>第二范式（2NF）：对记录唯一性的约束，要求记录有唯一的标识，即实体的唯一性。</li>
<li>第三范式（3NF）：对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ol>
<p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降 低范式。</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>PK是供程序员使用的表间连接工具，可以是一无物理意义的数字串, 由程序自动加1来实现。也可以是有物理意义的字段名或字段名的组合。不过前者比后者好。当PK是字段名的组合时，建议字段的个数不要太多，多了不但索引占用空间大，而且速度也慢。</p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>隔离了真实数据和操作人员，保证了数据的安全性。</p>
<h2 id="提高数据库运行效率的方法"><a href="#提高数据库运行效率的方法" class="headerlink" title="提高数据库运行效率的方法"></a>提高数据库运行效率的方法</h2><ol>
<li>在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。</li>
<li>当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。 </li>
<li>发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，以该表主键PK的某个值为界线，将该表的记录水平分割为两个表（即可以表维护 表行数过大 手动分割为两个  建个两表union的视图对程序透明）。若发现某个表的字段太多，例如超过八十个，则垂直分割该表，将原来的一个表分解为两个表。</li>
<li>对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。</li>
<li>在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。总之，要提高数据库的运行效率，<strong>必须从数据库系统级优化、数据库设计级优化、程序实现级优化，</strong>这三个层次上同时下功夫。</li>
</ol>
<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><ul>
<li><p>分表</p>
<ol>
<li>水平分表：解决的是记录过多，如果进联表（union）等操作，导致要进行不断的IO，另外数据过多比较的目标数就会过多，浪费比较的时间，如果进行分表，如果一开始就能定位所需要的数据在哪张子表就会减少IO操作，也减少了比较的次数。</li>
<li>垂直分表：解决的数据记录并不多，但是属性过多，导致检索的时候会进行过多的IO操作。垂直分表的原则是把大字段分到单独表中，同时必须保证该表与原表是一对一的关系（即使用主外键关联）。</li>
</ol>
</li>
<li><p>其他</p>
<ol>
<li>存放图片、文件等大文件用文件系统存储。数据库只存储路径，图片和文件存放在文件系统，甚至单独存放在一台服务器(图床)。</li>
<li><p>数据参数的配置。最重要的参数就是内存，我们主要用的innodb引擎，所以下面两个参数调的很大：</p>
<pre><code>innodb_additional_mem_pool_size=64M
innodb_buffer_pool_size=1G
</code></pre></li>
<li>合理的硬件资源和操作系统。如果机器的内存超过4G，那么应当采用64位操作系统和64位MySQL。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;创建索引&quot;&gt;&lt;a href=&quot;#创建索引&quot; class=&quot;headerlink&quot; title=&quot;创建索引&quot;&gt;&lt;/a&gt;创建索引&lt;/h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://yoursite.com/2018/02/01/Spring/"/>
    <id>http://yoursite.com/2018/02/01/Spring/</id>
    <published>2018-02-01T13:19:17.000Z</published>
    <updated>2018-02-04T13:38:36.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ol>
<li>BeanFactory</li>
<li>ApplicationContext</li>
<li>BeanDefinition</li>
<li>Resource</li>
</ol>
<h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><ol>
<li>Bean定义资源的定位</li>
<li>Bean定义资源的载入</li>
<li>Bean定义资源的解析  </li>
</ol>
<h2 id="IoC容器初始化的基本步骤"><a href="#IoC容器初始化的基本步骤" class="headerlink" title="IoC容器初始化的基本步骤"></a>IoC容器初始化的基本步骤</h2><ol>
<li>初始化的入口是通过调用容器中的refresh()方法实现的</li>
<li>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition，其大致过程：<blockquote>
<p>通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。</p>
<p>如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的。</p>
<p>容器通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition  这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现</p>
<p>注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.</p>
</blockquote>
</li>
</ol>
<ol>
<li>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方</li>
</ol>
<h2 id="Beanfactory-和-Factory-Bean"><a href="#Beanfactory-和-Factory-Bean" class="headerlink" title="Beanfactory  和 Factory Bean"></a>Beanfactory  和 Factory Bean</h2><ol>
<li>BeanFactory 指的是 IOC 容器的编程抽象,比如 ApplicationContext， XmlBeanFactory 等。</li>
<li>FactoryBean 只是一个可以在 IOC而容器中被管理的一个 bean,是对各种处理过程和资源使用的抽象,Factory bean 在需要时产生另一个对象，而不返回 FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了。</li>
</ol>
<h2 id="IoC容器的依赖注入"><a href="#IoC容器的依赖注入" class="headerlink" title="IoC容器的依赖注入"></a>IoC容器的依赖注入</h2><p>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入</p>
<h3 id="依赖注入发生的时机"><a href="#依赖注入发生的时机" class="headerlink" title="依赖注入发生的时机"></a>依赖注入发生的时机</h3><ol>
<li>用户第一次通过getBean方法向IoC容索要Bean时，IoC容器触发依赖注入。</li>
<li>当用户在Bean定义资源中为<bean>元素配置了lazy-init属性，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入</bean></li>
</ol>
<p>如果Bean定义的单态模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean定义还可以扩展为指定其生命周期范围。</p>
<p>一般来说依赖注入发生在向容器索取bean的时候，即调用各个getBean方法的时候；但当Bean定义资源的<bean>元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候就已经完成</bean></p>
<h2 id="IOC的高级应用"><a href="#IOC的高级应用" class="headerlink" title="IOC的高级应用"></a>IOC的高级应用</h2><p>Dereference(解引用)：一个在C/C++中应用比较多的术语，在C++中，”*”是解引用符号，而”&amp;”是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。</p>
<p>Spring IoC容器提供了两种管理Bean依赖关系的方式：</p>
<ol>
<li>显式管理：通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理。</li>
<li>autowiring：Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的Bean，从而自动地完成依赖注入。</li>
</ol>
<p>Spring IoC容器的autowiring属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ioc&quot;&gt;&lt;a href=&quot;#Ioc&quot; class=&quot;headerlink&quot; title=&quot;Ioc&quot;&gt;&lt;/a&gt;Ioc&lt;/h1&gt;&lt;h2 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h2&gt;&lt;o
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://yoursite.com/2018/01/28/JVM/"/>
    <id>http://yoursite.com/2018/01/28/JVM/</id>
    <published>2018-01-28T01:09:55.000Z</published>
    <updated>2018-01-28T14:38:44.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h1><h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><ol>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>寄存器（程序计数器）</li>
<li>堆区</li>
<li>方法区</li>
</ol>
<center><img src="https://ws1.sinaimg.cn/large/af2f0e07ly1fnw6oozzasj20x80k13z0.jpg" alt="JVM内存模型"></center>

<h2 id="各个内存模块的作用"><a href="#各个内存模块的作用" class="headerlink" title="各个内存模块的作用"></a>各个内存模块的作用</h2><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ol>
<li>程序逻辑运行的区域，可固定，可扩展。如果固定，当其中的某个线程需要执行内存（在栈空间上），而恰好分配的栈区不足就会出现StackOverflowError异常（运行时异常）。如果可扩展，当其中的某个线程需要执行内存（在栈空间上，而恰好内存已经使用完，会出现OutofMemeryError。</li>
<li>每个线程在其中都开辟了一个栈空间，线程的栈空间为固定大小，其中存储有运行时的方法，本地变量，对象引用等。线程栈是线程独享。</li>
<li>本质上来说程序的运行时依赖于方法的，所以在运行某个方法的时候都会为该方法创建一个栈帧，栈帧的作用是用来存在这个方法的操作数栈，局部变量表，方法出口，动态链接等信息，并把这个栈帧压入响应的线程栈中。</li>
<li>线程栈运行时创建，栈帧运行时创建<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3></li>
<li>本地方法栈是在调用本地方法时本地方法运行的内存空间。严格来说这里结构不由JVM管理，只是由JVM调用。</li>
</ol>
<h3 id="寄存器（程序计数器）"><a href="#寄存器（程序计数器）" class="headerlink" title="寄存器（程序计数器）"></a>寄存器（程序计数器）</h3><ol>
<li>线程独占</li>
<li>用于记录程序当前执行到的位置（指令地址）</li>
<li>如果当前某个线程正在执行某个本地方法，则该线程对应的计数器中的值为空。</li>
</ol>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><ol>
<li>线程共享</li>
<li>启动即创建</li>
<li>存储数组和对象，数组也是对象</li>
<li>详细可以划分为，新生代，老年代等</li>
<li>是垃圾回收的主要场所。</li>
<li>GC算法就主要是针对堆区设计的。</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol>
<li>堆区的一个逻辑分区，本质上也是堆</li>
<li>线程共享</li>
<li>主要用于存储类的信息、常量池、方法数据、方法代码等</li>
<li>这个区也会发生垃圾回收，但是频率很低。</li>
</ol>
<p>注：方法区是java虚拟机的一个规范，至于怎么实现，有虚拟机开发者自行确定。</p>
<h4 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h4><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是<strong>方法区</strong>。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且<strong>只有 HotSpot 才有PermGen space</strong>，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出</p>
<p>注：<em>整个区在java8后就被移除了，即在java8后使用元空间来表示方法区，即元空间是方法区的另一种实现方式。</em></p>
<h4 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h4><p>java8后使用元空间替换了永久代（PermGen）来实现方法区。元空间与永久代的不同：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p>
<p>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<h3 id="每个内存区域出现异常的情形"><a href="#每个内存区域出现异常的情形" class="headerlink" title="每个内存区域出现异常的情形"></a>每个内存区域出现异常的情形</h3><center><img src="https://images2015.cnblogs.com/blog/539365/201511/539365-20151119105947202-10960285.png" alt=""></center>

<ol>
<li>堆或方法区的内存不够分配都会出现OutOfMemoryError。</li>
<li>栈区只有在多线程的情况下才会出现OutOfMemoryError，在单线程的情况下只会出现StackOverflowError。</li>
<li>栈区在多线程的情况下会出现StackOverflowError，这是因为某个线程使用的栈深度超过了JVM定义的深度。</li>
<li>程序计数器理论上回出现OutOfMemoryError，但实际情况下是不会出现的，除非线程栈的大小小于计数器。</li>
</ol>
<p>注意：以上所说的各个区并不是在物理上进行分割的，而是在逻辑上进行分割的。比如堆区就可以分配在整个内存区域的不连续的空间中。</p>
<h1 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h1><pre><code>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
</code></pre><p>-Xmx128m：设置JVM最大可用内存为128M。</p>
<p>-Xms128m：设置JVM最小内存为128m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<p>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p>
<p>-Xss128k：设置每个线程的堆栈大小。 JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更 多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<p>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p>
<p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p>-XX:MaxPermSize=16m：设置持久代大小为16m。</p>
<p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。<br> – Ratio 比率<br> – Eden 伊甸<br> – Survivor 幸存者</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM的内存模型&quot;&gt;&lt;a href=&quot;#JVM的内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM的内存模型&quot;&gt;&lt;/a&gt;JVM的内存模型&lt;/h1&gt;&lt;h2 id=&quot;JVM内存划分&quot;&gt;&lt;a href=&quot;#JVM内存划分&quot; class=&quot;header
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础网络知识</title>
    <link href="http://yoursite.com/2018/01/21/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/01/21/基础网络知识/</id>
    <published>2018-01-21T13:08:21.000Z</published>
    <updated>2018-01-21T14:50:27.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>网络七层模型：应用层，会话层，表示层，传输层，网络层，链路层和物理层<br>网络五层模型：应用层，传输层，网络层，链路层，物理层</p>
<p>其中s的含义：SSL/TSL(Security Socket Layer/)TSL是SSL的一个升级</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于公钥加密算法，对称加密/非对称加密。<br>对称加密：加密和解密都是使用的相同的秘钥，可能网络中有很多网络实体是具有这个相同的秘钥的，可能不够安全。<br>非对称加密：公钥加密，私钥解密。公钥由服务器分发。所有客户端都有相同的公钥，但只有服务端有私钥。</p>
<p>握手：</p>
<ol>
<li>客户端先向服务端请求公钥</li>
<li>服务端给请求的客户端返回双方（客户端和服务端）通信的公钥</li>
<li>客户端使用私钥加密通信的数据</li>
<li>服务端用私钥解密公钥加密的数据</li>
</ol>
<p>以上的通信方式看似没有安全性问题，其实也存在中间人攻击的可能：</p>
<ol>
<li>攻击则可以冒充服务端，分发公钥。</li>
<li>攻击则可以冒充服务端，拦截数据后，把数据传递给服务端，服务端响应公钥，攻击者获取加密公钥，然后用自己的公钥替换真的公钥返回给客户端，之后客户端响应的数据都是用的攻击者的公钥加密，攻击者可以使用自己的私钥解密加密的报文并进行篡改。同时用真的公钥加密篡改后的数据响应给服务端</li>
</ol>
<p>引入数字证书颁发机构：</p>
<ol>
<li>客户端向服务端请求公钥，服务端把公钥给到第三方数字证书颁发机构。</li>
<li>第三方数字证书颁发机构使用自己的私钥对服务端的公钥进行加密，生成数字证书，并把该数字证书发送给客户端。</li>
<li>客户端使用本地存储的第三方机构的公钥对证书进行解密，获取服务端的公钥，使用该服务端公钥对数据进行加密，把加密后的数据发送给服务端。</li>
</ol>
<p>以上的流程其实还是存在被攻击的可能。因为攻击者还是有可能替换其中的公钥为自己的公钥的，因为他也有第三方机构的公钥。为解决该问题就需要保证证书是可以在客户端验证真伪的。这样的证书怎么制作呢？</p>
<ol>
<li>第三方证书颁发机构获取到公钥后，使用某种算法依据服务端的公钥生成一个证书编码，这个算法也是证书的一部分。</li>
<li>当客户端收到第三方颁发的证书后，通过证书中的算法和其中的加密公钥分析出证书编码，分析出的证书编码与证书本身的编码进行比较，如果相同，说明公钥没有被篡改。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h1&gt;&lt;p&gt;网络七层模型：应用层，会话层，表示层，传输层，网络层，链路层和物理层&lt;br&gt;网络五层模型：应用层，传输层，网络层，链
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gradle 版本依赖工具</title>
    <link href="http://yoursite.com/2018/01/21/gradle-%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/01/21/gradle-版本依赖工具/</id>
    <published>2018-01-21T09:18:26.000Z</published>
    <updated>2018-01-21T10:10:56.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><a href="http://services.gradle.org/distributions/" target="_blank" rel="external">下载</a></li>
<li><a href="https://gradle.org/install/#manually" target="_blank" rel="external">安装指导</a>或如果你下载的包中包含有文档，在解压后的根目录下有个文件getting-started.html，双击，使用浏览器打开，其中也有安装的指导</li>
<li>设置环境变量</li>
<li><p>检查是否安装成功,如果执行如下命令后看到版本信息，则表明安装成功</p>
<pre><code>gradle -v
</code></pre><p>注意：<em>修改版本包缓存的目录。默认情况下{user}/.gradle目录下，我们需要修改到指定的目录下(Windows),在bin/gradle.bat的相应位置设置如下的第二行脚本：</em></p>
<pre><code># Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script
set GRADLE_OPTS=-Dgradle.user.home=/yourpath/gradle/gradle_cache
</code></pre><p>如果使用的是大于4.3的版本，构建project的时候，使用：</p>
<pre><code>gradle build --scan
</code></pre></li>
</ol>
<h1 id="使用gradle构建Spring"><a href="#使用gradle构建Spring" class="headerlink" title="使用gradle构建Spring"></a>使用gradle构建Spring</h1><p>一定要使用相应版本的gradle构建，不然会出现难以预料的问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://services.gradle.org/distributions/&quot; target=&quot;_bla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-boot 学习</title>
    <link href="http://yoursite.com/2018/01/13/Spring-boot-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/01/13/Spring-boot-学习/</id>
    <published>2018-01-13T07:03:18.000Z</published>
    <updated>2018-01-15T13:05:16.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><ol>
<li>以远程方式启动应用</li>
<li>在eclipse中配置远程调试：Debug As =&gt; Debug Confirgurations =&gt; Remote Java Application,</li>
<li>配置好应用运行的环境的IP和监听debug调试的端口</li>
</ol>
<h1 id="启动Spring-boot应用"><a href="#启动Spring-boot应用" class="headerlink" title="启动Spring boot应用"></a>启动Spring boot应用</h1><ol>
<li>在IDE中启动</li>
<li><p>把应用打成jar，使用命令：</p>
<pre><code>java -jar myproject.jar //普通的启动
java -jar myproject.jar --debug //可以在控制台输出相关的debug日志信息
</code></pre></li>
</ol>
<h1 id="外化配置"><a href="#外化配置" class="headerlink" title="外化配置"></a>外化配置</h1><p>Spring Boot 允许你外化你的配置，这样你就可以在不同的环境中使用相同的应用程序代码。你可以使用properties文件，YAML文件，环境变量和命令行参数等外化你的配置。</p>
<h1 id="使用Spring-Boot开发应用"><a href="#使用Spring-Boot开发应用" class="headerlink" title="使用Spring Boot开发应用"></a>使用Spring Boot开发应用</h1><h2 id="Spring-MVC自配置"><a href="#Spring-MVC自配置" class="headerlink" title="Spring MVC自配置"></a>Spring MVC自配置</h2><p>Spring Boot为Spring MVC提供了自动配置    ，这在大多数程序中都很适用。</p>
<p>自动配置在Spring默认配置的基础上添加了如下的特性：</p>
<ol>
<li>包含<code>ContentNegotiatingViewResolver</code> 和 <code>BeanNameViewResolver</code>  beans。</li>
<li>支持为静态资源提供服务，包括支持webjar</li>
<li><code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code> 的自动注册</li>
<li>支持<code>HttpMessageConverters</code> </li>
<li><code>MessageCodesResolver</code> 的自动注册</li>
<li>静态文件<code>index.html</code>的支持</li>
<li>支持自定义图标</li>
<li>自动适用<code>ConfigurableWebBindingInitializer</code> bean</li>
</ol>
<p>如果你想保留Spring Boot MVC的特征，且你只想增加附加的MVC配置（如拦截器，格式化和视图控制器等），你可以增加你自己的<code>@Configuration</code> 类类型<code>WebMvcConfigurerAdapter</code>，但是没有<code>@EnableWebMvc</code>。如果你希望提供定制化的<code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> 或<code>ExceptionHandlerExceptionResolver</code> 的实例，你可以声明一个<code>WebMvcRegistrationsAdapter</code> 实例来提供这些组件。</p>
<p>如果你想要完全控制Spring MVC，你可以使用<code>@EnableWebMvc</code>增加你自己的<code>@Configuration</code>注解。</p>
<h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST(Representational State Transfer，表述性状态转移)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;远程调试&quot;&gt;&lt;a href=&quot;#远程调试&quot; class=&quot;headerlink&quot; title=&quot;远程调试&quot;&gt;&lt;/a&gt;远程调试&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;以远程方式启动应用&lt;/li&gt;
&lt;li&gt;在eclipse中配置远程调试：Debug As =&amp;gt; Debug 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Socket 编程</title>
    <link href="http://yoursite.com/2018/01/07/Java-Socket-%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/07/Java-Socket-编程/</id>
    <published>2018-01-07T05:17:58.000Z</published>
    <updated>2018-03-11T04:10:28.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket在网络编程中所处的位置"><a href="#Socket在网络编程中所处的位置" class="headerlink" title="Socket在网络编程中所处的位置"></a>Socket在网络编程中所处的位置</h1><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><center><img src="http://img.blog.csdn.net/20161209121343020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWpwMTk4NzEwMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></center><br>基于TCP/IP协议族的网络，共分四层：</p>
<ol>
<li>应用层，例如HTTP，FTP。它们都是基于TCP/UDP设计出来的</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p>Socket是位于应用层之下，传输层之上的接口，也就是操作系统提供给用户访问网络的系统接口。我们可以借助于Socket接口层，对传输层，网际层以及网络接口层进行操作，来实现我们不同的应用层协议。对于应用层，我们想实现网络功能，归根究底都是要通过Socket来实现的，否则，我们无法访问处于操作系统的传输层，网际层以及网络接口层。</p>
<p>Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。一般由操作系统或者JVM自己实现。java.net中的socket其实就是对底层的抽象调用。</p>
<p>套接字关联的数据结构：</p>
<ol>
<li>该套接字所关联的本地和远程互联网地址和端口。</li>
<li>一个FIFO队列用于存放接收到的等待分配的数据（RecvQ），以及一个用于存放等待传输数据的的队列（SendQ）</li>
<li>对于TCP套接字，还包含了与打开关闭TCP握手相关的额外协议状态信息。</li>
</ol>
<p>在JAVA中，我们用 ServerSocket、Socket类创建一个套接字连接，从套接字得到的结果是一个InputStream以及OutputStream对象，以便 将连接作为一个IO流对象对待。通过IO流可以从流中读取数据或者写数据到流中，读写IO流会有异常IOException产生。向输出流写数据并不意味着数据实际上已经被发送，它们只是被复制到了发送缓冲区队列SendQ，就是在Socket的OutputStream上调用 flush()方法，也不能保证数据能够立即发送到网络。<strong>真正的数据发送是由操作系统的TCP协议栈模块从缓冲区中取数据发送到网络来完成的</strong>。当有数据从网络来到时，TCP协议栈模块接收数据并放入接收缓冲区队列RecvQ，输入流InputStream通过read方法从RecvQ中取出数据。</p>
<p>套接字底层是基于TCP的，所以socket的超时和TCP超时是相同的。如果TCP的三次握手超时，那这个socket连接也会超时。</p>
<p>TCP/UDP，两者最大的区别在于，TCP是可靠的，也就是说，我们通过TCP发送的数据，网络协议栈会保证数据可靠的传输到对端，而UDP是不可靠的，如果出现丢包，协议栈不会做任何处理，可靠性的保证交由应用层处理。因此，TCP的性能会比UDP低，但是可靠性会比UDP好很多。除此之外，两者在传输数据时，也有形式上的不同，TCP的数据是流，大家可以类比文件流，而UDP则是基于数据包，也就是说数据会被打成包发送。流和数据包的最大区别在于流没有数据边界，数据包有数据边界，UDP每次发送的数据都独立成包。</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2></li>
</ul>
<ol>
<li>TCP连接的建立需要通过三次握手来完成 </li>
<li><p>TCP连接的关闭通过四次挥手来完成。</p>
<h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><p>目前常见的服务器模型主要有三种：</p>
</li>
<li><p>阻塞服务器</p>
</li>
<li>并发服务器</li>
<li><p>异步服务器</p>
<ul>
<li>阻塞式服务器是最好实现的服务器，也是问题最多的服务器。客户端发送到服务端的请求会进行排队，服务器会一次处理这些请求，前一个请求没有处理完，就不会处理下一个请求，这种服务器很容易受到攻击，只需要发送一个处理时间很长的请求就可以阻塞其他的请求。因此这种服务器也只能作为理论上的模型。</li>
<li>并发式服务器。这种服务器处理请求的时候，会为每个接收到的请求创建独立的线程来处理该请求。好处是不会出现请求被阻塞的情况，但也存在一些问题，如果线程过多会把服务器的资源耗尽，导致服务器不能提供服务。不过好在有别的方式可以规避这种情况，就是在服务端建立线程池来处理请求。线程池虽然避免了服务器资源耗尽的问题，但是也存在一些自身的不足，比如线程池资源被用完后，后续的请求也会出现阻塞的情况。</li>
<li>异步服务器。这种服务器借助系统的异步IO机制，当一个请求到来，我们可以先将请求注册，当有数据可以读取时，会得到通知，这时我们处理请求，这样服务器没有必要阻塞线程，也不会存在很大的系统开销，因此对于并发量比较高的服务器，一般都采用这种方式。</li>
</ul>
</li>
</ol>
<p>服务器的优化之路：单个线程阻塞模式；一个请求一个线程处理；多线程+线程池；NIO中的多路复用技术，一个线程管理多个请求。这里的请求都是服务端的接收套接字接收到客户端的连接请求。</p>
<h1 id="Java异步编程"><a href="#Java异步编程" class="headerlink" title="Java异步编程"></a>Java异步编程</h1><p>JAVA平台,实现异步调用的角色有如下三个角色：</p>
<ol>
<li>调用者</li>
<li>取货凭证</li>
<li>真实数据</li>
</ol>
<p>一个调用者在调用耗时操作,不能立即返回数据时,先返回一个取货凭证.然后在过一断时间后凭取货凭证来获取真正的数据。所以连结调用者和真实数据之间的桥梁是取货凭证。</p>
<h2 id="Java中的回调"><a href="#Java中的回调" class="headerlink" title="Java中的回调"></a>Java中的回调</h2><p>java中的回调就是将规定一个接口，然后设计一个类（该类与接口存在关联或者依赖关系），最后，当使用这个类的时候，实现之前规定的接口，这就是java中的回调。简单的说，在Java中，通常就是编写下层的人规定一个接口，由上层来实现这个接口；然后上层就可以把这个接口的一个对象作为参数传给下层，下层就会通过那个接口来调用由上层编写的函数。</p>
<p>java的回调是以接口的形式实现的。从类之间的关系角度看，有关联与依赖之分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Socket在网络编程中所处的位置&quot;&gt;&lt;a href=&quot;#Socket在网络编程中所处的位置&quot; class=&quot;headerlink&quot; title=&quot;Socket在网络编程中所处的位置&quot;&gt;&lt;/a&gt;Socket在网络编程中所处的位置&lt;/h1&gt;&lt;h2 id=&quot;网络分层&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习JMS</title>
    <link href="http://yoursite.com/2018/01/07/%E5%AD%A6%E4%B9%A0JMS/"/>
    <id>http://yoursite.com/2018/01/07/学习JMS/</id>
    <published>2018-01-07T02:41:45.000Z</published>
    <updated>2018-01-07T02:42:26.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JMS使用中遇到的问题"><a href="#JMS使用中遇到的问题" class="headerlink" title="JMS使用中遇到的问题"></a>JMS使用中遇到的问题</h1><h2 id="使用spring的消息转换器时提示的安全问题"><a href="#使用spring的消息转换器时提示的安全问题" class="headerlink" title="使用spring的消息转换器时提示的安全问题"></a>使用spring的消息转换器时提示的安全问题</h2><p>自定义了一个普通的java对象Email,希望通过spring提供的消息对象转换器把其转为对应的jms消息对象，但在转发消息时候出现如下日志提示的错误。</p>
<p>错误日志：</p>
<p><code>Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class com.daniel.study.jms.model.Email! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.</code></p>
<p>导致的原因是在5.12.2 and 5.13.0版本后为了传输的对象是安全的，强制要求用户指定需要传输的对象所在的包（package），只有在指定的包下的类的对象才能使用ObjectMessage进行安全转换，也就是要指定能进行转换的对象的类所在包作为一个白名单。有两种配置白名单的方式：</p>
<ol>
<li>客户端配置，该方式是在5.12.2和5.13.1及之后的版本中提供的配置方式，这种方式是常用的。</li>
</ol>
<p>Spring配置文件中配置，配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;  </div><div class="line">	    &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;</div><div class="line">	    &lt;!-- 指定可以通过ObjectMessage进行安全转换的对象的类所在的包 --&gt;</div><div class="line">	    &lt;property name=&quot;trustedPackages&quot;&gt;</div><div class="line">	        &lt;list&gt;</div><div class="line">	            &lt;value&gt;com.daniel.study.jms.model&lt;/value&gt;</div><div class="line">	        &lt;/list&gt;</div><div class="line">        &lt;/property&gt;  </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;  </div><div class="line">	    &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;</div><div class="line">	    &lt;property name=&quot;trustAllPackages&quot; value=&quot;true&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>如上的配置就是把com.daniel.study.jms.model下的所有类都加入白名单，在该白名单下的类的对象都是可以通过spring提供的转换器进行转换的。<a href="http://activemq.apache.org/objectmessage.html" target="_blank" rel="external">参考</a></p>
<p>java代码中设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);</div><div class="line">factory.setTrustedPackages(new ArrayList(Arrays.asList(&quot;org.apache.activemq.test,org.apache.camel.test&quot;.split(&quot;,&quot;))));</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);</div><div class="line">factory.setTrustAllPackages(true);</div></pre></td></tr></table></figure>
<ol>
<li>还可以在服务端（activeMq broker）中进行配置，这种方式的配置开始于activeMq的5.12.2和5.13.0版本，在${ACTIVEMQ_HOME}/bin/env中配置activeMq的系统属性ACTIVEMQ_OPTS：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dorg.apache.activemq.SERIALIZABLE_PACKAGES=java.lang,javax.security,java.util,org.apache.activemq,org.fusesource.hawtbuf,com.thoughtworks.xstream.mapper,com.daniel.study.jms.model</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Dorg.apache.activemq.SERIALIZABLE_PACKAGES=*`</div></pre></td></tr></table></figure>
<p>如上的设置，其中com.daniel.study.jms.model是加入白名单的包，对于broker的，其余的包默认是必须的。</p>
<h1 id="JMS事务管理之JNDI数据源配置"><a href="#JMS事务管理之JNDI数据源配置" class="headerlink" title="JMS事务管理之JNDI数据源配置"></a>JMS事务管理之JNDI数据源配置</h1><h2 id="什么是jndi"><a href="#什么是jndi" class="headerlink" title="什么是jndi"></a>什么是jndi</h2><p>jndi(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象。目录服务是一种命名服务，在这种服务里，对象不但有名称，还有属性。也就是说目录服务是一种特殊的命名服务。</p>
<h2 id="Tomcat容器"><a href="#Tomcat容器" class="headerlink" title="Tomcat容器"></a>Tomcat容器</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p><strong>全局：</strong></p>
<ol>
<li>在tomcat的conf文件夹下的context.xml配置文件中加入：<br>` &lt;Resource name=”jndi/mysql”   <pre><code>auth=&quot;Container&quot;   
type=&quot;javax.sql.DataSource&quot;   
driverClassName=&quot;com.mysql.jdbc.Driver&quot;   
url=&quot;jdbc:mysql://localhost:3306/test&quot;   
username=&quot;root&quot;   
password=&quot;root&quot;   
maxActive=&quot;20&quot;   
maxIdle=&quot;10&quot;   
maxWait=&quot;10000&quot;/&gt; 
</code></pre>`</li>
<li>在项目的web.xml中加入资源引用：<br><code>&lt;resource-ref&gt;  
&lt;description&gt;JNDI DataSource&lt;/description&gt;  
&lt;res-ref-name&gt;jndi/mysql&lt;/res-ref-name&gt;  
&lt;res-ref-type&gt;javax.sql.DataSource&lt;/res-ref-type&gt;  
&lt;res-auth&gt;Container&lt;/res-auth&gt;  
&lt;/resource-ref&gt;</code></li>
<li>在mybatis配置文件中加入:<br>`<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"><pre><code>&lt;property name=&quot;jndiName&quot;&gt;
    &lt;value&gt;java:comp/env/jdbc/mysql&lt;/value&gt;
&lt;/property&gt;
</code></pre> </bean><br>`<br><strong>单个项目：</strong></li>
<li>在META-INF中创建一个名为context.xml文件，在其中加入：<br>`&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br><context><br> &lt;Resource  name=”jdbc/mysql” auth=”Container” <pre><code>type=&quot;javax.sql.DataSource&quot;                                                     
driverClassName=&quot;com.mysql.jdbc.Driver&quot;                                 
url=&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&quot;
username=&quot;root&quot;
password=&quot;root&quot;
maxActive=&quot;50&quot;
maxIdle=&quot;30&quot;
maxWait=&quot;10000&quot; /&gt;
</code></pre></context><br>`</li>
<li>其他的同全局配置</li>
</ol>
<h2 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h2><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><h2 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h2><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><h3 id="配置方式-3"><a href="#配置方式-3" class="headerlink" title="配置方式"></a>配置方式</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是指一个工作单元，它包含了一组添加，删除，修改等具有逻辑关系的多个操作,作为一个单元整体执行，这组命令要么都执行成功，要么全部恢复</p>
<h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>分布式事务是指事务的参与者、支持事务的服务器、资源管理器以及事务管理器分别位于分布式系统的不同节点之上<br>在两个或多个网络计算机资源上访问并且更新数据。将对两个或多个网络计算机的数据进行的多次操作作为一个整体进行处理。如：不同银行账户之间转账。</p>
<p>一个分布式事务(distributed  transaction)包括一个事务管理器(transaction  manager)和一个或多个资源管理器(resource manager)</p>
<ol>
<li>一个资源管理器(resource  manager)是任意类型的持久化数据存储(数据库)。</li>
<li>事务管理器(transaction manager)承担着所有事务参与单元者的相互通讯的责任。</li>
</ol>
<h2 id="分布式事务处理流程"><a href="#分布式事务处理流程" class="headerlink" title="分布式事务处理流程"></a>分布式事务处理流程</h2><p>分布式事务处理允许JDBC驱动程序支持两段式提交协议</p>
<p>阶段一：开始向事务涉及到的全部资源发送提交前信息。此时，事务涉及到的资源还有最后一次机会来结束事务。如果任意一个资源决定结束事务，则整个事务取消，不会进行资源的更新。否则，事务将正常执行。为了防止发生资源更新失败，所有资源的更新都会写入到日志中。这些日志是永久性的，因此，这些日志在更新失败之后可以重新对所有资源进行恢复。(更新内存数据)</p>
<p>阶段二：只在阶段一没有异常结束的时候才会发生。此时，所有的资源管理器都开始执行真正的数据更新。 (更新数据库数据)</p>
<p>能实现分布式事务管理的事务管理器：</p>
<ol>
<li>JTA允许应用程序执行分布式事务处理。支持JTA的JDBC驱动程序极大地增强了数据访问能力。如果计划使用JTA来处理分布式事务,需要一个实现了以下接口的JDBC驱动</li>
</ol>
<p><code>javax.sql.XADataSource:获得XAConnection对象的工厂
javax.sql.XAConnection:继承PooledConnection,为分布式事务提供支持，事务管理器(通常为中间层服务器的一部分)通过XAResource对象管理XAConnection对象
javax.sql.DataSource</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JMS使用中遇到的问题&quot;&gt;&lt;a href=&quot;#JMS使用中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;JMS使用中遇到的问题&quot;&gt;&lt;/a&gt;JMS使用中遇到的问题&lt;/h1&gt;&lt;h2 id=&quot;使用spring的消息转换器时提示的安全问题&quot;&gt;&lt;a hr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaWeb 关键知识点答疑</title>
    <link href="http://yoursite.com/2018/01/01/JavaWeb-%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AD%94%E7%96%91/"/>
    <id>http://yoursite.com/2018/01/01/JavaWeb-关键知识点答疑/</id>
    <published>2018-01-01T06:16:59.000Z</published>
    <updated>2018-01-19T14:22:37.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-xml的作用"><a href="#web-xml的作用" class="headerlink" title="web.xml的作用"></a>web.xml的作用</h1><p>web.xml文件并不是web工程必须的，只有你需要配置欢迎页、servlet、filter等的时候，才需要配置它。web.xml的模式文件是由Sun公司定义的，每个web.xml文件的根元素<web-app>中，都必须标明这个web.xml使用的是哪些模式文件。</web-app></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;2.5&quot;
    xmlns=&quot;http://Java.sun.com/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;
&lt;/web-app&gt;
</code></pre><p>Tomcat加载欢迎页面的顺序：</p>
<ol>
<li>如果web中的web.xml文件中配置了欢迎页面，访问web的时候，就返回那个指定的欢迎页面</li>
<li>如果web中没有web.xml，或者web.xml中没有指定欢迎页面，Tomcat默认先查询index.html</li>
<li>如果第2步没有找到index.html，那就会去找index.jsp</li>
<li>如果以上步骤都没有找到合适的欢迎页面，那就返回<code>resource (/XXX) is not available</code></li>
</ol>
<h2 id="web-xml中命名与定制URL"><a href="#web-xml中命名与定制URL" class="headerlink" title="web.xml中命名与定制URL"></a>web.xml中命名与定制URL</h2><p>命名必须在定制URL之前</p>
<ol>
<li><p>servlet命名</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;
    &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
</code></pre></li>
<li><p>为servlet定制URL</p>
<pre><code>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></li>
</ol>
<h2 id="web-xml的加载顺序"><a href="#web-xml的加载顺序" class="headerlink" title="web.xml的加载顺序"></a>web.xml的加载顺序</h2><h3 id="根据节点确定加载顺序"><a href="#根据节点确定加载顺序" class="headerlink" title="根据节点确定加载顺序"></a>根据节点确定加载顺序</h3><ol>
<li>启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取<listener>和<context-param>两个结点。</context-param></listener></li>
<li>紧急着，容器创建一个ServletContext（servlet上下文），这个web项目的所有部分都将共享这个上下文。</li>
<li>容器将<context-param>转换为键值对，并交给servletContext。</context-param></li>
<li>容器创建<listener>中的类实例，创建监听器。</listener></li>
</ol>
<h3 id="根据oad-on-startup-元素的值确定加载顺序"><a href="#根据oad-on-startup-元素的值确定加载顺序" class="headerlink" title="根据oad-on-startup 元素的值确定加载顺序"></a>根据oad-on-startup 元素的值确定加载顺序</h3><p>oad-on-startup 元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候，加载这个servlet 。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。</p>
<h3 id="加载优先级的一些补充"><a href="#加载优先级的一些补充" class="headerlink" title="加载优先级的一些补充"></a>加载优先级的一些补充</h3><p>首先可以肯定的是，加载顺序与它们在 web.xml 文件中的先后顺序无关。即不会因为 filter 写在 listener 的前面而会先加载 filter。</p>
<p>按元素节点加载的顺序：context-param -&gt; listener -&gt;filter -&gt; servlet 。但对于同一类的元素节点，加载的顺序是和在web.xml中的配置顺序有关的</p>
<h1 id="servlet基础知识"><a href="#servlet基础知识" class="headerlink" title="servlet基础知识"></a>servlet基础知识</h1><h2 id="实现一个用户自己的servlet"><a href="#实现一个用户自己的servlet" class="headerlink" title="实现一个用户自己的servlet"></a>实现一个用户自己的servlet</h2><ol>
<li>所有用户自定义的servlet都必须要么继承javax.servlet.GenericServlet ，要么继承 javax.servlet.http.HttpServlet。前者是普通的servlet，后者是和HTTP相关servlet，这里介绍的和web相关的servlet一般都是继承自HttpServlet</li>
<li>在用户自定义的servlet中需要重写doGet和doPost方法，当一个GET或者POST请求到来后会映射到相应的方法。</li>
<li>可以重写别的一些方法，它们可以用来在运行时控制用</li>
<li>HttpServletRequest 和 HttpServletResponse 是所有doXXX()方法的默认参数。</li>
<li>为了发送内容给客户端，你需要使用从 HttpServletResponse 里获取的 PrintWriter 对象。任何写到这个对象的内容都会被写进outputstream里，并会把内容发送回给客户端。</li>
</ol>
<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><ol>
<li>初始阶段，web容器通过调用init()方法来初始化Servlet实例。这个方法在Servlet实例的生命周期里只调用一次。</li>
<li>处理客户端请求，web容器调用Servlet的service()方法来处理每一个请求。service() 方法定义了能够处理的请求类型并且调用适当方法来处理这些请求。编写Servlet的开发者必须实现这些请求对应的方法，否则就会调用父类对应的方法</li>
<li>消亡期，web容器调用destroy()方法来终结Servlet。如果你想在Servlet的生命周期内关闭或者销毁一些文件系统或者网络资源，你可以调用这个方法来实现。destroy() 方法和init()方法一样，在Servlet的生命周期里只能调用一次。</li>
</ol>
<h2 id="Servlet的优势"><a href="#Servlet的优势" class="headerlink" title="Servlet的优势"></a>Servlet的优势</h2><ol>
<li>Java Servlets如此有用的原因之一是Servlet能动态显示网页内容。</li>
<li>Servlet可以轻松创建一个基于请求和响应生命周期的web应用。</li>
<li>它们能够提供HTTP响应并且可以使用同一段代码来处理业务逻辑。处理业务逻辑的能力使Servlet比标准的HTML代码更强大。</li>
</ol>
<h2 id="容器的概念"><a href="#容器的概念" class="headerlink" title="容器的概念"></a>容器的概念</h2><ol>
<li>什么是服务器？</li>
</ol>
<p>就是应用运行的环境</p>
<ol>
<li>什么是servlet容器？</li>
</ol>
<p>如果服务器是一个Java web服务器，那么这个web服务器中就必须包含一个Servlet容器。</p>
<h3 id="容器事件监听器"><a href="#容器事件监听器" class="headerlink" title="容器事件监听器"></a>容器事件监听器</h3><p>为了创建一个基于容器事件执行动作的监听器，你必须创建一个实现 ServletContextListener 接口的类。这个类必须实现的方法有 contextInitialized() 和 contextDestroyed()。这两个方法都需要 ServletContextEvent 作为参数，并且在每次初始化或者关闭Servlet容器时都会被自动调用。</p>
<h2 id="servlet过滤器"><a href="#servlet过滤器" class="headerlink" title="servlet过滤器"></a>servlet过滤器</h2><p>Web过滤器在给定的URL被访问时对请求进行预处理并调用相应的功能是很有用的。相 比于直接调用给定URL请求的Servlet，包含相同URL模式的过滤器（filter）会在Servlet调用前被调用。过滤器必须要实现 javax.servlet.Filter 接口。这个接口包含了init()，descriptor()和doFilter()这些方法。init()和destroy()方法会被容器调用。 doFilter()方法用来在过滤器类里实现逻辑任务。如果你想把过滤器组成过滤链（chain filter）或者存在多匹配给定URL模式的个过滤器，它们就会根据web.xml里的配置顺序被调用。过滤器的URL必须对应需要过滤的servlet，两者的URL必须一模一样，在进入servlet前，web容器都会先调用相应的filter。</p>
<h1 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h1><p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。用来告诉客户端所获取的文件的类型，使得客户端可以调用相应的插件或应用来处理这个请求相应回来的文件。</p>
<h1 id="请求转发和请求重定向"><a href="#请求转发和请求重定向" class="headerlink" title="请求转发和请求重定向"></a>请求转发和请求重定向</h1><h2 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h2><p>有时候，你的应用需要把一个Servlet要处理的请求转让给另外的Servlet来处理并完成任务。而且，转让请求时不能重定向客户端的URL。即浏览器地址栏上的URL不会改变。在 ServletContext 里已经内置了实现上面需求的方法。所以，当你获取了 ServletContext 的引用，你就可以简单地调用getRequestDispatcher() 方法去获取用来转发请求的 RequestDispatcher 对象。当调用 getRequestDispatcher() 方法时，需要传递包含servlet名的字符串，这个Servlet就是你用来处理转让请求的Servlet。获取 RequestDispatcher 对象后，通过传递 HttpServletRequest 和HttpServletResponse 对象给它来调用转发方法。转发方法负责对请求进行转发。</p>
<pre><code>RequestDispatcher rd = servletContext.getRequestDispatcher(&quot;/NextServlet&quot;);
rd.forward(request, response);
</code></pre><h2 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h2><p>尽管有时候，你不想在Servlet发送重定向时通知用户，就像我们在上面那段看到的一样。但是在某些情况下，我们确实想要通知用户。当应用内的特定URL被访问时，你想把浏览器的URL重定向到另外一个。<br>要实现这种功能，你需要调用 HttpServletResponse 对象的sendRedirect()方法。</p>
<pre><code>httpServletResponse.sendRedirect(&quot;/anotherURL&quot;);
</code></pre><h1 id="Web服务器，应用服务器，Web容器"><a href="#Web服务器，应用服务器，Web容器" class="headerlink" title="Web服务器，应用服务器，Web容器"></a>Web服务器，应用服务器，Web容器</h1><h2 id="Web服务器和应用服务器"><a href="#Web服务器和应用服务器" class="headerlink" title="Web服务器和应用服务器"></a>Web服务器和应用服务器</h2><p>在以前这两者是有明显的区别，但是现在这两者的区别逐渐合并，甚至于在某些情况下可以把二者看为一件事物了（实体）。</p>
<p>一开始，<strong>web服务器</strong>足够简单，只提供基于HTTP协议的静态页面内容和图片，在那个时候，大部分的内容都是静态的，HTTP1.0协议只是把静态文件移动来移动去。但是之后很快web server演进到有了CGI的能力，这意味着有效地在每个web请求上启动一个进程来生成动态内容，这个时候的HTTP协议更加成熟，web server变得更加的复杂，其增加了许多的功能，如缓存，安全和会话管理等。随着技术的进一步成熟，我们从Kiva和NetDynamics获得了公司特有的基于java的服务器端技术，这些技术最终都集成到JSP中，这项技术我们今天任然用在大部分的应用开发中。</p>
<p>与web server对应的应用服务器（application servers）演进和存在了很长时间。一些公司为Unix发布产品，如Tuxedo, TopEnd, Encina ，它们都是基于大型机应用管理和类似IMS和CICS的模拟环境的哲学上的演进思想。这些产品中的大多数都指定了“封闭”的特定于产品的通信协议，将“重量级”客户端与服务器互连。90年代，这些传统的应用服务器产品开始演进出基于HTTP的通信协议的能力，一开始是经由网关，但很快这两种方式的界限就变得模糊不清了。</p>
<p>与此同时，web server因为能处理更高的加载，更多的并发和更好的特性。应用服务器开始发布越来越多的基于HTTP协议的通信能力，这就导致了web服务和应用服务器的之间的界限越来越窄。</p>
<p>现今，web服务器和应用服务器已经无多大区别，但有时候人们还会基于一些重要的特征来区别它们。</p>
<h2 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h2><center> <img src="https://howtodoinjava.com/wp-content/uploads/web-server-servlet-container.jpg" alt="web server与web container的区别"> </center>

<p>Web Container，是java中的一种特殊说法，应该指的就是servlet容器。servlet容器就是web服务器的一个组件，它可以与servlet交互。一个web容器负责管理servlet的生命周期，映射一个URL到一个特殊的servlet，并确保这个URL请求有正确的访问权限和更多这样的服务。总之，据以上所述，servlet容器就是servlet的运行环境和它的生命周期的维护位置。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>对于java而言，servlet让你可以编写服务端组件，这些组件有助于生成基于请求的动态内容。实际上，servlet是javax.servlet包中的一个接口，其中为一个servlet的生命周期声明了三个重要的方法——init(),service()和destroy()。每个servlet都会实现这三个方法，它们会在servlet的生命周期中的特定时间被调用。servlet是运行与服务端的，独立与平台和协议的技术。</p>
<center><img src="http://img.blog.csdn.net/20150420163121018" alt="servlet的工作流程"></center>

<p>在浏览器中输入一个URL地址后发生的事：</p>
<ol>
<li>根据输入的地址找到服务器</li>
<li>根据端口找到服务器上对应的在该端口上监听的程序（Tomcat）</li>
<li>进入找到的服务器程序</li>
<li>在服务器程序中找到servlet容器</li>
<li>在servlet容器中根据URL定位到提供服务的servlet的名称,如果没有找到对应的servlet类，就会调用Tomcat定义的DefaultServlet来直接访问webapp目录下的金泰资源</li>
<li>根据servlet名称找到servlet对应的servlet类</li>
<li>根据servlet类反射获取指定的方法</li>
<li>指定的方法动态生成响应</li>
<li>响应返回给服务器程序</li>
<li>服务器程序把响应传回给客户端程序（浏览器）</li>
</ol>
<p>Servlet类通过类加载器动态地加载到容器中，既可以通过懒加载的方式，也可以通过饿加载的方式。每个请求都有自己的线程，在同一时间，一个servlet可以服务于多个线程。当servlet对象不再使用了就会被JVM垃圾回收。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>当servlet容器启动时，它会部署和加载所有的应用，当一个应用被加载的时候，servlet容器会为每个应用创建一个ServletContext，且把它保留在内存中。web应用的web.xml会被解析，在web.xml中的每一个Servlet，Filter和Listener都会被创建一次，并也会保留在服务器的内存中。当servlet容器关闭的时候，会卸载所有的应用和ServletContext，所有的Servlet，Filter和Listener也都会被销毁。</p>
<p>按java文档所描述的，ServletContext定义了一系列servlet用来与它的容器通信的方法，例如过去文件的MIME类型，分发请求，或写日志文件等。在一个web应用在它的发布描述符中标记“分布式”的情况下，每个虚拟机会有一个context实例。在这种情况下，context不能用作共享全局信息的位置（因为信息不是真的全局的）。需要使用一个额外的资源，比如数据库。</p>
<h2 id="ServletRequest-和-ServletResponse-适合在servlet生命周期的那个阶段使用"><a href="#ServletRequest-和-ServletResponse-适合在servlet生命周期的那个阶段使用" class="headerlink" title="ServletRequest 和 ServletResponse 适合在servlet生命周期的那个阶段使用"></a>ServletRequest 和 ServletResponse 适合在servlet生命周期的那个阶段使用</h2><p>servlet容器绑定到一个web服务器上，该web服务器在某个端口上监听HTTP请求，通常是在80端口上。当一个客户端发送一个HTTP请求，servlet容器会创建一个新的HttpServletRequest 和 HttpServletResponse对象，并通过已经创建的URL模式匹配请求URL的filter和servlet实例来传递它们，所有这些都是在一个线程中完成的。</p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>当一个客户端第一次访问web应用，HttpSession会通过request.getSession()第一次被获取，servlet容器会创建它，生成一个长的独一无二的ID，并把它存入服务器内存中，Servlet也会为HTTP响应设置一个cookie，JSESSIONID 作为cookie的名称，独一无二的session ID作为cookie的值。</p>
<p>根据Http cookie的说明文档，只要这个cookie是有效的，在后续的请求中客户端都需要返回这个cookie。servlet容器将确定每一个传入的HTTP请求头，并使用名为JSESSIONID的cookie，使用cookie的值关联server内存中的HttpSession。</p>
<p>HttpSession一直存在，除非超过一定的时间没有被使用了，这个时间通常可以在web.xml中设置，默认值会是30分钟。因此当客户端超过30分钟没有访问应用时，servlet容器会销毁这个session。后续的每个请求，即便是有指定cookie的，也不再能访问相同session。servlet容器会创建一个新的。</p>
<p>另一方面，在客户端的session cookie有一个默认的存在时长，与浏览器的运行一样的时长。所以只要客户端关闭浏览器，在客户端的cookie就会被销毁。重新打开浏览器，与这个会话相关的cookie都不会再被发送。新的request.getSession()将会返回一个新的HttpSession，使用一个新的session ID设置一个新的cookie。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>你应该意识到你不能赋值任何请求或会话作用域的数据为一个servlet或filter的实例的变量。这些变量会在所有的请求会话中共享，这样的话就会导致线程不安全。<br><strong>Servlet在Tomcat中单实例多线程，导致了servlet在多线程下变量共享的线程安全问题。</strong></p>
<p>注：servlet的设计不是singleto模式，知识说servlet容器只创建其一次。</p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>Servlet输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。为解决这个问题，SUN推出了类似于ASP的镶嵌型的JSP，JSP把TAG嵌套到HTML语句中，就大大简化和方便了网页的设计和修改。</p>
<ol>
<li>JSP在本质上就是servlet，但两者的创建方式不一样</li>
<li>servlet是完全有java语言编写，善于流程控制和事务处理，通过servlet来生成动态网页很不直观</li>
<li>JSP由HTML代码和JSP标签组成，可以方便的编写动态网页</li>
</ol>
<p>基于以上原因，实际应用中多采用servlet来控制业务流程，采用JSP来生成动态网页。在MVC框架中，JSP位于视图层，servlet位于控制层。</p>
<ol>
<li>JSP是servlet的技术扩展，本质上就是servlet的简易形式</li>
<li>JSP编译后就是servlet类</li>
<li>servlet和JSP的最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP是Java和HTML组合成一个扩展名为.jsp的文件</li>
<li>JSP侧重于视图，Servlet主要用于控制逻辑。</li>
</ol>
<h3 id="web服务器使用JSP创建网页"><a href="#web服务器使用JSP创建网页" class="headerlink" title="web服务器使用JSP创建网页"></a>web服务器使用JSP创建网页</h3><ol>
<li>对于一个正常的页面，浏览器发送一个HTTP请求到万维网服务器。</li>
<li>网站服务器识别HTTP请求是一个JSP页面，并将其转发给JSP引擎。这是通过使用URL或JSP页面，而这个页面使用 .jsp 后缀，而不是 .html 后缀。</li>
<li>JSP引擎从磁盘加载JSP页面，并将其转换成servlet的内容。这种转换是很简单的，所有的模板文本被转换给println()语句，所有JSP元素被转换为实现该页面相应动态行为的Java代码。</li>
<li>JSP引擎编译成servlet的一个可执行类并转发原始请求到servlet引擎。</li>
<li>一部分Web服务器调用servlet引擎加载Servlet类并执行它。在执行期间，Servlet产生HTML的格式输出，其servlet引擎传递到web服务器响应HTTP请求。</li>
<li>Web服务器响应HTTP转发静态的HTML内容到浏览器。</li>
<li>最后的 web 浏览器处理HTTP响应动态生成的HTML页面完全就像一个静态页面内容。</li>
</ol>
<p><strong><em>JSP可通过servlet引擎动态的编译为静态页面</em></strong></p>
<ol>
<li><p>JSP脚本，JSP语法：</p>
<pre><code>&lt;% code fragment %&gt;
</code></pre><p>或XML语法：</p>
<pre><code>&lt;jsp:scriptlet&gt;
       code fragment
&lt;/jsp:scriptlet&gt;
</code></pre></li>
<li><p>JSP声明，JSP语法：</p>
<pre><code>&lt;%! declaration; [ declaration; ]+ ... %&gt;
</code></pre><p>或XML语法：</p>
<pre><code>&lt;jsp:declaration&gt;
       code fragment
&lt;/jsp:declaration&gt;
</code></pre></li>
<li><p>JSP表达式，JSP语法：</p>
<pre><code>&lt;%= expression %&gt;
</code></pre><p>或XML语法：</p>
<pre><code>&lt;jsp:expression&gt;
       expression
&lt;/jsp:expression&gt;
</code></pre></li>
<li><p>JSP注释，JSP语法：</p>
<pre><code>&lt;%-- This is JSP comment --%&gt;
</code></pre></li>
<li><p>JSP指令</p>
<pre><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;
</code></pre><p>有三种类型的指令标记：</p>
<pre><code>&lt;%@ page ... %&gt;&lt;!--定义页面依赖属性，例如脚本语言，错误页面和缓冲的要求--&gt;
&lt;%@ include ... %&gt;&lt;!--包括在转换阶段的文件--&gt;
&lt;%@ taglib ... %&gt;&lt;!--声明了一个标签库，包含自定义动作，用在页面中--&gt;
</code></pre></li>
<li><p>JSP动作，JSP动作使用XML语法结构来控制Servlet引擎的行为。可以动态地插入文件，重用JavaBeans组件，用户转发到另一个页面，或为Java插件生成HTML。语法：</p>
<pre><code>&lt;jsp:action_name attribute=&quot;value&quot; /&gt;    
</code></pre></li>
<li>JSP隐式对象</li>
</ol>
<p>JSP支持九种自动定义的变量，这也被称为隐式对象。这些变量是：</p>
<ul>
<li>request：这是与请求相关联的HttpServletRequest对象</li>
<li>response：这是用于响应客户端相关联的HttpServletResponse对象</li>
<li>out：这是用于将输出发送给客户端的PrintWriter对象</li>
<li>session：这是与请求相关联的HttpSession对象</li>
<li>application：这是应用程序上下文关联的ServletContext对象</li>
<li>config：这是与页面关联的ServletConfig对象</li>
<li>pageContext：这封装采用类似更高的性能JspWriters服务器特定的功能</li>
<li>page：这是一个简单的代名词，是用来调用由转换servlet类中定义的方法</li>
<li>Exception：Exception对象允许例外的数据由JSP指定访问</li>
</ul>
<h2 id="JSP对象的范围"><a href="#JSP对象的范围" class="headerlink" title="JSP对象的范围"></a>JSP对象的范围</h2><ul>
<li>page范围：使用此JSP对象可以在其中创建的页面内使用。</li>
<li>Request 范围：使用该JSP对象可以在请求服务任何地方使用。</li>
<li>Session 范围:使用该JSP的对象可用于在属于同一个会话页面。</li>
<li>Application 范围：使用该JSP的对象可以在整个应用程序页面中使用。</li>
</ul>
<h2 id="JSP中使用Javabean"><a href="#JSP中使用Javabean" class="headerlink" title="JSP中使用Javabean"></a>JSP中使用Javabean</h2><p>嵌入一个Java bean到JSP网页，有三个基本动作或标签：<jsp:usebean>, <jsp:setproperty>, <jsp:getproperty></jsp:getproperty></jsp:setproperty></jsp:usebean></p>
<ul>
<li><jsp:usebean>：这个标签是用来给bean指定“id”和“scope”属性相关联。</jsp:usebean></li>
<li><jsp:setproperty>：这个标签被用于设置一个beans属性的值，主要使用“name”属性已经定义的Javabean对象的ID。其他属性是 “property”, “param”, “value”</jsp:setproperty></li>
<li><jsp:getproperty>：个标签是用来获取引用Bean实例属性并将其存储到隐式out对象。</jsp:getproperty></li>
</ul>
<p>bean的规则：</p>
<ul>
<li>包应该是java bean的第一行</li>
<li>Bean应该有一个空的构造</li>
<li>所有的bean中的变量应该设置有“get”，“set”方法。</li>
<li>属性名应以大写字母开头在使用“set”，“get”方法时。</li>
<li>例如变量“名称”的get，set方法就是getName(), setName(String)</li>
<li>设置方法应该返回像一个空(void)值： “return void()”</li>
</ul>
<h2 id="JSP的运行机制"><a href="#JSP的运行机制" class="headerlink" title="JSP的运行机制"></a>JSP的运行机制</h2><center><img src="http://www.blogjava.net/images/blogjava_net/fancydeepin/myself/jsp.png" alt=""></center>

<ol>
<li>当客户端浏览器向服务器请求一个 JSP 页面时，服务器收到该请求后，首先检查所请求的这个JSP 文件内容 ( 代码 ) 是否已经被更新，或者是否是 JSP 文件创建后的第一次被访问</li>
<li>如果是，那么，这个 JSP 文件就会在服务器端的 JSP 引擎作用下转化为一个 Servlet 类的 Java 源代码文件。紧接着，这个 Servlet 类会在 Java 编译器的作用下被编译成一个字节码文件，并装载到 jvm 解释执行。剩下的就等同于 Servlet 的处理过程了。</li>
<li>如果被请求的 JSP 文件内容 ( 代码 ) 没有被修改，那么它的处理过程也等同于一个 Servlet 的处理过程。即直接由服务器检索出与之对应的 Servlet 实例来处理。</li>
</ol>
<p><em>注：JSP 文件不是在服务器启动的时候转换成 Servlet 类的。而是在被客户端访问的时候才可能发生转换的 ( 如 JSP 文件内容没有被更新等，就不再发生 Servlet 转换 )。</em><br>对Tomcat而言，打开目录 %Tomcat%/work/%您的工程文件目录%，在里面会有一个子目录：org/apache/jsp，如果没有这个目录，说明项目的JSP文件还没有被访问过。如果有该目录，进入其中会发现一些<em>_jsp.java 和 </em>_jsp.class 文件，这就是 JSP 文件被转换成Servlet 类的源文件和字节码文件了。</p>
<h1 id="java中一些很少用到特性"><a href="#java中一些很少用到特性" class="headerlink" title="java中一些很少用到特性"></a>java中一些很少用到特性</h1><ol>
<li>import static,静态导入</li>
</ol>
<p>import static（静态导入）是JDK1.5中的新特性，一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.<em>;这里多了个static，还有就是类名ClassName后面多了个 .</em> ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名的方式来调用。</p>
<h1 id="路径的特殊处理"><a href="#路径的特殊处理" class="headerlink" title="路径的特殊处理"></a>路径的特殊处理</h1><pre><code>URL url = this.getClass().getClassLoader().getResource(&quot;/&quot;)
</code></pre><p>上面这行代码会获取class目录的路径，如果其所在目录中含有空格等字符，导致通过如下方式</p>
<pre><code>File dir = new File(url.getFile());
</code></pre><p>获取不了class目录。</p>
<p>解决方法：</p>
<pre><code>File dir = new File(URLDecoder.decode(url.getFile(),&quot;utf-8&quot;));
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;web-xml的作用&quot;&gt;&lt;a href=&quot;#web-xml的作用&quot; class=&quot;headerlink&quot; title=&quot;web.xml的作用&quot;&gt;&lt;/a&gt;web.xml的作用&lt;/h1&gt;&lt;p&gt;web.xml文件并不是web工程必须的，只有你需要配置欢迎页、servle
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JNDI介绍</title>
    <link href="http://yoursite.com/2018/01/01/JNDI%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/01/01/JNDI介绍/</id>
    <published>2018-01-01T06:16:00.000Z</published>
    <updated>2018-01-01T07:05:37.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JNDI简介"><a href="#JNDI简介" class="headerlink" title="JNDI简介"></a>JNDI简介</h1><p>JNDI(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。是一种应用程序设计标准和规范，现在JNDI已经成为J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI的服务。为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上</p>
<ol>
<li>命名服务将名称和对象联系起来，使得我们可以用名称访问对象。</li>
<li>目录服务是一种命名服务，在这种服务里，对象不但有名称，还有属性。也就是说目录服务是一种特殊的命名服务。</li>
</ol>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><ol>
<li>JNDI API提供了一种统一的方式，可以在本地或网络上查找和访问服务。各种服务在命名服务器上注册一个名称，需要使用服务的应用程序通过JNDI找到对应服务就可以使用。</li>
<li>远程服务可以是任何的企业服务。DNS、LDAP(Lightweight Directory AccessProtocol 轻型目录访问协议)、 CORBA对象服务、数据源对象，文件系统、WindowsXP/2000/NT/Me/9x的注册表、RMI、EJB、JMS……</li>
<li>JNDI主要有两部分组成：应用程序编程接口和服务供应商接口。a) 应用程序编程接口提供了Java应用程序访问各种命名和目录服务的功能(API).b)服务供应商接口为任意一种服务的服务供应商(SPI:service provider interface)提供了使用JNDI的功能</li>
</ol>
<h1 id="JDBC与JNDI"><a href="#JDBC与JNDI" class="headerlink" title="JDBC与JNDI"></a>JDBC与JNDI</h1><p>JNDI通过注册能操作数据库的服务（如JDBC）就可以实现同JDBC相同的功能。</p>
<ol>
<li>JNDI：可以获得访问数据相关的对象，从而操作数据。本地不需要驱动，也不需要知道数据在哪里，所有需要访问数据库的都可以用。</li>
<li>JDBC：本地有驱动程序，知道数据在哪里，只有一个应用程序能用。</li>
</ol>
<h2 id="JNDI中的数据访问"><a href="#JNDI中的数据访问" class="headerlink" title="JNDI中的数据访问"></a>JNDI中的数据访问</h2><ol>
<li>驱动代码的加载由服务提供方负责</li>
<li>应用程序需要URL找到指定的服务</li>
<li>JNDI  API使应用程序可以通过逻辑名称获得指定的数据源</li>
<li>JNDI  API提供数据库源服务需要以下内容<br>a. 与数据源关联的数据库驱动程序<br>b. 数据源对象的引用名称<h2 id="JDBC访问数据库"><a href="#JDBC访问数据库" class="headerlink" title="JDBC访问数据库"></a>JDBC访问数据库</h2></li>
<li>javax.sql.DataSource接口是在Java程序设计时使用JNDI获得数据库连接的工具</li>
<li>用程序使用JNDI通过注册名称获得的就是DataSource实现类对象</li>
<li>通过DataSource实现类对象可以获得数据库连接对象(Connection)：所有需要访问数据库的应用程序都可以使用此服务，所以需要同时返回多个连接对象—连接池</li>
<li>由驱动程序供应商实现：实现DataSource接口的对象在基于JNDI  API的命名服务中注册后，应用程序就可以通过JNDI获得相关对象，从而访问数据库服务器。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDBC与JNDI：使用JDBC创建一个访问数据库的对象，此对象在JNDI服务器中注册一个逻辑名称，通过JNDI查找到该名称就可以获得相关对象。使得多个应用程序都可以访问数据库。</p>
<p>JNDI能注册各种各样可用的服务，使用JDBC实现的数据访问服务是其中之一</p>
]]></content>
    
    <summary type="html">
    
      JNDI是一种服务标准，定义的怎么使用服务和怎么提供服务，当然这里的使用服务一般来说是java应用程序
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日志系统</title>
    <link href="http://yoursite.com/2017/12/31/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/12/31/日志系统/</id>
    <published>2017-12-31T13:02:45.000Z</published>
    <updated>2017-12-31T14:05:15.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="slf4j-api、slf4j-log4j12以及log4j之间什么关系？"><a href="#slf4j-api、slf4j-log4j12以及log4j之间什么关系？" class="headerlink" title="slf4j-api、slf4j-log4j12以及log4j之间什么关系？"></a>slf4j-api、slf4j-log4j12以及log4j之间什么关系？</h1><p><code>slf4j:Simple Logging Facade for Java</code>，为java提供的简单日志Facade。Facade：门面，更底层一点说就是接口。他允许用户以自己的喜好，在工程中通过slf4j接入不同的日志系统。更直观一点，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。</p>
<p>因此，slf4j入口就是众多接口的集合，他不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。查看slf4j-api源码就可以发现，里面除了public final class LoggerFactory类之外，都是接口定义。因此，slf4j-api本质就是一个接口定义。</p>
<p>一句话总结：slf4j提供接口，各个日志系统或框架实现这些接口。好处是统一了日志系统的管理</p>
<center><img src="http://img.my.csdn.net/uploads/201211/18/1353244238_7191.png" alt="三者之间的关系">     </center>

<p>说明：</p>
<ol>
<li>以slf4j-api作为应用的日志入口</li>
<li>在应用编译的时候slf4j-api中public final class LoggerFactor类中的private final static void bind() 方法会寻找具体的日志实现类绑定，主要是通过StaticLoggerBinder.getSingleton();的语句调用。</li>
<li>slf4j-log4j12作为链接slf4j-api和log4j中间的适配器。它实现了slf4j-api中的StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法</li>
<li>log4j:这个是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。</li>
</ol>
<h1 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h1><p> LogBack 作为一个通用可靠、快速灵活的日志框架，将作为Log4j 的替代和SLF4J 组成新的日志系统的完整实现。官网上称具有极佳的性能，在关键路径上执行速度是log4j 的10 倍，且内存消耗更少。</p>
<h1 id="别的常见的日志方案"><a href="#别的常见的日志方案" class="headerlink" title="别的常见的日志方案"></a>别的常见的日志方案</h1><p>commons-logging+log4j。commons-logging类似于slf4j（slf4j-api）的作用。提供统一的日志接口</p>
]]></content>
    
    <summary type="html">
    
      理清在pom文件中引入的各个与日志相关的包的关系
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git 常用命令总结</title>
    <link href="http://yoursite.com/2017/12/10/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/10/git-常用命令总结/</id>
    <published>2017-12-10T09:07:03.000Z</published>
    <updated>2017-12-10T09:14:13.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="设置换行符转换"><a href="#设置换行符转换" class="headerlink" title="设置换行符转换"></a>设置换行符转换</h2><p>由于不同操作系统的换行符不同，因此如果本地使用window开发，而远程仓库是Linux系统，导致提交不成功。</p>
<h2 id="1-不同操作系统的换行符"><a href="#1-不同操作系统的换行符" class="headerlink" title="1. 不同操作系统的换行符"></a>1. 不同操作系统的换行符</h2><ul>
<li>CR回车 LF换行</li>
<li>Windows/Dos CRLF \r\n</li>
<li>Linux/Unix LF \n</li>
<li>MacOS CR \r</li>
</ul>
<h2 id="2-解决换行符不一致的设置方式"><a href="#2-解决换行符不一致的设置方式" class="headerlink" title="2. 解决换行符不一致的设置方式"></a>2. 解决换行符不一致的设置方式</h2><ul>
<li>提交时转换为LF，检出时转换为CRLF：git config –global core.autocrlf true</li>
<li>提交时转换为LF，检出时不转换：git config –global core.autocrlf input</li>
<li>提交检出均不转换：git config –global core.autocrlf false</li>
<li>拒绝提交包含混合换行符的文件：git config –global core.safecrlf true</li>
<li>允许提交包含混合换行符的文件：git config –global core.safecrlf false</li>
<li>提交包含混合换行符的文件时给出警告：git config –global core.safecrlf warn</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;h2 id=&quot;设置换行符转换&quot;&gt;&lt;a href=&quot;#设置换行符转换&quot; class=&quot;headerlink&quot; title=&quot;设置换行符转换&quot;&gt;&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>eclipse下javaweb 开发环境搭建</title>
    <link href="http://yoursite.com/2017/12/10/eclipse%E4%B8%8BJava%20Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/12/10/eclipse下Java Web开发环境搭建/</id>
    <published>2017-12-10T03:54:47.000Z</published>
    <updated>2017-12-10T10:36:01.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eclipse安装"><a href="#eclipse安装" class="headerlink" title="eclipse安装"></a>eclipse安装</h1><h1 id="Tomcat安装配置"><a href="#Tomcat安装配置" class="headerlink" title="Tomcat安装配置"></a>Tomcat安装配置</h1><ol>
<li><a href="https://tomcat.apache.org/" target="_blank" rel="external">下载</a>需要的版本</li>
<li>解压</li>
<li>启动，进入/bin目录双击startup.bat，启动后通过在浏览器输入<a href="http://localhost:8080访问Tomcat首页，如果启动成功，就会打开Tomcat首页" target="_blank" rel="external">http://localhost:8080访问Tomcat首页，如果启动成功，就会打开Tomcat首页</a></li>
<li>配置环境变量</li>
<li>给eclipse添加本地Tomcat，window-&gt;preferences-&gt;Server-&gt;Runtime Environment。如果eclipse不支持高版本的Tomcat，可以把高版本的Tomcat伪造为eclipse支持的Tomcat。把高版本的Tomcat伪造为低版本的Tomcat：1. <a href="https://www.zhihu.com/question/37809905" target="_blank" rel="external">参考</a>；2. 安装Eclipse Tomcat Plugin</li>
</ol>
<h1 id="Maven安装配置"><a href="#Maven安装配置" class="headerlink" title="Maven安装配置"></a>Maven安装配置</h1><ol>
<li><a href="http://maven.apache.org/" target="_blank" rel="external">下载</a>需要的版本</li>
<li>解压</li>
<li>配置环境变量</li>
<li>检查安装是否成功：命令行输入mvn -version,看到Maven home字样，说明安装成功。</li>
<li>配置：在config/settings.xml中配置本地库目录<code>&lt;localRepository&gt;D:\Software App\Java\Maven\mvn_repository&lt;/localRepository&gt;</code> settings.xml文件是用来设置maven的，对maven的配置基本上都是在这个文件中完成。<br>6.</li>
</ol>
<h2 id="maven功能简介"><a href="#maven功能简介" class="headerlink" title="maven功能简介"></a>maven功能简介</h2><h2 id="maven基本命令"><a href="#maven基本命令" class="headerlink" title="maven基本命令"></a>maven基本命令</h2><h1 id="创建webApp项目"><a href="#创建webApp项目" class="headerlink" title="创建webApp项目"></a>创建webApp项目</h1><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><ol>
<li>右键-&gt;new-&gt;other,找到maven,选择maven project-&gt;next。</li>
<li>选择maven-archetype-webapp后，点击next,注意,可以在filter中先输入webapp,这样就能快速找到maven-archetype-webapp选项,如果此时列出来的选择项仍然很多,就盯着version看,找version是release的。</li>
<li>输入groupid,artifact id和packgage,点击finish,然后耐心等待,第一次新建maven会有很多依赖包要下载,所以会比较慢.取决于你的网速和电脑配置。</li>
<li>创建中的注意事项：groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。artifactId设置为项目名称依照这个设置，你的包结构最好是（域.公司名称.项目名称）打头的.当然你的package可以不是这个,也可以自由输入,输入后你新建的项目默认就会有对应的包。</li>
<li>如果项目中的内容未报错，但项目文件夹上有错误，很可能是项目依赖的jdk版本与settings.xml文件中的java版本不同。只需要把settings.xml文件中java版本改为与eclipse引用的java版本相同即可。</li>
<li>eclipse中使用maven创建项目JDK版本默认是1.5解决方法：1. 修改maven的settings.xml文件。添加以下行，jdk版本改为自己需要的版本：<br>` <profile><br> <id>jdk-1.7</id><br> <activation>  <pre><code>&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  
&lt;jdk&gt;1.7&lt;/jdk&gt;  
</code></pre> </activation><br> <properties>  <pre><code>&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;  
&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  
&lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt;  
</code></pre> </properties><br></profile>`<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><a href="https://www.cnblogs.com/NieXiaoHui/p/5990570.html" target="_blank" rel="external">参考</a></li>
</ol>
<h1 id="MySql安装配置"><a href="#MySql安装配置" class="headerlink" title="MySql安装配置"></a>MySql安装配置</h1><ol>
<li><a href="https://dev.mysql.com/downloads/windows/installer/" target="_blank" rel="external">下载</a>，Windows下只有32位的安装包</li>
<li>安装，与普通软件的安装并没有区别</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eclipse安装&quot;&gt;&lt;a href=&quot;#eclipse安装&quot; class=&quot;headerlink&quot; title=&quot;eclipse安装&quot;&gt;&lt;/a&gt;eclipse安装&lt;/h1&gt;&lt;h1 id=&quot;Tomcat安装配置&quot;&gt;&lt;a href=&quot;#Tomcat安装配置&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/20/hello-world/"/>
    <id>http://yoursite.com/2017/10/20/hello-world/</id>
    <published>2017-10-20T12:49:03.277Z</published>
    <updated>2016-09-02T14:57:49.035Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jdk 源码阅读</title>
    <link href="http://yoursite.com/2017/08/30/jdk-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/30/jdk-源码阅读/</id>
    <published>2017-08-30T15:16:11.000Z</published>
    <updated>2017-08-30T15:42:15.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><ul>
<li>Java中一个Unicode字符占两个字节</li>
<li>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII<br>码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中<br>文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java中一个Unicode字符占两个字节&lt;/li&gt;
&lt;li&gt;UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="后端，Java" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习</title>
    <link href="http://yoursite.com/2017/08/06/Vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/08/06/Vue学习/</id>
    <published>2017-08-06T14:53:02.000Z</published>
    <updated>2017-08-06T14:58:52.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法"><a href="#在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法" class="headerlink" title="在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法"></a>在基于vue-cli模板开发的组件的工程中使用font-awesome字体图标库的方法</h1><p>方法一、</p>
<p>npm install –save-dev font-awesome</p>
<p>在main.js里添加</p>
<p>import ‘font-awesome/css/font-awesome.css’</p>
<p>方法二、</p>
<p>在官网下载代码到本地，现在应该是font-awesome-4.7，把整个文件夹放到资源文件夹中，然后在index.html中加上：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/font-awesome-4.7/css/font-awesome.min.css&quot;&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      学习Vue中遇到的一些问题的解决方法
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://yoursite.com/2017/07/11/webpack-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/07/11/webpack-入门/</id>
    <published>2017-07-11T13:36:14.000Z</published>
    <updated>2017-07-11T13:56:20.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建第一个webpack的前端项目"><a href="#创建第一个webpack的前端项目" class="headerlink" title="创建第一个webpack的前端项目"></a>创建第一个webpack的前端项目</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>安装nodejs和npm（nodejs package managemer），新版本的nodejs都是自带npm的，安装完nodejs，默认就安装了npm，最好是把npm的包下载路径指向国内的镜像，方便下载。常用的有cnpm。</p>
<h2 id="初始化webpack前端工程"><a href="#初始化webpack前端工程" class="headerlink" title="初始化webpack前端工程"></a>初始化webpack前端工程</h2><ul>
<li>mkdir webpack-demo &amp; cd webpack-demo</li>
<li>npm init -y</li>
<li>npm install –save-dev webpack</li>
</ul>
<h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><ul>
<li>mkdir src</li>
<li>mkdir dist</li>
<li>在src目录下创建 index.js文件，其中的内容</li>
</ul>
]]></content>
    
    <summary type="html">
    
      webpack是前端代码的包管理工具，依赖管理工具，类似后端开发中的maven
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring Framework 指导文档</title>
    <link href="http://yoursite.com/2017/05/02/Spring-Framework-%E6%8C%87%E5%AF%BC%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/2017/05/02/Spring-Framework-指导文档/</id>
    <published>2017-05-02T14:15:58.000Z</published>
    <updated>2017-06-06T15:37:58.620Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring-依赖和依赖于Spring"><a href="#Spring-依赖和依赖于Spring" class="headerlink" title="Spring 依赖和依赖于Spring"></a>Spring 依赖和依赖于Spring</h4><p>尽管Spring为大量的企业和其他非Spring的工具提供集成和支持， 但Spring特意使依赖于它的应用尽可能的依赖一个绝对小的包集合：为了在一个小的用例中使用Spring，你不必搜索（定位）和下载大量的jar库文件。对于基本的依赖注入，只有一个强制的外部依赖，就是日志记录相关的依赖。<br>接下来我们即将概述配置一个依赖于Spring应用所必须的基本步骤，首先，通过maven配置，接着是通过gradle配置，最后是通过Ivy配置。在任何一种配置方式下，如果有不清楚的，参考你的依赖管理系统文档，或者查看一些样例的编码——Spring本身在构建的时候就是使用gradle管理依赖的，我们的样例大多也是是应用gradle和Maven来做依赖管理的。</p>
<h4 id="Maven-依赖管理"><a href="#Maven-依赖管理" class="headerlink" title="Maven 依赖管理"></a>Maven 依赖管理</h4><p>如果你使用的是maven做依赖管理，你甚至不必明确地提供日志相关的依赖，例如，为创建一个应用环境并使用依赖注入来配置一个应用，你的maven依赖如下：</p>
<p><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.0.0.M5&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></p>
<p>正如上面所示，注意，如果你不必依赖于Spring的API编译，那么可以通过<scope>声明为运行时依赖，这是一个典型的关于基本的依赖注入的用例。</scope></p>
<p>上述例子工作在Maven中心库上，为了使用Maven库，必须在maven的配置文件中指定库的位置。只依赖于所有的发布版本的配置：</p>
<p><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;io.spring.repo.maven.release&lt;/id&gt;
        &lt;url&gt;http://repo.spring.io/release/&lt;/url&gt;
        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></p>
<p>依赖于里程碑的配置：</p>
<p><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;io.spring.repo.maven.milestone&lt;/id&gt;
        &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt;
        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></p>
<p>依赖于快照的配置：</p>
<p><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;io.spring.repo.maven.snapshot&lt;/id&gt;
        &lt;url&gt;http://repo.spring.io/snapshot/&lt;/url&gt;
        &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></p>
<h4 id="Maven-依赖“材料清单”"><a href="#Maven-依赖“材料清单”" class="headerlink" title="Maven 依赖“材料清单”"></a>Maven 依赖“材料清单”</h4><p>在使用Maven的时候，可能不慎混合不同的Spring版本，例如，你会发现一个第三方库，或者另一个Spring工程，引入了一个传递依赖，并且该依赖还是一个较早的发行版本。如果你忘了明确的声明一个直接依赖，许多难以预料的问题会发生。</p>
<p>为了克服以上描述的问题，maven提供了一个材料清单（bill of materials，BOM）的概念，为了确保所有的Spring依赖（直接或者间接的）是同一个版本，你可以导入<code>spring-framework-bom</code>到你的<code>dependencyManagement</code>区中：</p>
<p><code>&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;5.0.0.M5&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></p>
<p>使用BOM增加的一个好处是，当依赖Spring框架产品时不必再指定<code>&lt;version&gt;</code>属性：</p>
<p>`<dependencies><br>    <dependency><br>        <groupid>org.springframework</groupid><br>        <artifactid>spring-context</artifactid><br>    </dependency><br>    <dependency><br>        <groupid>org.springframework</groupid><br>        <artifactid>spring-web</artifactid><br>    </dependency></dependencies></p>
<dependencies><code>#### Gradle依赖管理 ####
通过构建系统来使用Spring库，需要在</code>repositories<code>中包含恰当的URL：</code>repositories {<br>    mavenCentral()<br>    // and optionally…<br>    maven { url “<a href="http://repo.spring.io/release" target="_blank" rel="external">http://repo.spring.io/release</a>“ }<br>}<code>你可以根据需求改变</code>repositories<code>中URL的</code>/release<code>为</code>/milestone<code>，或者改变为</code>/snapshot<code>。一旦一个库已经被配置，你可以通过普通的gradle方法声明依赖，如:</code>dependencies{<br>    compile(“org.springframework:spring-context:5.0.0.M5”)<br>    testCompile(“org.springframework:spring-test:5.0.0.M5”)<br> }<code>#### Ivy 依赖管理 ####
如果你更喜欢使用Ivy管理依赖，也有相似的配置选择。配置Ivy指向Spring库（repository）,需增加如下的</code>resolver<code>到你的</code>ivysettings.xml<code>配置文件中：</code><resolvers><a href="ibiblioname=&quot;io.spring.repo.maven.release&quot;m2compatible=&quot;true&quot;root=&quot;http://repo.spring.io/release/&quot;/">ibiblioname=&quot;io.spring.repo.maven.release&quot;m2compatible=&quot;true&quot;root=&quot;http://repo.spring.io/release/&quot;/</a></resolvers><code>你也可以根据需要修改</code>root<code>URL中的</code>/release/<code>为</code>/milestone/<code>或</code>/snapshot/<code>。一旦配置完成，就可以使用通用的方式增加依赖了，例如（在ivy.xml中）：



        &lt;dependency org=&quot;org.springframework&quot; 
                    name=&quot;spring-core&quot; rev=&quot;5.0.0.M5&quot; conf=&quot;compile-&gt;runtime&quot;/&gt;

#### 发布zip文件 ####
尽管建议使用支持依赖管理的构建系统获取Spring Framework，但仍然可以下载发布的zip文件。

发布的zip文件也被提交到Spring Maven 库（这只是为了方便，你不必使用maven或者是其他的构建工具来下载他们）。

下载发布的zip文件，首先打开浏览器，输入 [http://repo.spring.io/release/org/springframework/spring]( http://repo.spring.io/release/org/springframework/spring)，并选择你想下载的版本对应的子文件夹。发布的文件以</code>-dist.zip<code>结尾，如 spring-framework-{spring-version}-RELEASE-dist.zip。发布文件也被提交到 [milestones](http://repo.spring.io/milestone/org/springframework/spring/) 和[snapshots](http://repo.spring.io/snapshot/org/springframework/spring/)。

#### 2.3.2 Logging ####
对于Spring来说logging是一个非常重要的依赖，因为：
a)它是唯一强制依赖的外部依赖
b)每个人都喜欢从他们使用的工具中输出些东西
c)Spring集成了许多其他的工具，这些工具都选择logging作为依赖。应用开发者的一个普遍目标是在一个中间位置使用一个作用于整个应用的统一logging配置，包括应用依赖的第三方组件，这也许是比较难的在有许多logging框架可供选择之前。

Spring强制依赖的logging框架是Jakarta Commons Logging API (JCL)。我们依赖JCL编译，我们也使JCL Log对象对于扩展自Spring Framework的classes是可见的。对于用户来说，重要的是所有的Spring版本都依赖于同一个logging库：因为向后兼容，所以好迁移，扩展自Spring的应用也是支持向后兼容的。为了支持向后兼容，我使Spring中的一个模块明确地依赖上</code>commons-logging<code>（JCL的标准实现），然后使所有的其他Spring模块在编译时期依赖于这个模块。举个例，如果你正在使用Maven，且不知道在哪里记录</code>commons-logging<code>的依赖，其实这个依赖来自Spring，更准确的说是来自Spring的核心模块</code>spring-core<code>。

关于</code>commons-logging<code>的一个好处是你不需要额外的库就能使你的应用正常运行，有一个运行时发掘算法，可以从classpath指定的地方寻找别的logging框架，并使用一个它认为合适的（或者你可以直接告诉这个算法你要使用哪一个）。如果没有可用的logging框架，你还可以使用JDK自带的logging框架（java.util.logging，JUL）。当你的Spring应用运行起来后，你应该会看到console窗口快速的输出大部分重要情况下的日志。
##### 不用 Common Loging #####
不幸的是，</code>commons-logging<code>中的运行时探查算法尽管方便了终端用户，但也是有问题的。回到之前，我们重新启动，Spring会使用一个不同的日志依赖。我们的首选可能是 Simple Logging Facade for Java ( 面向Java的简单日志管理，SLF4J),它也被用在人们使用的许多其他工具中，这些工具和Spring一起被使用在人们的应用中。

这有两种基础的方法来关闭</code>commons-logging<code>：
1. 从</code>spring-core<code>（因为它是唯一明确依赖</code>commons-logging<code>的模块）模块中排出</code>commons-logging<code>相关的依赖，

2. 依赖一个特殊的</code>commons-logging<code>依赖，该依赖被一个空的jar包替换（更多详情见 [SLF4J FAQ](https://www.slf4j.org/faq.html#excludingJCL)）。

为了排出</code>commons-logging<code>，增加如下内容到</code>dependencyManagement`标签中：<br><br>    <dependencies><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-core</artifactid><br>            <version>5.0.0.M5</version><br>            <exclusions><br>                <exclusion><br>                    <groupid>commons-logging</groupid><br>                    <artifactid>commons-logging</artifactid><br>                </exclusion><br>            </exclusions><br>        </dependency><br>    </dependencies>

<p>这时这个应用可能出现问题，因为在classpath中没有JCL API的实现，为了修复这个问题，需要提供一个新的实现。在下一节，我们将通过使用SLF4J作为例子，介绍怎么样提供一个可选择的JCL实现。</p>
<h5 id="使用SLF4J"><a href="#使用SLF4J" class="headerlink" title="使用SLF4J"></a>使用SLF4J</h5><p>比起<code>commons-logging</code>，SLF4J是一个更轻量的依赖，且在运行时更有效，因为它是在编译时期绑定，而别的集成日志框架是在运行时刻发现。这也就意味着你必须更加明确在运行期需要做什么，并因此声明，或者配置它。SLF4J给许多通用日志框架提供粘合剂，因此你通常可以选择一个你已经在使用的日志框架，并通过绑定到SLF4J上对它配置和管理。</p>
<p>SLF4J给许多通用日志框架提供粘合剂功能，配合JCL，它也可以做一些别致的事：把别的日志框架和它本身连接起来。因此为了在Spring中使用SLF4J，你必须用SLF4J-JCL替换<code>commons-logging</code>依赖。一旦你替换了<code>commons-logging</code>依赖，日志调用将由Spring内部转变为SLF4J API调用，所以如果在你的应用中别的库使用了<code>commons-logging</code>依赖，你都可以在一个单一地方配置和管理日志。</p>
<p>一个普遍的选择将有可能是在Spring和SLF4J中架起桥梁，在SLF4J和Log4j之间提供明确的绑定。你需要提供几种依赖（消除存在的<code>common-logging</code>依赖）：桥梁，SLF4J 实现Log4j，Log4j实现它自身，在Maven中，你可以想这样配置：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;5.0.0.M5&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
        &lt;version&gt;1.7.22&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>这看起来似乎有许多依赖，而且只是为了看到一些日志。对，就是如此，但这是可选的，而且考虑到类加载器的问题，尤其是在一个有限制的容器中，如OSGi平台，比起<code>common-logging</code>,上面的这种选择应该更好，综上，使用SLF4J-JCL有一个性能上的好处，因为它的绑定时在编译期，而不是运行期。</p>
<p>在SLF4J的用户中，一个更常见的选择是，直接绑定<a href="https://logback.qos.ch/" target="_blank" rel="external">Logback</a>,因为它使用较少的步骤和生成较少的依赖。Logback消除了额外的绑定步骤，因为它直接实现了SLF4J，因此你只需要绑定两个（<code>jcl-over-slf4j</code> 和<code>logback</code>）而不是四个库。如果你绑定的是Logback，你还需要消除来自其他依赖（不是Spring）的对slf4j-api的依赖，因为你需要确保在classpath中只依赖一个slf4j版本的API。</p>
<h5 id="Using-Log4j"><a href="#Using-Log4j" class="headerlink" title="Using Log4j"></a>Using Log4j</h5><p>Note：Log4j1.x已经不更新了，下面讲解的是Log4j2。</p>
<p>为了配置和管理的目的，许多人使用Log4j作为日志框架。Log4j是高效和稳定的，实际上它也正是我们在构建和测试Spring的运行时刻所使用的。Spring也提供了一些实用工具来配置和初始化Log4j，所以在Spring的一些模块中Log4j是一个可选择的编译时依赖。</p>
<p>为了并用Log4j和JCL，你所需要做的就是把Log4j加入classpath中，并为他提供一个配置文件（<code>log4j2.xml</code>,<code>log4j2.properties</code>,或者它支持的其他配置格式），对于Maven的使用者，最少的依赖配置是：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
        &lt;version&gt;2.7&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>如果你还希望使用SLF4J，如下的依赖是必要的：</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
    &lt;version&gt;2.7&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>这里有一个关于把日志定向到控制台的<code>log4j2.xml</code>配置例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;WARN&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;
    &lt;/Console&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Logger name=&quot;org.springframework.beans.factory&quot; level=&quot;DEBUG&quot;/&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Console&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre><h5 id="自带本地JCL的运行时容器"><a href="#自带本地JCL的运行时容器" class="headerlink" title="自带本地JCL的运行时容器"></a>自带本地JCL的运行时容器</h5><p>许多人在一个实现了JCL的的容器中运行他们的Spring应用。IBM的Websphere 应用服务器（WAS）就是一个这样的容器。这样的容器经常出现问题，不幸的是还没有一个好的解决方案；大部分情况下，只是简单的把<code>common-logging</code>从你的应用中排出是远远不够的。</p>
<p>必须清晰的认识到：问题的报告通常不是通过JCL的，甚至也不是通过<code>common-logging</code>，尽管他们把<code>common-logging</code>绑定到了其他的框架（通常是Log4j）上了。这个可能失败的原因为】是<code>common-logging</code>改变了他们上报的方式，在运行时刻发现在一些容器中使用较老的版本（1.0），然而现在许多人用的却是新的版本（1.1）。Spring不使用不通用的JCL API，因此在这里没有问题，但是一旦Spring或者你的应用尝试做一些日志操作，你可能会发现你所绑定的Log4j是不起作用的。</p>
<p>在这种情况下的 WAS ，最简单的事是反转类加载的层级（IBM称“parent last”），因此是应用控制了JCL的依赖，而不是容器。这种选择不总是可行的，但在公共领域有许多别的建议作为供选择的方法， 依赖正确的版本和容器的特性集合你的旅程可能会产生变化。</p>
<h1 id="二、核心技术"><a href="#二、核心技术" class="headerlink" title="二、核心技术"></a>二、核心技术</h1><p>这部分指导文档包含了所有的绝对完整的Spring Framework技术。</p>
<p>其中最重要的是Spring Framework的控制反转（IoC）容器。深入处理Spring Framework的IoC容器离不开Spring的面向切面编程（AOP）的技术，该技术是广泛应用的。spring Framework拥有自己的AOP框架，从概念上来说是比较简单的，在Java的企业级编程中成功的占据了AOP需求的80%的热点。</p>
<p>这部分内容也会涉及到Spring中集成的AspectJ（一种当前最完善，最成熟的企业级AOP实现的框架）</p>
<ul>
<li>第三章，IoC容器</li>
<li>第四章，资源</li>
<li>第五章，校验、数据绑定和类型转换</li>
<li>第六章，Spring表达式语言（SpEL）</li>
<li>第七章，Spring的面向切面编程</li>
<li>第八章，Spring AOP APIs</li>
</ul>
<h2 id="3-IoC容器"><a href="#3-IoC容器" class="headerlink" title="3. IoC容器"></a>3. IoC容器</h2><h3 id="3-1-Spring-IoC容器和Beans的介绍"><a href="#3-1-Spring-IoC容器和Beans的介绍" class="headerlink" title="3.1 Spring IoC容器和Beans的介绍"></a>3.1 Spring IoC容器和Beans的介绍</h3><p>本质涵盖Spring框架中控制反转规则的实现。IoC也以依赖注入而著称。依赖注入是一种对象凭借什么来定义他们的依赖的方法，依赖指的是对象能有效完成它的工作所借助的其他对象，这些依赖只有通过构造器的参数，工厂方法的参数，或是对象实体的属性来设置，这个对象实体或是被构造的，或是由工厂方法返回的。当容器创建bean的时候，它会注入bean的依赖。这种方式是反转的基础，之所以叫做控制反转（IoC）,是因为bean通过直接使用本身的类构造器，或者是像服务定位器模式的机制来控制实例，或是定位自身的依赖。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="external"><code>BeanFactory</code></a>接口提供一个高级的，能管理各种对象类型的配置机制。<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="external"><code>ApplicationContext</code></a>是一个<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="external"><code>BeanFactory</code></a>的子接口，<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="external"><code>ApplicationContext</code></a>增加了Spring AOP易集成的特性；甚至发布了消息，资源处理机制；特殊的应用层上下文，例如用于web应用中的<code>WebApplicationContext</code></p>
<p>总之，<code>BeanFactory</code>提供了配置框架和基本功能，ApplicationContext 增加了更多企业特征的功能。<code>ApplicationContext</code> 是<code>BeanFactory</code>的一个完全超级，因此在本章关于Spring IOC容器的说明中特意使用它。如果想了解更多的关于使用BeanFactory的信息， 请参考<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-beanfactory" target="_blank" rel="external">Section 3.16, “The BeanFactory”</a></p>
<p>在Spring中，各种对象构成了你的应用的主干，被Spring IOC容器管理的对象通常称为<em>beans</em>。一个bean要么是一个实例化的、组装好的对象，要么是一个被Spring IoC容器管理的对象。另外，在你的应用中，一个bean是众多对象中简单的一个。Beans和在他们中的依赖，被映射到容器使用的一个配置元数据中。</p>
<h3 id="3-2-容器概览"><a href="#3-2-容器概览" class="headerlink" title="3.2 容器概览"></a>3.2 容器概览</h3><p>接口<code>org.springframework.context.ApplicationContext</code>代表Spring IoC容器，它负责实例化、配置和组装前面提到的beans。容器通过读取配置元数据来获取关于实例化、配置和组装对象的说明。配置元数据通过XML文件、Java注解和Java代码来描述。配置元数据允许你表达组成你的应用的对象和这些对象之间的复杂关系。</p>
<p>Spring提供了几种开箱即用的<code>ApplicationContext</code>接口的实现。在一个单一的应用中，通常需要创建一个<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank" rel="external"><code>ClassPathXmlApplicationContext</code></a>或<a href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_blank" rel="external"><code>FileSystemXmlApplicationContext</code></a>。XML已经成为定义配置元数据的传统格式，你也可以通知容器使用Java注解或Java代码作为元数据的定义格式，这种方式只需要提供一个小的XML配置以说明可支持这中额外的元数据格式。</p>
<p>在许多的应用场景中，明确用户代码不必实例化一个或多个SpringIoC的容器的实例。例如，在一个web应用场景中，应用的web.xml文件中只需要简单八行web XML描述符通常就足够了。 (见 3.15.4节, “方便web应用上下文的实例化”)。如果你当前正在使用 <a href="https://spring.io/tools/sts" target="_blank" rel="external"><code>Spring Tool Suite</code></a>，一个加强版的Eclipse开发环境，这个样板配置文件只需简单地点击几次鼠标或是敲几次键盘就被创建。</p>
<p>下图是一个表示Spring怎样工作的高级视图。你的应用类与配置元数据相结合，因此，创建和初始化<code>ApplicationContext</code>之后，你就拥有了一个完全配置的、可运行的的系统或应用。</p>
<p><center><br><img src="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/images/container-magic.png.pagespeed.ce.-0JjaOG5As.png" alt="" title="Spring IoC容器"></center></p>
<p>图 3.1. Spring IoC容器<br></p>
<h4 id="3-2-1-配置元数据"><a href="#3-2-1-配置元数据" class="headerlink" title="3.2.1 配置元数据"></a>3.2.1 配置元数据</h4><p>正如之前的图所描述的一样，Spring IoC容器需要一个配置元数据。这个配置元数据描绘你作为一个应用开发者应该怎么告诉Spring容器在你的应用中去实例化、配置和组装对象。</p>
<p>传统第提供配置元数据的方式是通过一个简单的，直接明了的XML格式，这也是本章为了传达Spring IoC容器的关键概念和特征而使用得最多的方式。</p>
<p><em>注：基于XML的元数据并不是唯一的配置元数据格式。Spring IoC容器与配置元数据的实际书写格式毫无关系。并且进来，许多开发者为他们的Spring应用选择基于Java的配置</em>。</p>
<p>想要获取更多的关于在Spring容器中使用其他的元数据格式的信息，请查阅：</p>
<ul>
<li><p><a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-annotation-config" target="_blank" rel="external">基于注解的配置</a>：Spring2.5引进了注解对元数据配置的支持。</p>
</li>
<li><p><a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-java" target="_blank" rel="external">基于Java的配置</a>：从Spring3.0开始，Spring提供了许多特性来支持Java配置工程，这些特性还成为了核心Spring框架的一部分。那就是说，你可以使用Java而非XML文件来定义你的应用的类型的beans的外观。为了使用这些新特性，请查看 <code>@Configuration</code>,<code>@Bean</code>, <code>@Import</code> 和<code>@DependsOn</code> 注解.</p>
</li>
</ul>
<p>Spring配置由至少一个，但通常来说不止一个bean的定义组成，容器必须管理他们。基于XML的配置元数据以处于顶级元素<code>&lt;beans&gt;</code>中的<code>&lt;bean/&gt;</code>元素来表示这些bean的配置。Java配置通常使用@Bean注解@Configuration类中的方法。</p>
<p>这些bean定义符合组成应用的实际的对象。通常来说，你需定义服务层对象，数据访问层对象（DAOs）对象,诸如Struts <code>Action</code>实例这样的表示对象，和诸如Hibernate <code>SessionFactories</code>，JMS队列之类的底层对象。一般来说，在容器中，不必配置细粒度的领域对象，因为创建和加载领域对象通常是DAOs和业务逻辑的责任。然而，你可以使用Spring中集成的AspectJ来配置那些脱离IoC容器控制而创建的对象。查看<a href="ocs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#aop-atconfigurable">使用AspectJ和Spring一起依赖注入领域对象</a></p>
<p>如下展示了基于XML的配置元数据的基本结构：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;
</code></pre><p><code>id</code>属性是一个字符串，用来鉴别bean定义的唯一性；<code>class</code>属性定义了bean的类型，且使用的是全限定类名。id属性的值涉及到对象协作。在这个例子中，XML没有展现协作对象之间的引用；获取更多信息，请查看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-dependencies" target="_blank" rel="external">依赖</a></p>
<h4 id="3-2-2-实例化一个容器"><a href="#3-2-2-实例化一个容器" class="headerlink" title="3.2.2 实例化一个容器"></a>3.2.2 实例化一个容器</h4><p>实例化一个Spring IoC容器很简单，提供给ApplicationContext的构造器的位置路径（可以多个）就是实际的资源位置字符串，他们允许容器从一系列的外部资源，如本地文件系统，从Java <code>classpath</code>等加载配置元数据。</p>
<pre><code>ApplicationContext context =
    new ClassPathXmlApplicationContext(new String[] {&quot;services.xml&quot;, &quot;daos.xml&quot;});
</code></pre><p>注：在你了解了Spring IoC容器后，你也许想知道更多的关于Spring的<code>Resource</code>抽象，正如在第四章，资源中描述的一样，资源提供了方便的机制读取来自URI语法定义的位置的输入。尤其Resource路径被用来构建应用 上下文，正如<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources-app-ctx" target="_blank" rel="external">4.7节 应用上下文和资源路径</a>所描述的。</p>
<p>如下展示了服务层对象配置文件<code>（services.xml）</code>:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- services --&gt;

    &lt;bean id=&quot;petStore&quot; class=&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;
        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
        &lt;property name=&quot;itemDao&quot; ref=&quot;itemDao&quot;/&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for services go here --&gt;

&lt;/beans&gt;
</code></pre><p>如下展示了数据访问对象配置文件<code>（daos.xml）</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;accountDao&quot;
        class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;itemDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for data access objects go here --&gt;

&lt;/beans&gt;
</code></pre><p>之前的例子中，服务层由<code>PetStoreServiceImpl</code>类与<code>JpaAccountDao</code> 和<code>JpaItemDao</code>（基于JPA对象/关系映射标准）两个数据访问对象类型组成，<code>property name</code>元素引用Javabean的属性名字，<code>ref</code>元素引用另一个bean定义的名称。id和ref之间的链接了表达了协作对象之间的依赖。想了解一个对象的依赖的详细配置方式，查看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-dependencies" target="_blank" rel="external">依赖</a>。</p>
<h5 id="基于XML的配置元数据的组成"><a href="#基于XML的配置元数据的组成" class="headerlink" title="基于XML的配置元数据的组成"></a>基于XML的配置元数据的组成</h5><p>把bean的定义放到多个XML文件中是有用的。在你的架构中，常常每个独立的XML配置文件代表一个逻辑层或模块。</p>
<p>你可以使用应用上下文构造器来从所有这些XML片段中加载bean的定义。这个构造器提取多<code>Resource</code>位置，如前一节所示。作为一种选择，使用一个或多个<code>&lt;import/&gt;</code>元素来从别的文件加载bean定义，如：</p>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;services.xml&quot;/&gt;
    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;

    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;
    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>在前面的例子中，外部的bean定义加载自三个文件：<code>services.xml</code>, <code>messageSource.xml</code>, 和<code>themeSource.xml</code>。所有的位置路径与导入的定义文件相关，因此<code>services.xml</code>必须在完全一样的目录，或classpath位置中，正如文件中的导入活动。因此，<code>messageSource.xml</code> 和 <code>themeSource.xml</code>必须在一个<code>Resource</code>位置中，这个位置在导入文件的位置下。    如你所见，一个引导斜线被忽视了，但是如果加上了斜线，这些路径就是相对的，不使用斜线是更好的格式。一旦文件的内容被导入，包括最上层的<code>&lt;beans/&gt;</code>元素，都必须根据Spring的模式校验XMLbean的定义。</p>
<p>注：<em>使用相对路径（../）引用在父目录中的文件是可以的，但是不建议这样做。如果这样做了，就会创建一个不再当前应用中的文件的依赖。尤其，这个不建议用于“classpath：”URLs (例如, “classpath:../services.xml”),运行时的解决方法是选择“最近”的classpath的根目录，之后在它的父目录中搜寻。Classpath配置的改变会导致选择一个不同的错误的目录。</em></p>
<p><em>你可以总是资源的全限定位置而不是相对路径：如，”file:C:/config/services.xml” 或”classpath:/config/services.xml”。然而，你应该意识到你正在使你的应用的配置与特殊的绝对位置相耦合了。</em></p>
<p>import指令是beans命名空间本身提供的一个特征。超出了普通的bean定义的，更深层次的配置特征在一个选择的spring提供的XML命名空间中是可用的，如，“context”和“util”命名空间。</p>
<h5 id="Groovy的bean定义——DSL（领域专用语言）"><a href="#Groovy的bean定义——DSL（领域专用语言）" class="headerlink" title="Groovy的bean定义——DSL（领域专用语言）"></a>Groovy的bean定义——DSL（领域专用语言）</h5><p>作为一个具体的配置元数据的高级例子，bean定义也可以通过spring的Groovy的bean定义——DSL来表示，这可以通过Grails框架来了解。通常来说，这样的配置是配置在一个.groovy文件中的，其结构如下：</p>
<p>beans{<br>    dataSource(BasicDataSource) {<br>   driverClassName = “org.hsqldb.jdbcDriver”<br>url = “jdbc:hsqldb:mem:grailsDB”<br>username = “sa”<br>password = “”<br>settings = [mynew:”setting”]<br>}<br>sessionFactory(SessionFactory) {<br>dataSource = dataSource<br>}<br>myService(MyService) {<br>nestedBean = { AnotherBean bean -&gt;<br>dataSource = dataSource<br>}<br>}<br>}</p>
<p>这中配置的格式大部分等价于XMLbean定义，甚至支持spring的XML配置命名空间。通过一个“importBeans”指令，这种配置也允许导入XML bean定义文件。</p>
<h4 id="3-2-3-使用容器"><a href="#3-2-3-使用容器" class="headerlink" title="3.2.3 使用容器"></a>3.2.3 使用容器</h4><p><code>ApplicationContext</code>是一个高级工厂接口，并且有能力维护不同的beans的注册和他们的依赖。使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，可以检索你的bean的实体。</p>
<p><code>ApplicationContext</code>使你能够读取bean定义并使用他们，如下所示：</p>
<pre><code>// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);

// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();
</code></pre><p>使用Groovy的配置，引导程序看起来与上面非常相似，只是一个不同的上下文实现类，体现出Groovy（但也了解XML bean的定义）</p>
<pre><code>ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
</code></pre><p>结合阅读器代理，<code>GenericApplicationContext</code>成为最灵活多变的变体，例如与读取XML文件的<code>XmlBeanDefinitionReader</code>相结合：</p>
<pre><code>GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(ctx).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);
   context.refresh();
</code></pre><p>与读取Groovy文件的<code>GroovyBeanDefinitionReader</code>相结合：</p>
<pre><code>GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(ctx).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
   context.refresh();
</code></pre><p>如果需要，这些阅读器代理可以在同一个<code>ApplicationContext</code>上混合和配合使用，从不同的配置源读取bean定义。</p>
<p>之后你可以使用getBean检索bean的实体。<code>ApplicationContext</code>接口还有几个别的方法可以检索beans，理想的应用编码不应该使用它们。的确，你的应用编码不应该调用<code>getBean()</code>方法，从而你的应用一点都不依赖Spring APIs。例如，Spring与web框架的集成为了不同的web框架组件提供依赖注入，这些组件如controller和JSF管理beans,允许你声明通过元数据在特殊的bean上声明依赖（如，autowiring 注解）</p>
<h3 id="Bean概览"><a href="#Bean概览" class="headerlink" title="Bean概览"></a>Bean概览</h3><p>一个Spring IoC容器管理一个或多个beans。这些beans是通过提供给容器的配置元数据来创建的，如在XML<code>&lt;beans/&gt;</code>标签中定义的格式。</p>
<p>在容器中，这些bean定义被描述为<code>BeanDefinition</code>对象，这些对象包含（以及其他信息）如下的元数据</p>
<ul>
<li>一个包全限定类名：典型地实际实现类型</li>
<li>bean行为的配置元素，声明了bean在容器中应该有的行为（范围，声明周期回调等等）。</li>
<li>引用那些对当前bean工作来说是必要的bean，这些引用通常叫合作者或是依赖者。</li>
<li>别的设置在新创建的对象中的配置，如，使用在一个bean中的连接次数，可以用来管理连接池，或是限制一个连接池的大小。</li>
</ul>
<p>这些元数据翻译为一系列组成每个bean定义的属性。</p>
<p>表3.1. bean定义</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Explained in</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>Section 3.3.2, “Instantiating beans”</td>
</tr>
<tr>
<td>name</td>
<td>Section 3.3.1, “Naming beans”</td>
</tr>
<tr>
<td>scope</td>
<td>Section 3.5, “Bean scopes”</td>
</tr>
<tr>
<td>constructor arguments</td>
<td>Section 3.4.1, “Dependency Injection”</td>
</tr>
<tr>
<td>properties</td>
<td>Section 3.4.1, “Dependency Injection”</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>Section 3.4.5, “Autowiring collaborators”</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>Section 3.4.4, “Lazy-initialized beans”</td>
</tr>
<tr>
<td>initialization method</td>
<td>the section called “Initialization callbacks”</td>
</tr>
<tr>
<td>destruction method</td>
<td>the section called “Destruction callbacks”</td>
</tr>
</tbody>
</table>
<p><code>ApplicationContext</code> 的实现，除了bean定义外还包含关于如何创建一个特殊的bean的信息，也允许注册已存在的，用户在容器外面创建的对象。由返回工厂实现<code>DefaultListableBeanFactory</code>的<code>getBeanFactory()</code>方法访问ApplicationContext的Bean工厂来完成这个功能。凭借方法registerSingleton(..) 和 registerBeanDefinition(..)，<code>DefaultListableBeanFactory</code>支持注册。然而，有经过元数据定义的beans定义，典型的应用能独立工作。</p>
<p><em>注：Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding of existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to factory) is not officially supported and may lead to concurrent access exceptions and/or inconsistent state in the bean container</em>.</p>
<h4 id="命名-beans"><a href="#命名-beans" class="headerlink" title="命名 beans"></a>命名 beans</h4><p>每个bean都有一个或多个标识符。在持有bean的容器中，这些标识符必须是独一无二的。一个bean通常只有一个标识符，但如果需要多个标识符，额外的可以看做别名。</p>
<p>在基于XML的配置元数据中，使用<code>id</code>和/或<code>name</code>属性来指定bean标识符。<code>id</code>属性允许精确指定一个ID。按照惯例，这些名称是字母和数字的组合（’myBean’,’fooService’等），但也可以含有特殊字符。如果你想采用bean的别名，你可以在<code>name</code>属性中指定他们，并通过逗号（,），分号（；）或空格分隔。按历史的标记，在版本Spring3.1前，<code>id</code>属性被定义为<code>xsd:ID</code> 类型，它约束合理的字符。从3.1开始，<code>id</code>属性被定义为<code>xsd:string</code>类型。注意，尽管不再通过XML解析，但容器依然强制bean id独一无二的特性。</p>
<p>不要求你给bean提供一个名称或ID。如果没有明确的提供名称或ID，容器会给bean生成一个独一无二的名称。然而，如果你想通过名称引用bean，或通过使用<code>ref</code>元素或者<a href="">服务定位器</a>来查看bean,都必须提供一个名称。不给bean提供名称的动机是与使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-inner-beans" target="_blank" rel="external">内部bean</a>s和<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-autowire" target="_blank" rel="external">自动包装者</a></p>
<blockquote>
<p><strong>bean命名约定</strong></p>
<p>当命名beans时，约定就是使用标准的Java实例化域名称的约定，也就是bean名称以一个小写字符开始，之后按驼峰形式。这样的名称如<code>&#39;accountManager&#39;</code>, <code>&#39;accountService&#39;</code>, <code>&#39;userDao&#39;</code>, <code>&#39;loginController&#39;</code>等等。</p>
<p>命名beans时，一贯主张配置容易阅读和理解，如果你使用Spring AOP，这命名约定是很有帮助的，当通过名字应用通知到一系列的相关beans上时。</p>
</blockquote>
<p>注：通过组件扫描classpath，Spring会按如下规则为没有命名的组件生成bean名称：基本上是，获取简单的class名称，把第一个字母变为小写。然而在特殊的情况下，有超过一个字符且第一个和第二个字符都是大写，原始的方式就不起作用了。    这些规则与<code>java.beans.Introspector.decapitalize</code>（Spring在这里用到的）定义的规则是相同的。</p>
<h5 id="Aliasing-a-bean-outside-the-bean-definition"><a href="#Aliasing-a-bean-outside-the-bean-definition" class="headerlink" title="Aliasing a bean outside the bean definition"></a>Aliasing a bean outside the bean definition</h5><p>在bean的自定义中，可以提供多个名称给bean，通过使用一个组合决定一个名称，该名称由<code>id</code>属性和在<code>name</code>属性中任何数量的名称指定。这些名称可以等价于同一个bean的别名，且在许多情况下是有用的，比如，通过使用一个特殊的bean名称，允许在同一个应用中的每个组件引用一个共同的依赖。</p>
<p>然而，在bean被实际定义的地方指定所有的别名并不总是适合的，。有时为一个在其他地方定义的bean启用一个别名是值得的。这种情况在大型系统是常见的，这种系统中配置被分配到每个子系统，每个子系统都有它自己的一系列对象定义。在基于XML的配置元数据中，可以使用<alias>元素来完成别名的定义：</alias></p>
<pre><code>&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;
</code></pre><p>在这种情况下，在同一个容器，一个bean被命名为<code>fromName</code>，也许，在使用完这个别名定义后，又被<code>toName</code>引用。</p>
<p>例如，子系统A的配置元数据引用名称为<code>subsystemA-dataSource</code>的DataSource。子系统B的配置元数据引用名称为<code>subsystemB-dataSource</code>的DataSource。当使用这两个子系统来组合成一个主应用，且这个主应用引用名称为<code>myApp-dataSource</code>的DataSource。为了使这三个名称引用相同的对象，需要添加如下的别名定义到MyApp配置元数据：</p>
<pre><code>&lt;alias name=&quot;subsystemA-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;
&lt;alias name=&quot;subsystemA-dataSource&quot; alias=&quot;myApp-dataSource&quot; /&gt;
</code></pre><p>现在，每个组件和主应用都可以通过一个独立的（有效的创建一个命名空间），并且保证不与其他定义冲突的名称来引用dataSource，而且引用的是相同的bean。</p>
<blockquote>
<p><strong>Java 配置</strong></p>
<p>如果使用Java配置，@Bean注解可以用来提供别名，详情见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-java-bean-annotation" target="_blank" rel="external"> 3.12.3, “使用 @Bean 注解”</a>。</p>
</blockquote>
<h4 id="3-3-2-实例化bean"><a href="#3-3-2-实例化bean" class="headerlink" title="3.3.2 实例化bean"></a>3.3.2 实例化bean</h4><p>一个bean的定义本质上来说是一个创建一个或多个对象的食谱。当接收到请求，容器会查询食谱找到一个命名的bean，并使用被bean定义封装的配置元数据来创建一个实际的对象。</p>
<p>如果你使用的是基于XML的配置元数据，指定实例化在<code>&lt;bean/&gt;</code>元素中的<code>class</code>属性中的对象类型。这个class属性，内部是一个在<code>BeanDefinition</code> 实体上的Class属性，通常是强制的。（例子见，“<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method" target="_blank" rel="external">使用一个实例工厂方法实例化</a>”这节和 3.7 “<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-child-bean-definitions" target="_blank" rel="external">Bean定义的继承</a>”）。有一种或两种方法使用<code>Class</code>属性。</p>
<ul>
<li>典型地是为了指定构造bean的类，容器直接通过调用构造函数创建bean的情况，有点像使用Java代码的<code>new</code>操作。</li>
<li>为了指定包含用来创建对象的静态工厂方法的实际类类型，容器回调一个在类中的静态工厂方法来创建对象并不是常见的情况。</li>
</ul>
<blockquote>
<p><strong>内部类名称</strong>。如果你想为一个<code>static</code>的内部类（nested class）配置一个bean定义,你必须使用这个内部类的二元名称。</p>
<p>例如，如果你在<code>com.example</code>包中有一个名叫Foo的类,且在Foo中有一个<code>static</code>内部类叫Bar，那么一个bean定义中的<code>class</code>属性的值会是：</p>
<pre><code>com.example.Foo$Bar
</code></pre><p>注意在类名称中使用<code>$</code>字符来分隔内部类名称和外部类名称。</p>
</blockquote>
<h5 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h5><p>当通过构造方法来创建一个bean时，对所有正常的类都是可以的，并且与Sprin是兼容的。也就是说，开发的类（class）不必实现任何特殊的接口，或者以特殊的方式编码。简单地指定bean类就足够了。但是，根据你用什么类型的IoC来定义特殊bean，你也许需要一个默认的构造函数。</p>
<p>Spring IoC容器实质上能管理任何你想管理的类型；不限制管理真实的JavaBean。在容器中，大部分的Spring使用者更喜欢只有一个默认构造函数的和在内容之后有恰当的setter和getter模式的真实JavaBean。在容器中，你可能有更特殊的非bean风格的类。例如，如果你需要使用一个遗留下来的连接池，它绝对不遵循JavaBean规范，Spring也可以管理它。</p>
<p>通过基于XML的配置元数据，你可以照着下面指定你的bean:</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;

&lt;bean name=&quot;anotherExample&quot; class=&quot;examples.ExampleBeanTwo&quot;/&gt;
</code></pre><p>关于提供参数给构造函数和在对象被创建之后设置对象实体的内容的原理的详细信息，见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-collaborators" target="_blank" rel="external">注入依赖</a></p>
<h5 id="静态工厂方法实例化"><a href="#静态工厂方法实例化" class="headerlink" title="静态工厂方法实例化"></a>静态工厂方法实例化</h5><p>当定义一个用静态工厂方法来创建的bean时，使用<code>class</code>属性来指定包含<code>static</code>工厂方法的的类，使用<code>factory-method</code>属性来指定工厂方法本身的名称。你应该可以调用这个方法，返回一个存活的对象，随后被认为是否已经通过构造函数被创建。这样的bean定义的一个用法是在遗留代码中调用静态工厂。</p>
<p>如下的bean定义表明bean将通过调用一个工厂方法来创建。这个定义没有指定返回对象的类型（class）,只指定了含有工厂的类。在这个例子中，<code>createInstance()</code>方法必定是一个静态方法。</p>
<pre><code>&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
</code></pre><p>关于提供参数给工厂方法和对象在工厂返回后设置对象实体内容的原理的详细信息，见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-properties-detailed" target="_blank" rel="external">依赖和配置详情</a></p>
<h5 id="使用一个实例工厂方法实例化"><a href="#使用一个实例工厂方法实例化" class="headerlink" title="使用一个实例工厂方法实例化"></a>使用一个实例工厂方法实例化</h5><p>与静态工厂方法实例化类似，通过一个实例工厂方法实例化，会回调一个已经存在容器中的bean的非静态的方法来创建一个新的bean。    为了使用该原理，保留<code>class</code>属性为空，并在<code>factory-bean</code>属性中，为在当前（或父/祖先）容器中的bean指定名称，该bean包含用来创建对象的实例方法。通过<code>factory-method</code>属性为工厂方法本身设置名称。</p>
<pre><code>&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre><p>.</p>
<pre><code>public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();
    private DefaultServiceLocator() {}

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
</code></pre><p>如下，一个工厂类可以拥有多余一个的工厂方法：</p>
<pre><code>&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

&lt;bean id=&quot;accountService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createAccountServiceInstance&quot;/&gt;
</code></pre><p>.</p>
<pre><code>public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();
    private static AccountService accountService = new AccountServiceImpl();

    private DefaultServiceLocator() {}

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }

}
</code></pre><p>这种方式表明工厂bean(factory bean )本身可以通过依赖注入（DI）来管理和配置，见见<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-properties-detailed" target="_blank" rel="external">依赖和配置详情</a></p>
<p>注意：在Spring文档中，工厂bean(factory bean)指的是这样一种bean，就是被配置在Spring容器中，可以通过<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method" target="_blank" rel="external">实例</a>或<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-class-static-factory-method" target="_blank" rel="external">静态</a>工厂方法来创建对象的bean。通过对比，<code>FactoryBean</code>（注意大写）是指一个特殊的Spring <a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-extension-factorybean" target="_blank" rel="external"><code>FactoryBean</code></a></p>
<h3 id="3-4-依赖"><a href="#3-4-依赖" class="headerlink" title="3.4 依赖"></a>3.4 依赖</h3><p>一个典型的企业应用不是由单个对象（Spring称为bean）组成。甚至最简单的应用都有几个对象协同工作，呈现给终端用户所见的是一个紧凑的应用。下一节说明你怎么从定义若干的独一无二的bean定义迈向一个完全实际的应用，该应用中对象之间为了完成一个目标而协作。</p>
<h4 id="3-4-1-依赖注入"><a href="#3-4-1-依赖注入" class="headerlink" title="3.4.1 依赖注入"></a>3.4.1 依赖注入</h4><p><em>依赖注入</em>（DI）是一个方法，该方法通过对象定义他们的依赖，也就是与他们一起运作的别的对象，只有通过构造参数，工厂方法参数，或者是在它被构造或者从一个工厂方法返回后设置在对象实体上的内容。当容器创建bean的时候会注入那些依赖。这种方法是基础的反转，因此称<em>控制反转</em>（IoC），通过使用直接的类构造方法或者服务定位模式，bean自己控制实例化或者它自己的依赖的位置。</p>
<p>使用DI原理，代码更清晰，当通过对象的依赖提供对象，能更有效的解耦。对象不查询它自己的依赖，也不知道依赖的位置或类。照此，你的类变得更容易测试，尤其是当依赖是接口或抽象的基类时，它们允许打桩或模仿实现被用到单元测试中。</p>
<p>DI存在两大变体，基于构造器的依赖注入和基于Setter的依赖注入。</p>
<h5 id="基于构造器的注入"><a href="#基于构造器的注入" class="headerlink" title="基于构造器的注入"></a>基于构造器的注入</h5><p>容器回调一个有若干参数的构造器，其中的每个参数代表一个依赖，完成基于构造器的依赖注入，。与调用一个有特殊参数的<code>static</code>工厂方法来构造bean是几乎等价的，本文论点是处理构造器的参数和类似地处理<code>static</code>工厂方法的参数。下面的例子展示的是一个只能通过构造器注入的依赖注入的的类。注意这个类没有任何特殊性，它只是一个POJO，没有依赖容器的特殊接口，基类和注解。     </p>
<pre><code>public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...

}
</code></pre><h5 id="构造参数解析"><a href="#构造参数解析" class="headerlink" title="构造参数解析"></a>构造参数解析</h5><p>使用参数类型来解决构造参数匹配的问题。如果没有潜在的不确定性存在bean定义的构造器参数中，构造器参数的顺序被定义在一个bean定义中，当bean被实例化时，正是那些参数的顺序被提供给恰当的构造器。请仔细想想下面的类：</p>
<pre><code>package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }

}
</code></pre><p>假设<code>Bar</code>和<code>Baz</code>类与继承不相关，那么就没有潜在的不确定性存在。如此，下面的配置就工作正常，你也不必在<code>&lt;constructor-arg/&gt;</code>元素中明确地指定构造参数索引和/或类型。</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;constructor-arg ref=&quot;bar&quot;/&gt;
        &lt;constructor-arg ref=&quot;baz&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot;/&gt;

    &lt;bean id=&quot;baz&quot; class=&quot;x.y.Baz&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>当另一个bean被引用，且类型是已知的，那么匹配就可能发生（正如前面的例子）。当一个简单的类型被使用，如<code>&lt;value&gt;true&lt;/value&gt;</code>，Spring不能决定这个值的类型，因此在没有帮助的情况下不能匹配，请仔细想想下面的类：</p>
<pre><code>package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }

}
</code></pre><p>在前面的场景中，如果使用<code>type</code>属性明确指定构造器参数的类型的话，容器就可以使用类型来匹配简单的类型，如：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>使用<code>index</code>属性来精确指定构造器参数的索引，如：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>除了解决多个简单值的不确定性外，指定索引还可以解决一个构造器有两个相同类型的参数的不确定性。注意索引值是从0起步的。</p>
<p>你也可以使用构造器参数名消除值的歧异：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>记住，为使这种配置在你的代码之外起作用，必须在调试标记可用可用的情况下编译，那样的话，Spring可以从构造器中浏览参数的名称。如果不能再调试标记下编译你的代码（或者是不想），你可以使用JDK注解 <a href="http://docs.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" target="_blank" rel="external">@ConstructorProperties</a>明确你的构造器参数的名称。样例类必须看起来如下：</p>
<pre><code>package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({&quot;years&quot;, &quot;ultimateAnswer&quot;})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }

}
</code></pre><h5 id="基于setter的依赖注入"><a href="#基于setter的依赖注入" class="headerlink" title="基于setter的依赖注入"></a>基于setter的依赖注入</h5><p>容器回调一个无参的构造器或无参的static工厂方法来构造你的bean后，接着调用bean上的setter方法完成依赖注入。</p>
<p>如下例子展示一个使用纯setter注入来进行依赖注入的类，这个类是符合Java的习惯的，它只是一个POJO，没有依赖容器的特殊接口，基类和注解。</p>
<pre><code>public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...

}
</code></pre><p><code>ApplicationContext</code> 支持基于构造器和基于setter的DI注入它所管理的bean。在一些依赖已经通过构造器方法注入胡，容器也还支持基于setter的依赖注入。你以一个<code>BeanDefinition</code>的格式配置依赖，你把<code>BeanDefinition</code>与<code>PropertyEditor</code>的实例结合用来转换属性的格式到另一种格式，然而，大部分的Spring使用者不直接使用这些类（i.e.,以编程的方式），而是使用XML的bean定义，注解组件（以<code>@Component</code>, <code>@Controller</code>等注解类），或者是基于Java的<code>@Configuration</code>的类中的<code>@Bean</code> 方法。在内部，这些类被转化为<code>BeanDefinition</code>实例，并被用来加载一个完整的Spring IoC容器实例。</p>
<blockquote>
<p><strong>是基于构造器函数，还是基于setter依赖注入？</strong></p>
<p>因为你可以混用基于构造函数和及与setter的依赖注入，为强制的依赖使用构造函数，为可选的依赖使用setter方法或配置方式，是一个好的经验法则。注意，在一个setter方法上使用@Required注解，可以用来使使属性成为必须的依赖。</p>
<p>Spring团队通常提倡构造函数注入，因为这种方式能使一个不可变对象来实现应用程序组件，并确保必须的依赖不为<code>null</code>。更重要的是构造函数注入的组件总是以一个完全初始化的状态返回给客户端代码。附注一点，大量的构造函数参数是一种不好的代码风格，这意味着这个类可能有许多的职责，这样的代码需要重构以更好的解决本身独立的关注点。</p>
<p>根本上来讲，setter注入只能被用来注入，可选的依赖，在类的内部可以给这种依赖分配合适的默认值。否则，在代码使用依赖的每个地方都必须进行非空检查。setter注入的一个好处是setter方法使得类依赖的对象能重新配置或者重新注入。因此通过JMX MBeans管理，是一个使用setter注入的很好的使用案例。</p>
<p>使用DI的风格最适合一个特定的类。有时，当处理没有源码的第三方类时，你就可以选择依赖注入。例如，如果一个第三方类没有暴露任何setter方法，那么构造函数注入也许是唯一的可获得DI形式。</p>
</blockquote>
<h5 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h5><p>容器按如下步骤完成bean依赖的解析：</p>
<ul>
<li>通过描述所有bean的配置元数据来创建和初始化<code>ApplicationContext</code>。配置元数据可以由XML、Java代码和注解指定。</li>
<li>对于每个bean，以属性、构造参数，或者一个静态工厂方法的参数的形式来表示它们的依赖，如果你使用的不是一个正常的构造函数而是静态工厂方法。当bean被创建时，这些依赖被提供给bean。</li>
<li>每一个属性或者构造函数参数都是要设置的值，或是容器中的另一个bean的引用的实际定义。</li>
<li>每个属性或者构造函数的参数是一个值，被从指定格式转变为属性或构造函数参数的实际类型。默认情况下，Spring可以把字符串格式的值转化为一个内置的类型，如int,long,String,boolean等等。</li>
</ul>
<p>当Spring容器被创建时，会校验每个bean的配置。然而，bean属性的值不会被设置，除非bean被实际创建。Beans是单例，被设置为在容器创建时创建的实例——预置实例（默认）。相关知识点被定义在<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="external">3.5 “Bean知识点”</a>。不然的话，bean只有在被请求时才被创建了。创建一个bean会潜在地创建一个beans的图表，作为bean的依赖，并创建和分配它的依赖的依赖（以此类推）。注意，在第一次创建bean时，解析依赖中的不匹配将会在下面介绍。</p>
<blockquote>
<p>循环依赖</p>
<p>如果你主要使用构造函数注入，导致一个难以解决的循环依赖情形是可能的。</p>
<p>如，类A需要一个通过构造函数注入的类B的实例，类B需要一个通过构造函数注入的类A的实例。如果你为类A和类B配置beans,且相互注入，Spring IoC容器在运行时发现这个循环引用，就会抛出一个<code>BeanCurrentlyInCreationException</code>异常。</p>
<p>一个解决的办法是编辑一些类的源码，这些类通过sette函数r而不是构造函数配置。另外一种办法是，避免构造函数注入而只用setter注入。换句话，虽然不建议setter注入，但你可以使用它来配置循环依赖。</p>
<p>与标准的情况（没有循环依赖）不同，bean A和bean B之间的循环依赖强制其中的一个bean以完全初始化本身的方式注入另一个bean（一个典型的蛋鸡问题）</p>
</blockquote>
<p>通常来说，你可以相信Spring会做正确的事。在容器加载的时候，它会检查配置问题，如引用一个不存在的bean和循环依赖。Spring尽可能晚地设置属性和解决依赖，直到bean被实际创建。这也就意味着Spring容器正确地加载后可能生成一个异常，当你请求一个对象，在创建这个对象或它的依赖时出现了一个问题。如，当找不结果或属性非法时bean会抛出一个异常。这可能会推迟一些配置问题的可见性，这也是为什么<code>ApplicationContext</code>实现默认的预实例化单例bean的原因。在实际需要这些bean之前，花费一些预付的时间和空间来创建他们，你会在创建<code>ApplicationContext</code>的时候发现配置问题，而不是在这之后。你可以推翻这些默认行为以使单例bean被懒初始化，而不被预实例化。</p>
<p>当一个或多个协作的bean被注入到一个依赖的bean中，如果不存在循环依赖，每个协同工作的bean完全地优先配置以便注入依赖bean中。这也就意味着，如果bean A有一个在 bean B上的依赖，Spring IoC容器彻底地优先配置bean B 通过调用bean A上的setter方法。换句话，bean被实例化（如果没有单独预实例化），它的依赖被设置，生命周期相关的方法被调用（如<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-initializingbean" target="_blank" rel="external">配置初始化方法</a>或 <a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-initializingbean" target="_blank" rel="external">InitializingBean回调方法</a>）。</p>
<h5 id="依赖注入例子"><a href="#依赖注入例子" class="headerlink" title="依赖注入例子"></a>依赖注入例子</h5><p>下面的例子使用基于XML配置元数据的setter DI。Spring 以XML配置文件的以小部分列举了一些bean定义：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- setter injection using the nested ref element --&gt;
    &lt;property name=&quot;beanOne&quot;&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/property&gt;

    &lt;!-- setter injection using the neater ref attribute --&gt;
    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }

}
</code></pre><p>在前面的例子中，setter方法声明匹配在XML文件中指定的属性，下面的例子使用构造函数 DI：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- constructor injection using the nested ref element --&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/constructor-arg&gt;

    &lt;!-- constructor injection using the neater ref attribute --&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;

    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;  

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }

}
</code></pre><p>构造函数参数在bean定义中指定，将被用作<code>ExampleBean</code>的构造函数的参数。</p>
<p>现在思考下这个例子的一个变体，要求Spring通过调用一个static工厂方法来返回该对象的一个实例，而不是使用构造方法来创建该对象的一个实例。</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; factory-method=&quot;createInstance&quot;&gt;
    &lt;constructor-arg ref=&quot;anotherExampleBean&quot;/&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;constructor-arg value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre><p>-</p>
<pre><code>public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }

}
</code></pre><p><code>static</code>工厂方法的参数由<code>&lt;constructor-arg/&gt;</code> 元素提供，与实际使用构造函数一模一样。虽然在本例子中是相同，但是工厂方法返回的类的类型不必与包含该static工厂方法的类的类型相同。可以以本质上相同的方式（除了使用<code>factory-bean</code>属性替代<code>class</code>属性）使用一个工厂方法（非静态的），这里不做详细讨论。</p>
<h4 id="3-4-2-依赖和详细配置"><a href="#3-4-2-依赖和详细配置" class="headerlink" title="3.4.2 依赖和详细配置"></a>3.4.2 依赖和详细配置</h4><p>正如前面章节提及的，您可以定义bean属性和构造函数参数作为对其他托管bean（协作者）的引用，或作为值的内部定义。Spring的基于XML的配置元数据支持子元素类型，其中的<code>&lt;property/&gt;</code>和 <code>&lt;constructor-arg/&gt;</code>元素就是为了该目的。</p>
<h5 id="连续值（原语，字符串等等）"><a href="#连续值（原语，字符串等等）" class="headerlink" title="连续值（原语，字符串等等）"></a>连续值（原语，字符串等等）</h5><p><code>&lt;property/&gt;</code>元素的<code>value</code>属性指明了一个属性或者构造函数参数，并用人类能识别的字符串来表示。Spring的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#core-convert-ConversionService-API" target="_blank" rel="external">文件扫描服务</a>用来把这些值从<code>字符串</code>转换为实际的属性或参数类型。</p>
<pre><code>&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName(String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>为了更加简洁的XML配置，下面的例子使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-p-namespace" target="_blank" rel="external"> p-namespace</a></p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;
        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;
        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;
        p:username=&quot;root&quot;
        p:password=&quot;masterkaoli&quot;/&gt;

&lt;/beans&gt;
</code></pre><p>上面这个XML配置更加简洁，然而，打字错误只能在运行时期而不是设计时期被发现，除非你使用的是一个IDE，如 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>或 <a href="https://spring.io/tools/sts" target="_blank" rel="external">Spring Tool Suite</a>（STS），当你创建bean定义时，它们都支持自动补全属性。强烈建议这样的ID帮助。</p>
<p>你也可以配置一个<code>java.util.Properties</code>实例，如下：</p>
<pre><code>&lt;bean id=&quot;mappings&quot;
    class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>Spring容器通过使用JavaBeans <code>PropertyEditor</code>原理来把<code>&lt;value/&gt;</code>元素之间的文本转化为一个<code>java.util.Properties</code>实例。这是一个很好的精简，也是Spring团队倾向于使用内嵌<code>&lt;value/&gt;</code>元素替换value属性样式的几个为数不多的地方之一（This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <value> element over the value attribute style.）。</value></p>
<h5 id="idref-元素"><a href="#idref-元素" class="headerlink" title="idref 元素"></a>idref 元素</h5><p><code>idref</code> 元素值是一个error-proof方式，该方式是用来把容器中的另一个bean的<code>id</code>(字符串值-不是一个引用)传递到<code>&lt;constructor-arg/&gt;</code> 或 <code>&lt;property/&gt;</code>元素中。</p>
<pre><code>&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;

&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot;&gt;
        &lt;idref bean=&quot;theTargetBean&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>上面的bean定义片段完全等价于下面的定义片段：</p>
<pre><code>&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;

&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>比起第二中，第一种形式更可取，因为使用<code>idref</code>元素允许容器在部署的时候校验引用和该名称的bean的真实存在。第二种变体，在值上没有校验行为，这些值被传递给<code>client</code> bean的<code>targetName</code>属性。只有当<code>client</code> bean真正被实例化的时候，其中的错别字才会被发现。如果<code>client</code> bean是一个<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="external">原型</a>（prototype）bean。那么这些拼写错误和异常结果只能被发现得更晚，直到容器被部署时。</p>
<p>在4.0 beans xsd中，不再支持<code>idref</code>上的<code>local</code>属性，因为它不再提供任何超过常规bean引用的值。当升级到4.0模式的时候，只需要简单的改变存在的<code>idref local</code>引用为<code>idref bean</code>引用。与用<code>&lt;idref/&gt;``元素携带值相同的一个地方是在一个AOP拦截器的配置中配置一个ProxyFactoryBean</code> bean定义的地方。当你指定拦截器的名字时，使用<code>&lt;idref/&gt;</code>元素可以避免一个拦截器id的拼写错误。</p>
<h5 id="引用其他bean（协作者）"><a href="#引用其他bean（协作者）" class="headerlink" title="引用其他bean（协作者）"></a>引用其他bean（协作者）</h5><p><code>ref</code>元素是在<code>&lt;constructor-arg/&gt;</code>或 <code>property/&gt;</code>定义元素中的最后一个元素。这里设置指定的bean的属性的值，该值是容器管理的另一bean（一个协作者）的引用。该引用bean是被设置属性的bean的依赖，一旦需要就会在属性设置前初始化。（如果合作者是一个单例bean，可能已经被容器初始化）。所有的引用最终都是另一个对象的引用。审视和校验依赖于你是否通过<code>bean</code>, <code>local</code>,或<code>parent</code>属性指定别的对象的id/name。</p>
<p>通过<code>&lt;ref/&gt;</code>标签的bean属性指定目标bean是最通用的形式，在同一个容器或父容器中允许任何bean引用的创建，且不管是否在同一个XML文件中。<code>bean</code>属性的值也许会与目标bean的<code>id</code>属性相同，或是作为目标bean的name属性中值之一。</p>
<pre><code>&lt;ref bean=&quot;someBean&quot;/&gt;
</code></pre><p>通过<code>parent</code>属性创建一个在父容器或当前容器中的bean的引用来指定目标bean。<code>parent</code>属性的值要不与目标bean的id属性值相同，要不是目标bean的<code>name</code>属性中的值之一，且目标bean必须在当前容器的一个父容器中。当你有一个分层的容器，且想通过一个名称可能与父bean相同的代理来封装一个存在父容器中bean时，主要使用这种bean引用的变体。</p>
<pre><code>&lt;!-- in the parent context --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.SimpleAccountService&quot;&gt;
    &lt;!-- insert dependencies as required as here --&gt;
&lt;/bean&gt;
</code></pre><p>-</p>
<pre><code>&lt;!-- in the child (descendant) context --&gt;
&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>在 4.0 beans xsd中，ref元素不再支持local属性，因为它不再提供任何超过常规bean引用的值。当升级到4.0模式时，只需要简单的改变存在的<code>ref local</code> 引用为<code>ref bean</code>引用。</p>
</blockquote>
<h5 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h5><p>在<code>&lt;property/&gt;</code> 或 <code>&lt;constructor-arg/&gt;</code>元素中的一个<bean>元素定义了一个所谓的<em>内部bean</em>。</bean></p>
<pre><code>&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>一个内部bean的定义不需要id或name的定义；即便指定，容器也不会使用这个值作为一个标识。容器还忽略了创建物（bean）上的<code>scope</code>标记：内部bean总是匿名的，且他们总是用外部bean来创建。把内部bean注入到协作的bean中是不可能的，除非进入封装的bean中，或是能独立地访问它们。作为一个少见的问题，不可能收到来自用户的销毁方法的回调，一个请求中，内部bean被包含在一个单例bean中：内部bean实例的创建会被绑定到包含它的bean上，但在请求范围的生命周期中销毁方法的回调允许它参与。这是一个不常见的情况；内部bean只是简单的享有包含它们的bean的作用域。</p>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>在<code>&lt;list/&gt;</code>,<code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;props/&gt;</code> 元素中，你可以分别设置Java集合类型List、Set、Map和Properties的属性和参数。</p>
<pre><code>&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>一个map的key或value，或者是一个集合的value的值,也可以再次成为如下的任何元素的值：</p>
<pre><code>bean | ref | idref | list | set | map | props | value | null
</code></pre><h5 id="集合归并"><a href="#集合归并" class="headerlink" title="集合归并"></a>集合归并</h5><p>Spring容器也支持集合的归并。一个应用的开发者可以定义一个父样式<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，并且有一个子样式<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code>元素继承和复写来自父集合的值。也就是说，子集合的值是归并父和子集合元素的结果，孩子的集合元素覆盖在父集合中指定的值。</p>
<p>本部分合并讨论父子bean的原理。读者如果不熟悉父和子的bean定义，在继续之前可以先阅读下<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#beans-child-bean-definitions" target="_blank" rel="external">相关的章节</a></p>
<p>下面例子示范了集合的归并：</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;administrator&quot;&gt;administrator@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge=&quot;true&quot;&gt;
                &lt;prop key=&quot;sales&quot;&gt;sales@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.co.uk&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;
</code></pre><p>注意使用在<code>child bean</code>定义的<code>adminEmails</code>属性的<props>元素上的<code>merge=true</code>属性。当<code>child</code> bean被容器解析和实例化，由此产生的实例有一个<code>adminEmails Properties</code>集合，该集合包含归并孩子的<code>adminEmails</code>集合和父亲的<code>adminEmails</code> 集合的结果。</props></p>
<p>administrator=administrator@example.com</p>
<p>sales=sales@example.com</p>
<p>support=support@example.co.uk</p>
<p>孩子<code>Properties</code> 集合的值被设置为从父元素<code>&lt;props/&gt;</code>继承所有的属性元素，孩子的值，也就是<code>support</code>值覆盖父集合中的值。</p>
<p>这种合并行为同样适用于<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;set/&gt;</code>集合类型。在<list>元素的特殊情况下，器语言与<code>List</code>集合类型相关。也就是说，一个<code>ordered</code>集合的值的概念是被保持的，父集合的值在所有孩子链表的值的前面。在Map，Set和Properties集合的类型的情形下，是没有顺序可说的。因此没有顺序语义影响集合类型，这些类型成为相关的Map，Set和Properties的容器内部使用的实现类型的基础</list></p>
<h5 id="集合合并的限制"><a href="#集合合并的限制" class="headerlink" title="集合合并的限制"></a>集合合并的限制</h5><p>不能和并不同的集合类型（如Map和List），如果你尝试这样做，就会抛出一个恰当的异常。<code>merge</code>属性必须在下级的，继承的孩子定义上指定。在一个父集合定义上指定<code>merge</code>属性是多余的，且可能不会产生希望的合并结果。</p>
<h5 id="强类型集合"><a href="#强类型集合" class="headerlink" title="强类型集合"></a>强类型集合</h5><p>随着Java5中泛型的引入，你可以使用强类型的集合了。也就是说，可以申明一个<code>Collection</code>类型，因此，这个集合中只可以包含<code>String</code>元素（例如）。如果你使用Spring依赖注入一个强类型<code>Collection</code>到一个Bean中，你可以利用Spring的类型转换支持强类型<code>Collection</code>的实例的元素转变为合适的类型，这个类型是先被加入<code>Collection</code>中的。</p>
<pre><code>public class Foo {

    private Map&lt;String, Float&gt; accounts;

    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}
</code></pre><p>-</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;property name=&quot;accounts&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;
                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;
                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>当<code>foo</code> bean的<code>accounts</code>属性准备好注入时，通过反射，关于强类型<code>Map&lt;String, Float&gt;</code>的元素类型的通用信息是可以获得的。</p>
<h5 id="Null-和空字符串值"><a href="#Null-和空字符串值" class="headerlink" title="Null 和空字符串值"></a>Null 和空字符串值</h5><p>Spring处理属性的空参数如同处理空<code>Strings</code>.如下的基于XML的配置元数据的片段，设置<code>email</code>属性为空<code>String</code>值（””）</p>
<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>上面的例子等价于如下的Java代码：</p>
<pre><code>exampleBean.setEmail(&quot;&quot;)
</code></pre><p><code>&lt;null/&gt;</code>元素处理<code>null</code>值，如：</p>
<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>上面的配置等价于如下的Java代码：</p>
<pre><code>exampleBean.setEmail(null)
</code></pre><h5 id="通过p-namespace精简XML配置"><a href="#通过p-namespace精简XML配置" class="headerlink" title="通过p-namespace精简XML配置"></a>通过p-namespace精简XML配置</h5><p>p 命名空间使你可以使用<code>bean</code>元素的属性替代嵌套的<code>&lt;property/&gt;</code>元素来描述你的属性值和/或协作bean。</p>
<p>通过命名空间，Spring支持可扩展的配置格式，这是基于一个XML Schema 定义。本章讨论的配置格式被定义在一个 XML Schema文档中。然而 p-namespace并没有定义在XSD文件中，值存在Spring的核心中。</p>
<p>下面的例子中包含两个XML片段，都是用来解决相同的问题：第一个使用标准的XML格式，第二个使用p-namespace。</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;foo@bar.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;foo@bar.com&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>上面的例子演示了在p-namespace bean的定义中一个叫做email的属性。告诉Spring包含一个属性声明。正如前面提及的，p-namespace没有schema定义，因此你可以设置这个属性名到属性（property）名。</p>
<p>下列含有超过两个bean的定义，都引用另一个bean：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;
        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;john-modern&quot;
        class=&quot;com.example.Person&quot;
        p:name=&quot;John Doe&quot;
        p:spouse-ref=&quot;jane&quot;/&gt;

    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>如你所见，本例包含了不止一个使用p-namespace的属性值，但都使用了一个特殊的格式 来声明属性的引用。第一个bean的定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>创建了一个<code>John</code>到<code>Jane</code>的引用，第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为一个属性来完成完全相同的事。在本例中<code>spouse</code> 是属性名，鉴于<code>-ref</code>部分，表明这个不是直接的值，而是相当于对另一个bean的引用。</p>
<blockquote>
<p>p-namespace并不比标准的XML格式灵活，例如，这种格式声明的属性引用会与以<code>ref</code>结尾的属性冲突，然而标准的XML格式就不会有这个问题。为避免在同一时间使用所有的三种方式来生成XML文档，我们建议仔细选择你的方式，并把这个信息传达给你的团队成员。</p>
</blockquote>
<h5 id="通过c-namespace精简XML配置"><a href="#通过c-namespace精简XML配置" class="headerlink" title="通过c-namespace精简XML配置"></a>通过c-namespace精简XML配置</h5><p>与“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-p-namespace" target="_blank" rel="external">通过p-namespace精简XML配置</a>”节相似，c-namespace在Spring3.1开始引入，允许使用内部属性来配置构造函数的参数代替内嵌的<code>constructor-arg</code>元素。</p>
<p>回顾“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-constructor-injection" target="_blank" rel="external">基于构造函数依赖注入</a>”章节关于<code>c:</code>命名空间的例子：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot;/&gt;
    &lt;bean id=&quot;baz&quot; class=&quot;x.y.Baz&quot;/&gt;

    &lt;!-- traditional declaration --&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;constructor-arg ref=&quot;bar&quot;/&gt;
        &lt;constructor-arg ref=&quot;baz&quot;/&gt;
        &lt;constructor-arg value=&quot;foo@bar.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration --&gt;
    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot; c:bar-ref=&quot;bar&quot; c:baz-ref=&quot;baz&quot; c:email=&quot;foo@bar.com&quot;/&gt;

&lt;/beans&gt;
</code></pre><p>关于通过名称设置构造函数参数，c:命名空间使用与p:命名空间相同的约定（bean的引用以-ref结尾）。即便你没有在XSD模式中定义它，这也无妨，你只需要声明就行。</p>
<p>对于构造参数不可用（通常如果编译的字节码没有debuggig信息的话）的稀有情景，你可以使用给参数加上索引的备用方法：</p>
<pre><code>&lt;!-- c-namespace index declaration --&gt;
&lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot; c:_0-ref=&quot;bar&quot; c:_1-ref=&quot;baz&quot;/&gt;
</code></pre><blockquote>
<p>由于XML的语法的原因，索引符号需要以<code>_</code>开头，就像XML的属性名称一样，不能以数字开头（即便有些IDE是允许这样的）。</p>
</blockquote>
<p>实际上，在匹配参数上构造函数解决<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-ctor-arguments-resolution" target="_blank" rel="external">机制</a>是十分有效的。所以除非真的需要，否建议使用name符号贯穿整个配置。</p>
<h5 id="混合属性名称"><a href="#混合属性名称" class="headerlink" title="混合属性名称"></a>混合属性名称</h5><p>当设置bean属性时，可以使用混合的或者嵌套的属性名称，只要所有的path组件出最终属性属性名外都不是<code>null</code>。思考如下的bean定义：</p>
<pre><code>&lt;bean id=&quot;foo&quot; class=&quot;foo.Bar&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre><p><code>foo</code> bean有一个<code>fred</code>属性，<code>fred</code>属性有一个<code>bob</code>属性，<code>bob</code>属性有一个<code>sammy</code>属性，最终的<code>sammy</code>属性被设置为<code>123</code>。为了使其能起作用，<code>bean</code>构造后，<code>foo</code>的<code>fred</code>属性，<code>fred</code>的<code>bob</code>属性必须不是<code>null</code>，或者不能抛出<code>NullPointerException</code>异常。 </p>
<h4 id="3-4-3-使用依赖"><a href="#3-4-3-使用依赖" class="headerlink" title="3.4.3 使用依赖"></a>3.4.3 使用依赖</h4><p>如果一个bean另一个bean的依赖，那通常就表示这个bean被设置为了另一个bean的属性（内容）。典型的是，通过基于XML的配置元数据中的<ref>元素来完成这项功能。然而，有时候bean之间的依赖并不是直接的；如，在一个class中的一个静态初始化方法需要被触发，比如数据库驱动注册（database driver registration）。在bean使用的元素被初始化之前，<code>depends-on</code>属性可以明确地强制一个或多个bean初始化。如下，使用<code>depends-on</code>属性来传递了一个单bean上的依赖。</ref></p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;
&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
</code></pre><p>为了表示在多个bean上的依赖，提供一个bean的名称列表作为<code>depends-on</code>属性的值，其中的逗号，空格和分号作为校验分隔符：</p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;
    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;
</code></pre><p>在bean的定义中的<code>depends-on</code>属性既可以指定初始化时的依赖，如果只是一个单例bean的话，也可以指定对应的销毁时的依赖，从属的bean定义了一个<code>depends-on</code>与一个给定bean关系，且会被首先销毁，优先销毁给定的bean自身，也就是说<code>depends-on</code>也可以控制关闭顺序。</p>
<h4 id="3-4-4-bean的Lazy初始化"><a href="#3-4-4-bean的Lazy初始化" class="headerlink" title="3.4.4 bean的Lazy初始化"></a>3.4.4 bean的Lazy初始化</h4><p>默认情况下，ApplicationContext 实现希望创建和配置所有的单例beans，以作为初始化程序的一部分。一般情况下，这种预先实例化的方式是很有必要的，因为在配置中或者与环境相关的错误会及时被发现，不然的话很可能是几个小时，甚至几天之后才会被发现。当不满意这样的行为时，你可以通过标记bean定义为lazy-initialized来阻止一个单例bean的预实例化。一个lazy-initialied bean告知IoC容器，只有当一个bean第一次被请求时才创建其实例化，而不是在启动的时候就创建。</p>
<p>在XML文件中，通过,<bean>元素的lazy-init属性来控制lazy初始化行为。例如：</bean></p>
<pre><code>&lt;bean id=&quot;lazy&quot; class=&quot;com.foo.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.foo.AnotherBean&quot;/&gt;
</code></pre><p>当上面的配置被一个<code>ApplicationContext</code>消费时，在<code>ApplicationContext</code> 启动时，命名为<code>lazy</code>的bean需希望被预实例化，而命名为<code>not.lazy</code>的可以预实例化。</p>
<p>然而，当一个lazy初始化bean是一个非lazy初始化的单例bean的依赖时，<code>ApplicationContext</code> 就会在启动时创建lazy初始化bean，这是为了满足单例的依赖。lazy初始化的bean被注入到一个单例bean中，那么在别的地方就不再是lazy bean。</p>
<p>通过使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init属</code>性，可以在容器级别控制懒初始化。例如：</p>
<pre><code>&lt;beans default-lazy-init=&quot;true&quot;&gt;
    &lt;!-- no beans will be pre-instantiated... --&gt;
&lt;/beans&gt;
</code></pre><h4 id="3-4-5-自动装配协作对象"><a href="#3-4-5-自动装配协作对象" class="headerlink" title="3.4.5 自动装配协作对象"></a>3.4.5 自动装配协作对象</h4><p>Spring容器可以在协作bean之间进行自动关联，你可以允许Spring通过检查ApplicationContext中的内容，以自动地解决你的bean的协作者（其他的bean）。自动封装有一下一些优势：</p>
<ul>
<li>自动封装明显地减少需要指定的属性或者构造参数（就这点而言，别的机制，如在本章其他地方讨论的bean模板也是有价值的）。</li>
<li>当你的对象演变时，自动封装可以更新配置。例如，如果你需要为一个class增加依赖，它可以自动满足需求而不需要修改配置。也就是说自动装配在开发的时候是特别有用的，不可否认，当代码基础变得稳定后可以切换到精确配置这个选项上来。</li>
</ul>
<p>在使用基于XML的配置元数据时，你可以为一个通过<bean>元素的autowire属性定义的bean指定自动装配的模式。自动装配功能有四种模式，你可以为每个bean指定自动装配机制，也就是说你可以选择为哪一个bean进行自动装配。</bean></p>
<p>表3.2 自动装配模式</p>
<p><table><br>    <tr><br>        <th>模式</th><th><br>        </th><th>解释</th><th><br>    </th></tr><tr><br>    </tr><tr><br>        <td>no</td><td><br>        </td><td>（默认）没有自动包装，bean的引用必须通过<code>ref</code>元素定义，对于比较大的部署，不建议改变默认设置，因为精确地描述一个协作者，需要提供更多的控制和透明度，一定程度上来说，这种方式记录了系统的结构</td><td><br>    </td></tr><tr><br>    </tr><tr><br>        <td>byName</td><td><br>        </td><td>通过属性名称自动封装，Spring查询有相同属性名的，需要自动封装的bean。例如，如果一个bean的定义被设置为通过名称自动封装，并且包含一个master属性（就是 有一个setMaster(..)方法），Spring寻找一个名称为<code>master</code>的bean定义，并使用它来设置属性</td><td><br>    </td></tr><tr><br>    </tr><tr><br>        <td>byType</td><td><br>        </td><td>如果恰好一个bean的属性类型存在一个容器中，那么可以自动封装该属性。如果存在超过一个，就会抛出一个毁灭性的异常，这就表明你可能没使用<em>byType</em>自动包装这个bean，如果没有匹配的bean，就什么都不会发生，属性就不会被设置</td><td><br>    </td></tr><tr><br>    </tr><tr><br>        <td>constructor</td><td><br>        </td><td>类似<em>byType</em>，但是使用了构造参数，如果在容器中恰好不存在一个构造器的参数类型的bean，那么就会产生一个严重错误</td><td><br>    </td></tr><tr></tr></table></p>
<table>




<p>通过<em>byType</em>和<em>constructor</em>的自动封装模式，你可以包装数组和有类型集合，在这种情形下，容器中的所有的匹配所需类型的自动包装候选者用于满足依赖。如果key的类型是<code>String</code>，你可以自动包装强类型的Map。一个自动包装的Map的值将由满足预期类型bean实例组成，Map的键会包含相应的bean名称。</p>
<p>你可以把自动包装行为和依赖检查结合起来，依赖检查是在自动包装后执行的。</p>
<h5 id="自动包装的劣势和限制"><a href="#自动包装的劣势和限制" class="headerlink" title="自动包装的劣势和限制"></a>自动包装的劣势和限制</h5><p>在整个项目中一直使用自动包装机制，使得自动包装能更好的起作用。如果自动包装不被普遍使用，而只被使用来包装一两个bean定义会令开发者感到迷惑。</p>
<p>考虑自动包装的限制和缺点：</p>
<ul>
<li>在<code>property</code>和<code>constructor-arg</code>中设置的明确依赖总是会覆盖自动包装。你不能封装所谓的简单属性，比如基本类型，<code>Strings</code>，和<code>Classes</code>（和这些简单类型的数组），这个限制是设计时就有的。</li>
<li>自动封装没有精确封装准确。尽管如上表所诉，但Spring还是很小心的避免在模拟两可的情况下进行猜测，这种情况也许会导致难以预料的结果，Spring所管理的对象之间关系不再被精确的记录。</li>
<li>包装信息对于从Spring容器生成一个文档的工具来说可能是没有用的。</li>
<li>容器中的多个bean定义可以匹配setter方法和构造函数参数指定的类型，从而达到自动包装。对于数组，集合或Maps，这都不是问题。然而对于单值的依赖，这种含糊是难以解决的。如果非独立的bean定义是可用的，就会抛出一个异常。</li>
</ul>
<p>在最新的方案中，你有以下几种选择：</p>
<ul>
<li>放弃自动包装而改用精确的封装</li>
<li>如下一节描述的一样，为避免对一个<code>bean</code>定义进行自动包装，可以通过设置它的<code>autowire-candidate</code>属性为<code>false</code>。</li>
<li>通过设置bean元素的<code>primary</code>属性为<code>true</code>,指派一个单例bean定义作为最初的候选者。</li>
<li>通过基于注解的配置可以实施更细粒度的控制，如<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-annotation-config" target="_blank" rel="external">3.9 “基于注解的容器配置”</a>中所述。</li>
</ul>
<h5 id="排除bean自动包装"><a href="#排除bean自动包装" class="headerlink" title="排除bean自动包装"></a>排除bean自动包装</h5><p>在每个bean的基础上，可以排除一个bean的自动包装，在spring的XML格式中，设置<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性为<code>false</code>;容器使得特殊的bean定义不能包装基础构件（包括注解方式的配置，如<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-autowired-annotation" target="_blank" rel="external"><code>@Autowired</code></a>）</p>
<blockquote>
<p>autowire-candidate属性被设计成只影响基于类型的自动包装。它不影响通过名称的精确引用，该引用将会转变，即便指定的bean没有被标记为一个自动包装的候选对象。因此，通过名字的自动包装将不会注入，除非名称匹配。</p>
</blockquote>
<p>通过基于bean名称相关的模式匹配，你可以限制自动包装的候选者。顶级的<beans>元素，在它的default-autowire-candidates属性中，可以接受一个或多个模式。例如，为了限制任何名称以Repository结尾的bean的自动包装候选者的状态，以*Repository作为值。为了提供多个模式，把它们定义在以逗号分隔的list中。一个bean定义的autowire-candidate属性的精确值，true或者false,总是被优先考虑，对于这样的bean，模式匹配规则不起作用。</beans></p>
<p>这种技术对那些你从来不想通过自动包装注入到其他bean中的bean来说是有用的。这也并不意味着被排除的bean不能通过自动包装配置。也就是说，bean本身不能成为包装其他bean的候选者。</p>
<h4 id="3-4-6-方法注入"><a href="#3-4-6-方法注入" class="headerlink" title="3.4.6 方法注入"></a>3.4.6 方法注入</h4><p>在大部分的应用场景中，容器中的大部分bean是单例。当一个单例bean需要与另一个单例bean协作，或者是一个非单例bean需要与另一个非单例bean协作，你典型的处理依赖的方式是定义一个bean成为另一个bean的依赖。当bean的生命周期不同的时候，就会导致一个问题。假设单例bean A需要使用非单例bean B，或许在A的每个方法调用上。容器只会创建单例bean一次，也就是说只有一次机会设置属性，容器不能给bean A 提供一个bean B的实例在每次需要一个bean B的时候。</p>
<p>一个解决办法是放弃一些依赖倒置。你可以通过实现ApplicationContextAware接口使得bean A能意识到容器的存在，每当bean A需要bean B的时候，可以通过创建一个getBean(“B”)来调用容器获取bean B实例。如下是该方法的一个例子：</p>
<pre><code>// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre><p>前面的方法难以令人满意，因为业务代码与Spring Framework耦合在一起了。方法注入，有点Spring IoC容器的优秀特点，允许以一个清晰的方式处理这个用例。</p>
<pre><code>你可以[这篇博客条目](https://spring.io/blog/2004/08/06/method-injection/)中阅读更多的关于方法注入的的优势。
</code></pre><h5 id="Lookup方法注入"><a href="#Lookup方法注入" class="headerlink" title="Lookup方法注入"></a>Lookup方法注入</h5><p>Lookup方法注入是容器覆盖在容器管理的bean上的方法的能力，为容器中的另一个bean返回查询结果。lookup涉及到的特殊情况是一个原型bean，正如在前面的章节的场景中所描述的一样。Spring Framework实现这种方法注入是通过字节码生成器，该生成器是使用CGLIB 库动态地生成一个复写该方法的子类。</p>
<blockquote>
<ul>
<li>为了使这个动态的子类生效，Spring bean容器将要收集的这个类不能是final的，将要被覆盖的方法也不能是final的。</li>
<li>单元测试一个有abstract方法的类，要求你自己子类化该类，并为该abstract方法提供一个桩(stub)实现。</li>
<li>对于要求具体类来完成的组件组件扫描，具体的方法也是必须的。 </li>
<li>一个最关键的限制是lookup方法不能与工厂方法一起工作，尤其是不能与配置类中的使用@Bean注解的方法一起工作，因为在这种情况下容器不负责创建实例，因此不能在运行时快速生成子类。</li>
</ul>
</blockquote>
<p>看看在前面的代码片段中的CommandManager 类，你会发现Spring容器会动态的覆盖createCommand()方法的实现。你的CommandManager 类将会没有的任何的Spring依赖，正如下面重写的例子所示;</p>
<pre><code>package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
</code></pre><p>在客户端类中包含将要注入的方法（如这种情形下的CommandManager 类），需要被注入的类要求有一个如下的格式的签名：</p>
<pre><code>&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);
</code></pre><p>如果该方法是abstract的，需要动态生成的子类实现该方法。否则的话，动态生成的子类需要覆盖在原始类中定义的具体的方法。如：</p>
<pre><code>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>无论什么时候，标识为commandManager 的bean需要一个myCommand bean的新实例，它都会调用它自己的createCommand()方法。如果真的需要把myCommand bean部署为一个原型，你必须小心谨慎的。如果它是一个单例，每次都返回myCommand bean的同一个实例。</p>
<p>或者在一个基于注解的组件模型中，你可能会通过@Lookup注解声明一个lookup方法：</p>
<pre><code>public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup(&quot;myCommand&quot;)
    protected abstract Command createCommand();
}
</code></pre><p>或者，更常用的是，你可以依赖目标bean获取解决方法，依靠lookup方法声明的返回类型：</p>
<pre><code>public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
</code></pre><p>注意，为了使这些方法与Spring的组件扫在描默认情况下忽略抽象类的规则兼容，你可以有代表性地声明这样的带有注解的lookup方法，使得其有一个具体的桩(stub)实现。</p>
<blockquote>
<p>另一种访问不同作用域的目标bean的方法是一个ObjectFactory/ Provider注入点。查看章节“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-scopes-other-injection" target="_blank" rel="external">Scoped beans as dependencies</a>”。</p>
<p>感兴趣的读者也可以查看ServiceLocatorFactoryBean（在org.springframework.beans.factory.config包中） 的使用。</p>
</blockquote>
<h5 id="任意的方法替换"><a href="#任意的方法替换" class="headerlink" title="任意的方法替换"></a>任意的方法替换</h5><p>一个比lookup方法注入更少使用的方法注入形式是替所换管理的通过另一个方法实现的bean中的任何方法的能力。</p>
<p>根据基于XML配置的元数据，为了部署bean，你可以使用replaced-method元素替换一个存在的，通过另一个bean实现的方法。考虑如下的类，它有一个computeValue方法，这个方法是我们想覆盖的：</p>
<pre><code>public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...

}
</code></pre><p>一个实现了org.springframework.beans.factory.support.MethodReplacer接口的类提供了一个新的方法定义：</p>
<pre><code>/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
</code></pre><p>部署原始类并指定覆盖的方法的bean定义，就像下面这样：</p>
<pre><code>&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;
</code></pre><p>你可以使用一个或多个包在<replaced-method>元素中的<arg-type>元素来指定将要被覆盖的方法的签名。在类中，只有方法被重载和存在多个变体的情况，参数才需要签名。为方便起见，输入的参数字符串可以是全限定类名的字符串的子串。例如，如下的都匹配java.lang.String：</arg-type></replaced-method></p>
<pre><code>java.lang.String
String
Str
</code></pre><p>因为参数的数量通常足够区分每个可能的选择，这个简写可以节约键入次数，允许你只键入最短的字符串就可以匹配一个参数类型。</p>
<h3 id="3-5-Bean作用域"><a href="#3-5-Bean作用域" class="headerlink" title="3.5 Bean作用域"></a>3.5 Bean作用域</h3><p>当你创建一个bean定义的时候，实际上是为通过bean定义定义的类的创建真实的实例建立了一个菜谱。把一个bean的定义看做菜谱的观点是很重要的，因为这意味着，就一个类来说，你可以从一个单一的菜谱创建许多对象实例。</p>
<p>你能控制的不只有各种各样的依赖和塞入一个由一个特殊的bean定义创建的对象中的配置值，而且还包括由特殊bean定义创建的对象的作用域。在你能选择的对象的作用域中，这种方法是强大和灵活的，所选折的对象是通过配置而不是必须在Java类级别的对象作用域中创建的。可以把Bean定义为部署到多个作用域中的一个：创造性地，Spring Framework 支持留个作用域，其中的五个只有在你使用web方面的<code>ApplicationContext</code>时才起效。</p>
<p>如下的作用域支持开箱即用，你也可以创建传统的作用域：</p>
<p><table><br>    <tr><br>        <th>Scope</th><br>        <th>描述</th><br>    </tr><br>    <tr><br>        <th>singleton</th><br>        <th>(默认)每个Spring IoC容器都会把单一的bean定义映射为一个单一的对象实例</th><br>    </tr><br>    <tr><br>        <th>prototype</th><br>        <th>把一个单一的bean定义映射到任何数量的对象实例</th><br>    </tr><br>    <tr><br>        <th>request</th><br>        <th>把一个单一的bean定义映射到单个HTTP请求的生命周期中，也就会说每个HTPP请求有一个它自身的一个bean实例，该bean反复被一个单一的bean定义创建，只有在web感知的Spring ApplicationContext的上下文中才有效</th><br>    </tr><br>    <tr><br>        <th>session</th><br>        <th>Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.</th><br>    </tr><br>    <tr><br>        <th>application</th><br>        <th>Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.</th><br>    </tr><br>    <tr><br>        <th>application</th><br>        <th>Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.</th><br>    </tr><br></table></p>
<blockquote>
<p>Spring3.0之后，一个线程级的作用域是可用的，但没有默认注册。更多的信息见<a href="http://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/SimpleThreadScope.html" target="_blank" rel="external"><code>SimpleThreadScope</code></a>相关的文档。关于怎样注册这个作用或者其他的惯用的作用域，查看“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom-using" target="_blank" rel="external">使用一个常用作用域</a>”这节。</p>
</blockquote>
<h4 id="3-5-1-单例作用域"><a href="#3-5-1-单例作用域" class="headerlink" title="3.5.1 单例作用域"></a>3.5.1 单例作用域</h4><p>一个被管理的单例bean只有一个共享的实例，所有通过ID或IDS匹配bean定义的bean请求导致一个特殊的bean实例被Spring容器返回。</p>
<p>换句话说，当你定义一个bean定义，它被定义为一个单例，Spring IoC容器精确地创建一个通过bean定义定义的对象实例。这个单实例被存储在一个类似单例bean的缓存中，所有后面的关于这个bean的请求和引用，返回的都是这个对象。</p>
<p><img src="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/singleton.png.pagespeed.ce.U0lSEQUK39.png" alt=""><br>Spring单例bean的概念不同于在 Gang of Four (GoF)中定义的单例模式。GoF单例硬编码一个对象的作用域，对于每个类加载器一个特殊的类只被创建一次，Spring单例的作用域最好描述为一个容器一个bean。这意味着在一个单一的容器中如果你为一个特殊的类定义了一个bean，那么Spring容器创建一个，且只创建一个通过bean定义定义的类实例。Spring中的单例作用域就是默认的作用域。为了在XML文件中把一个bean定义为单例，你会像下面一样编写这个XML文件：</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot;/&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre><h3 id="3-5-2-原型作用域"><a href="#3-5-2-原型作用域" class="headerlink" title="3.5.2 原型作用域"></a>3.5.2 原型作用域</h3><p>非单例，bean的原型作用域的部署导致一个新的bean实例创建，每次对这个特殊bean的请求都会创建这个bean。也就是说，这个bean被注入到另一个bean中，或者你可以通过getBean()方法在容器上回调来请求这个bean。作为一个规则，为所有有状态的bean使用原型作用域，为所有的无状态的bean使用单例。</p>
<p>下图阐明了Spring的原型作用域，一个数据访问对象（DAO）通常不配置为一个原型，因为一个典型的DAO没有持有任何的会话状态。这里作者只是简单的复用单例图的核心：</p>
<p><img src="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/prototype.png.pagespeed.ce._EP1ydjN29.png" alt=""><br>如下例子，在XML文件中定义了一个原型bean：</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;
</code></pre><p>与其他的作用域进行对比，Spring并没有管理一个原型bean的完整生命周期：容器实例化、配置，另外还集合一个原型对象，并把它推送给用户，除此之外并没有更多的关于原型实例的记录。    那就是，尽管初始化生命周期的回调方法在所有不分作用域的对象上被调用，但是在原型作用域的情况下，销毁生命周期回调函数的配置不被调用。客户端代码必须清理原型作用域对象，并且释放原型bean占有的宝贵的资源。为了获得Spring容器释放的被原型作用域bean占有的资源，试着使用一个常用的 bean 提交处理器，该处理器拥有需要被清理的bean的引用。</p>
<p>某些情况下，Spring容器关于原型作用域bean的角色是Java new操作符的代替者。全生命周期管理越过那个点，就必须被客户端处理。（关于Spring容器中的bean的生命周期的详细信息，可以参考3.6.1节，“<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-factory-lifecycle" target="_blank" rel="external">生命周期回调</a>”）</p>
</table></dependencies>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Spring-依赖和依赖于Spring&quot;&gt;&lt;a href=&quot;#Spring-依赖和依赖于Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring 依赖和依赖于Spring&quot;&gt;&lt;/a&gt;Spring 依赖和依赖于Spring&lt;/h4&gt;&lt;p&gt;尽管
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GVim的编码设置</title>
    <link href="http://yoursite.com/2017/04/04/GVim%E7%9A%84%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/04/04/GVim的编码设置/</id>
    <published>2017-04-04T10:48:09.000Z</published>
    <updated>2017-04-04T10:53:17.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gvim的基本设置"><a href="#gvim的基本设置" class="headerlink" title="gvim的基本设置"></a>gvim的基本设置</h1><hr>
<h2 id="编码设置"><a href="#编码设置" class="headerlink" title="编码设置"></a>编码设置</h2><p><code>set fileencodings=utf-8,chinese,latin-1</code></p>
<p><code>set termencoding=utf-8</code></p>
<p><code>set encoding=utf-</code></p>
]]></content>
    
    <summary type="html">
    
      在使用vim过程中的一些总结
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="工具类学习" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
